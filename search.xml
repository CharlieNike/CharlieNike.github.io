<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MySQL8.0的帮助信息]]></title>
    <url>%2F2018%2F07%2F27%2FMySQL8.0%E7%9A%84%E5%B8%AE%E5%8A%A9%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[整理：房玉辉 博客：https://ElonJelinek.github.ioMySQL8.0的帮助信息MySQL8.0版本相比于MySQL5.0做了很多的更改，有很多函数和字段都被删除了，因此之前网上的很多操作，现在已经不适用于8.0版本了，由于8.0版本是近期才更新的，所以对新手来说，会遇到很多的坑，而且一些坑在网上还找不到答案，所以跳坑最好的方法，就是查看MySQL自带的帮助信息，这里列出来一部分查看帮助信息的命令，以及一些帮助信息。 当然，帮助信息需要在安装MySQL8.0并登陆成功之后，才能查看得到，并且需要有一定的英语基础。 另外，跳坑最好的方法，就是不断地尝试，不断地总结，做记录。 账户管理123456789101112131415161718192021mysql&gt; help account management;You asked for help about help category: "Account Management"For more information, type 'help &lt;item&gt;', where &lt;item&gt; is one of the followingtopics: ALTER RESOURCE GROUP ALTER USER CREATE RESOURCE GROUP CREATE ROLE CREATE USER DROP RESOURCE GROUP DROP ROLE DROP USER GRANT RENAME USER REVOKE SET DEFAULT ROLE SET PASSWORD SET RESOURCE GROUP SET ROLEmysql&gt; 创建用户：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495mysql&gt; help create user;Name: 'CREATE USER'Description:Syntax:CREATE USER [IF NOT EXISTS] user [auth_option] [, user [auth_option]] ... DEFAULT ROLE role [, role ] ... [REQUIRE &#123;NONE | tls_option [[AND] tls_option] ...&#125;] [WITH resource_option [resource_option] ...] [password_option | lock_option] ...user: (see )auth_option: &#123; IDENTIFIED BY 'auth_string' | IDENTIFIED WITH auth_plugin | IDENTIFIED WITH auth_plugin BY 'auth_string' | IDENTIFIED WITH auth_plugin AS 'hash_string' | IDENTIFIED BY PASSWORD 'hash_string'&#125;tls_option: &#123; SSL | X509 | CIPHER 'cipher' | ISSUER 'issuer' | SUBJECT 'subject'&#125;resource_option: &#123; MAX_QUERIES_PER_HOUR count | MAX_UPDATES_PER_HOUR count | MAX_CONNECTIONS_PER_HOUR count | MAX_USER_CONNECTIONS count&#125;password_option: &#123; PASSWORD EXPIRE | PASSWORD EXPIRE DEFAULT | PASSWORD EXPIRE NEVER | PASSWORD EXPIRE INTERVAL N DAY | PASSWORD HISTORY DEFAULT | PASSWORD HISTORY N | PASSWORD REUSE INTERVAL DEFAULT | PASSWORD REUSE INTERVAL N DAY&#125;lock_option: &#123; ACCOUNT LOCK | ACCOUNT UNLOCK&#125;The CREATE USER statement creates new MySQL accounts. It enablesauthentication, SSL/TLS, resource-limit, and password-managementproperties to be established for new accounts, and controls whetheraccounts are initially locked or unlocked.To use CREATE USER, you must have the global CREATE USER privilege, orthe INSERT privilege for the mysql database. When the read_only systemvariable is enabled, CREATE USER additionally requires theCONNECTION_ADMIN or SUPER privilege.CREATE USER either succeeds for all named users or rolls back and hasno effect if any error occurs. By default, an error occurs if you tryto create a user that already exists. If the IF NOT EXISTS clause isgiven, the statement produces a warning for each named user thatalready exists, rather than an error.The statement is written to the binary log if it succeeds, but not ifit fails; in that case, rollback occurs and no changes are made. Astatement written to the binary log includes all named users. If the IFNOT EXISTS clause is given, this includes even users that already existand were not created.The statement written to the binary log specifies an authenticationplugin for each user, determined as follows:o The plugin named in the original statement, if one was specified.o Otherwise, the default authentication plugin. In particular, if a user u1 already exists and uses a nondefault authentication plugin, the statement written to the binary log for CREATE USER IF NOT EXISTS u1 names the default authentication plugin. (If the statement written to the binary log must specify a nondefault authentication plugin for a user, include it in the original statement.)If the server adds the default authentication plugin for anynonexisting users in the statement written to the binary log, it writesa warning to the error log naming those users.URL: http://dev.mysql.com/doc/refman/8.0/en/create-user.htmlmysql&gt; 修改密码新的方法为 set password for root@localhost = &#39;123456&#39;; 1234mysql&gt; set password for root@localhost = '123456';Query OK, 0 rows affected (0.04 sec)mysql&gt; 旧的方法 set password for &#39;root&#39;@&#39;localhost&#39; = password (&#39;123456&#39;); 在MySQL8.0.11已经被删除，因为新版的MySQL已经没有password字段了，但是password函数没有被删除。 修改密码的帮助信息1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980mysql&gt; help set passwordName: 'SET PASSWORD'Description:Syntax:SET PASSWORD [FOR user] = password_optionpassword_option: &#123; 'auth_string' | PASSWORD('auth_string')&#125;The SET PASSWORD statement assigns a password to a MySQL user account.'auth_string' represents a cleartext (unencrypted) password.*Note*:o SET PASSWORD ... = PASSWORD('auth_string') syntax was removed in MySQL 8.0.11.o Rather than using SET PASSWORD ... = 'auth_string' syntax, ALTER USER syntax is the preferred statement for account alterations, including assigning passwords. For example:ALTER USER user IDENTIFIED BY 'auth_string';*Important*:Under some circumstances, SET PASSWORD may be recorded in server logsor on the client side in a history file such as ~/.mysql_history, whichmeans that cleartext passwords may be read by anyone having read accessto that information. For information about the conditions under whichthis occurs for the server logs and how to control it, seehttp://dev.mysql.com/doc/refman/8.0/en/password-logging.html. Forsimilar information about client-side logging, seehttp://dev.mysql.com/doc/refman/8.0/en/mysql-logging.html.SET PASSWORD can be used with or without a FOR clause that explicitlynames a user account:o With a FOR user clause, the statement sets the password for the named account, which must exist:SET PASSWORD FOR 'jeffrey'@'localhost' = 'auth_string';o With no FOR user clause, the statement sets the password for the current user:SET PASSWORD = 'auth_string'; Any client who connects to the server using a nonanonymous account can change the password for that account. To see which account the server authenticated you as, invoke the CURRENT_USER() function:SELECT CURRENT_USER();Setting the password for a named account (with a FOR clause) requiresthe UPDATE privilege for the mysql database. Setting the password foryourself (for a nonanonymous account with no FOR clause) requires nospecial privileges. When the read_only system variable is enabled, SETPASSWORD requires the CONNECTION_ADMIN or SUPER privilege in additionto any other required privileges.If a FOR user clause is given, the account name uses the formatdescribed in http://dev.mysql.com/doc/refman/8.0/en/account-names.html.For example:SET PASSWORD FOR 'bob'@'%.example.org' = 'auth_string';The host name part of the account name, if omitted, defaults to '%'.SET PASSWORD interprets the string as a cleartext string, passes it tothe authentication plugin associated with the account, and stores theresult returned by the plugin in the mysql.user account row. (Theplugin is given the opportunity to hash the value into the encryptionformat it expects. The plugin may use the value as specified, in whichcase no hashing occurs.)URL: http://dev.mysql.com/doc/refman/8.0/en/set-password.htmlmysql&gt; 授权123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149mysql&gt; help grant;Name: 'GRANT'Description:Syntax:GRANT priv_type [(column_list)] [, priv_type [(column_list)]] ... ON [object_type] priv_level TO user_or_role [auth_option] [, user_or_role [auth_option]] ... [REQUIRE &#123;NONE | tls_option [[AND] tls_option] ...&#125;] [WITH &#123;GRANT OPTION | resource_option&#125; ...]GRANT PROXY ON user_or_role TO user_or_role [, user_or_role] ... [WITH GRANT OPTION]GRANT role [, role] ... TO user_or_role [, user_or_role] ... [WITH ADMIN OPTION]object_type: &#123; TABLE | FUNCTION | PROCEDURE&#125;priv_level: &#123; * | *.* | db_name.* | db_name.tbl_name | tbl_name | db_name.routine_name&#125;user_or_role: &#123; user | role&#125;user: (see http://dev.mysql.com/doc/refman/8.0/en/account-names.html)role: (see http://dev.mysql.com/doc/refman/8.0/en/role-names.html.auth_option: &#123; IDENTIFIED BY 'auth_string' | IDENTIFIED WITH auth_plugin | IDENTIFIED WITH auth_plugin BY 'auth_string' | IDENTIFIED WITH auth_plugin AS 'hash_string' | IDENTIFIED BY PASSWORD 'hash_string'&#125;tls_option: &#123; SSL | X509 | CIPHER 'cipher' | ISSUER 'issuer' | SUBJECT 'subject'&#125;resource_option: &#123; | MAX_QUERIES_PER_HOUR count | MAX_UPDATES_PER_HOUR count | MAX_CONNECTIONS_PER_HOUR count | MAX_USER_CONNECTIONS count&#125;The GRANT statement enables system administrators to grant privilegesand roles, which can be granted to user accounts and roles. Thesesyntax restrictions apply:The GRANT statement enables system administrators to grant privilegesand roles, which can be granted to user accounts and roles. Thesesyntax restrictions apply:o GRANT cannot mix granting both privileges and roles in the same statement. A given GRANT statement must grant either privileges or roles.o The ON clause distinguishes whether the statement grants privileges or roles: o With ON, the statement grants privileges. o Without ON, the statement grants roles. o It is permitted to assign both privileges and roles to an account, but you must use separate GRANT statements, each with syntax appropriate to what is to be granted.For more information about roles, seehttp://dev.mysql.com/doc/refman/8.0/en/roles.html.To use GRANT, you must have the GRANT OPTION privilege, and you musthave the privileges that you are granting. When the read_only systemvariable is enabled, GRANT additionally requires the CONNECTION_ADMINor SUPER privilege.GRANT either succeeds for all named users and roles or rolls back andhas no effect if any error occurs. The statement is written to thebinary log only if it succeeds for all named users and roles.The REVOKE statement is related to GRANT and enables administrators toremove account privileges. See [HELP REVOKE].Each account name uses the format described inhttp://dev.mysql.com/doc/refman/8.0/en/account-names.html. Each rolename uses the format described inhttp://dev.mysql.com/doc/refman/8.0/en/role-names.html. For example:GRANT ALL ON db1.* TO 'jeffrey'@'localhost';GRANT 'role1', 'role2' TO 'user1'@'localhost', 'user2'@'localhost';GRANT SELECT ON world.* TO 'role3';The host name part of the account or role name, if omitted, defaults to'%'.Normally, a database administrator first uses CREATE USER to create anaccount and define its nonprivilege characteristics such as itspassword, whether it uses secure connections, and limits on access toserver resources, then uses GRANT to define its privileges. ALTER USERmay be used to change the nonprivilege characteristics of existingaccounts. For example:CREATE USER 'jeffrey'@'localhost' IDENTIFIED BY 'password';GRANT ALL ON db1.* TO 'jeffrey'@'localhost';GRANT SELECT ON db2.invoice TO 'jeffrey'@'localhost';ALTER USER 'jeffrey'@'localhost' WITH MAX_QUERIES_PER_HOUR 90;*Note*:As of MySQL 8.0.11, GRANT is used only for defining account privileges.the REQUIRE clause, WITH clause as used for setting resource limits,and the IDENTIFIED clause have been removed, and it is no longerpossible to use GRANT to modify nonprivilege account characteristics.This includes using GRANT to create accounts or specify characteristicssuch as passwords, whether accounts use secure connections, and limitson access to server resources. Instead, perform these tasks usingCREATE USER or ALTER USER.From the mysql program, GRANT responds with Query OK, 0 rows affectedwhen executed successfully. To determine what privileges result fromthe operation, use SHOW GRANTS. See [HELP SHOW GRANTS].URL: http://dev.mysql.com/doc/refman/8.0/en/grant.htmlmysql&gt; 数据库和创建数据库123456789101112131415161718192021222324252627mysql&gt; help databases;Many help items for your request exist.To make a more specific request, please type 'help &lt;item&gt;',where &lt;item&gt; is one of the followingtopics: SHOW SHOW DATABASESmysql&gt; help create database;Name: 'CREATE DATABASE'Description:Syntax:CREATE &#123;DATABASE | SCHEMA&#125; [IF NOT EXISTS] db_name [create_specification] ...create_specification: [DEFAULT] CHARACTER SET [=] charset_name | [DEFAULT] COLLATE [=] collation_nameCREATE DATABASE creates a database with the given name. To use thisstatement, you need the CREATE privilege for the database. CREATESCHEMA is a synonym for CREATE DATABASE.URL: http://dev.mysql.com/doc/refman/8.0/en/create-database.htmlmysql&gt; 创建表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194mysql&gt; help create table;Name: 'CREATE TABLE'Description:Syntax:CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name (create_definition,...) [table_options] [partition_options]CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name [(create_definition,...)] [table_options] [partition_options] [IGNORE | REPLACE] [AS] query_expressionCREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name &#123; LIKE old_tbl_name | (LIKE old_tbl_name) &#125;create_definition: col_name column_definition | [CONSTRAINT [symbol]] PRIMARY KEY [index_type] (index_col_name,...) [index_option] ... | &#123;INDEX|KEY&#125; [index_name] [index_type] (index_col_name,...) [index_option] ... | [CONSTRAINT [symbol]] UNIQUE [INDEX|KEY] [index_name] [index_type] (index_col_name,...) [index_option] ... | &#123;FULLTEXT|SPATIAL&#125; [INDEX|KEY] [index_name] (index_col_name,...) [index_option] ... | [CONSTRAINT [symbol]] FOREIGN KEY [index_name] (index_col_name,...) reference_definition | CHECK (expr)column_definition: data_type [NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT] [UNIQUE [KEY]] [[PRIMARY] KEY] [COMMENT 'string'] [COLUMN_FORMAT &#123;FIXED|DYNAMIC|DEFAULT&#125;] [reference_definition] | data_type [GENERATED ALWAYS] AS (expression) [VIRTUAL | STORED] [NOT NULL | NULL] [UNIQUE [KEY]] [[PRIMARY] KEY] [COMMENT 'string']data_type: BIT[(length)] | TINYINT[(length)] [UNSIGNED] [ZEROFILL] | SMALLINT[(length)] [UNSIGNED] [ZEROFILL] | MEDIUMINT[(length)] [UNSIGNED] [ZEROFILL] | INT[(length)] [UNSIGNED] [ZEROFILL] | INTEGER[(length)] [UNSIGNED] [ZEROFILL] | BIGINT[(length)] [UNSIGNED] [ZEROFILL] | REAL[(length,decimals)] [UNSIGNED] [ZEROFILL] | DOUBLE[(length,decimals)] [UNSIGNED] [ZEROFILL] | FLOAT[(length,decimals)] [UNSIGNED] [ZEROFILL] | DECIMAL[(length[,decimals])] [UNSIGNED] [ZEROFILL] | NUMERIC[(length[,decimals])] [UNSIGNED] [ZEROFILL] | DATE | TIME[(fsp)] | TIMESTAMP[(fsp)] | DATETIME[(fsp)] | YEAR | CHAR[(length)] [CHARACTER SET charset_name] [COLLATE collation_name] | VARCHAR(length) [CHARACTER SET charset_name] [COLLATE collation_name] | BINARY[(length)] | VARBINARY(length) | TINYBLOB | BLOB[(length)] | MEDIUMBLOB | LONGBLOB | TINYTEXT [CHARACTER SET charset_name] [COLLATE collation_name] | TEXT[(length)] [CHARACTER SET charset_name] [COLLATE collation_name] | MEDIUMTEXT [CHARACTER SET charset_name] [COLLATE collation_name] | LONGTEXT [CHARACTER SET charset_name] [COLLATE collation_name] | ENUM(value1,value2,value3,...) [CHARACTER SET charset_name] [COLLATE collation_name] | SET(value1,value2,value3,...) [CHARACTER SET charset_name] [COLLATE collation_name] | JSON | spatial_typeindex_col_name: col_name [(length)] [ASC | DESC]index_type: USING &#123;BTREE | HASH&#125;index_option: KEY_BLOCK_SIZE [=] value | index_type | WITH PARSER parser_name | COMMENT 'string' | &#123;VISIBLE | INVISIBLE&#125;reference_definition: REFERENCES tbl_name (index_col_name,...) [MATCH FULL | MATCH PARTIAL | MATCH SIMPLE] [ON DELETE reference_option] [ON UPDATE reference_option]reference_option: RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULTtable_options: table_option [[,] table_option] ...table_option: AUTO_INCREMENT [=] value | AVG_ROW_LENGTH [=] value | [DEFAULT] CHARACTER SET [=] charset_name | CHECKSUM [=] &#123;0 | 1&#125; | [DEFAULT] COLLATE [=] collation_name | COMMENT [=] 'string' | COMPRESSION [=] &#123;'ZLIB'|'LZ4'|'NONE'&#125; | CONNECTION [=] 'connect_string' | &#123;DATA|INDEX&#125; DIRECTORY [=] 'absolute path to directory' | DELAY_KEY_WRITE [=] &#123;0 | 1&#125; | ENCRYPTION [=] &#123;'Y' | 'N'&#125; | ENGINE [=] engine_name | INSERT_METHOD [=] &#123; NO | FIRST | LAST &#125; | KEY_BLOCK_SIZE [=] value | MAX_ROWS [=] value | MIN_ROWS [=] value | PACK_KEYS [=] &#123;0 | 1 | DEFAULT&#125; | PASSWORD [=] 'string' | ROW_FORMAT [=] &#123;DEFAULT|DYNAMIC|FIXED|COMPRESSED|REDUNDANT|COMPACT&#125; | STATS_AUTO_RECALC [=] &#123;DEFAULT|0|1&#125; | STATS_PERSISTENT [=] &#123;DEFAULT|0|1&#125; | STATS_SAMPLE_PAGES [=] value | TABLESPACE tablespace_name | UNION [=] (tbl_name[,tbl_name]...)partition_options: PARTITION BY &#123; [LINEAR] HASH(expr) | [LINEAR] KEY [ALGORITHM=&#123;1|2&#125;] (column_list) | RANGE&#123;(expr) | COLUMNS(column_list)&#125; | LIST&#123;(expr) | COLUMNS(column_list)&#125; &#125; [PARTITIONS num] [SUBPARTITION BY &#123; [LINEAR] HASH(expr) | [LINEAR] KEY [ALGORITHM=&#123;1|2&#125;] (column_list) &#125; [SUBPARTITIONS num] ] [(partition_definition [, partition_definition] ...)]partition_definition: PARTITION partition_name [VALUES &#123;LESS THAN &#123;(expr | value_list) | MAXVALUE&#125; | IN (value_list)&#125;] [[STORAGE] ENGINE [=] engine_name] [COMMENT [=] 'string' ] [DATA DIRECTORY [=] 'data_dir'] [INDEX DIRECTORY [=] 'index_dir'] [MAX_ROWS [=] max_number_of_rows] [MIN_ROWS [=] min_number_of_rows] [TABLESPACE [=] tablespace_name] [(subpartition_definition [, subpartition_definition] ...)]subpartition_definition: SUBPARTITION logical_name [[STORAGE] ENGINE [=] engine_name] [COMMENT [=] 'string' ] [DATA DIRECTORY [=] 'data_dir'] [INDEX DIRECTORY [=] 'index_dir'] [MAX_ROWS [=] max_number_of_rows] [MIN_ROWS [=] min_number_of_rows] [TABLESPACE [=] tablespace_name]query_expression: SELECT ... (Some valid select or union statement)CREATE TABLE creates a table with the given name. You must have theCREATE privilege for the table.By default, tables are created in the default database, using theInnoDB storage engine. An error occurs if the table exists, if there isno default database, or if the database does not exist.For information about the physical representation of a table, seehttp://dev.mysql.com/doc/refman/8.0/en/create-table-files.html.URL: http://dev.mysql.com/doc/refman/8.0/en/create-table.htmlmysql&gt; 版权声明：博客中的文章版权归博主所有，未经授权，禁止转载，转载请注明出处，合作请点击“关于我”，扫码添加微信]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac安装MySQL 8.0]]></title>
    <url>%2F2018%2F07%2F27%2FMac%E5%AE%89%E8%A3%85MySQL%208.0%E7%89%88%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[整理：房玉辉 博客：https://ElonJelinek.github.io用Homebrew安装MySQL打开终端，输入命令：brew install mysql 1234567891011121314151617181920ElonJelinek:~ ElonJelinek$ brew install mysql==&gt; Downloading https://homebrew.bintray.com/bottles/mysql-8.0.12.high_sierra.boAlready downloaded: /Users/ElonJelinek/Library/Caches/Homebrew/mysql--8.0.12.high_sierra.bottle.tar.gz==&gt; Pouring mysql--8.0.12.high_sierra.bottle.tar.gz==&gt; /usr/local/Cellar/mysql/8.0.12/bin/mysqld --initialize-insecure --user=ElonJ==&gt; CaveatsWe've installed your MySQL database without a root password. To secure it run: mysql_secure_installationMySQL is configured to only allow connections from localhost by defaultTo connect run: mysql -urootTo have launchd start mysql now and restart at login: brew services start mysqlOr, if you don't want/need a background service you can just run: mysql.server start==&gt; Summary🍺 /usr/local/Cellar/mysql/8.0.12: 255 files, 233.0MB 启动MySQL服务：brew services start mysql 12ElonJelinek:~ ElonJelinek$ brew services start mysqlService `mysql` already started, use `brew services restart mysql` to restart. 设置开机启动：launchctl load ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist 12ElonJelinek:~ ElonJelinek$ launchctl load ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist/Users/ElonJelinek/Library/LaunchAgents/homebrew.mxcl.mysql.plist: service already loaded 用root用户登录MySQL：mysql -uroot 1234567891011121314ElonJelinek:~ ElonJelinek$ mysql -urootWelcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 8Server version: 8.0.12 HomebrewCopyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.mysql&gt; 一些简单操作，注意每一个命令都以分号;结束。查看版本：select version(); 1234567mysql&gt; select version();+-----------+| version() |+-----------+| 8.0.12 |+-----------+1 row in set (0.00 sec) 查看当前时间：select now(); 1234567mysql&gt; select now();+---------------------+| now() |+---------------------+| 2018-07-27 19:45:13 |+---------------------+1 row in set (0.00 sec) 查看所有的数据库：show databases; 12345678910mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sys |+--------------------+4 rows in set (0.00 sec) 查看当前所进入的数据库，即当前正在使用的数据库：select database(); 由于当前没有进入任何一个数据库，所以结果为null 1234567mysql&gt; select database();+------------+| database() |+------------+| NULL |+------------+1 row in set (0.00 sec) 查看数据库中的表：show tables; 由于当前并没有进入任何一个数据库，所以查不到表 123mysql&gt; show tables;ERROR 1046 (3D000): No database selectedmysql&gt; 修改root用户密码：ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;123456&#39;; 12mysql&gt; ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123456';Query OK, 0 rows affected (0.01 sec) 退出：exit 12345678910111213141516171819202122232425262728mysql&gt; exitByeElonJelinek:~ ElonJelinek$``` 重新登录，此时已经为root用户设置了密码：123456，因此，用用户名加密码方式登录：`mysql -u root -p`回车后，输入密码`123456` （这里并不显示输入的密码，直接输入123456并回车就OK。）```goElonJelinek:~ ElonJelinek$ mysql -u root -p Enter password: Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 13Server version: 8.0.12 HomebrewCopyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.mysql&gt; 选择一个数据库首次安装后，会有四个数据库，这里我们选择mysql这个库 use mysql; 1234567891011121314mysql&gt; use mysql;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; select database();+------------+| database() |+------------+| mysql |+------------+1 row in set (0.00 sec)mysql&gt; 查看mysql库里的所有表： show tables; 1234567891011121314151617181920212223242526272829303132333435363738394041mysql&gt; show tables;+---------------------------+| Tables_in_mysql |+---------------------------+| columns_priv || component || db || default_roles || engine_cost || func || general_log || global_grants || gtid_executed || help_category || help_keyword || help_relation || help_topic || innodb_index_stats || innodb_table_stats || password_history || plugin || procs_priv || proxies_priv || role_edges || server_cost || servers || slave_master_info || slave_relay_log_info || slave_worker_info || slow_log || tables_priv || time_zone || time_zone_leap_second || time_zone_name || time_zone_transition || time_zone_transition_type || user |+---------------------------+33 rows in set (0.01 sec)mysql&gt; 默认有33张表。 本节到此结束，下一次开始进行数据库、表的增删改查。 版权声明：博客中的文章版权归博主所有，未经授权，禁止转载，转载请注明出处，合作请点击“关于我”，扫码添加微信]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在本地网络部署super—dictionary智能合约]]></title>
    <url>%2F2018%2F05%2F03%2F%E5%9C%A8localhost%E9%83%A8%E7%BD%B2super%E2%80%94dictionary%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%2F</url>
    <content type="text"><![CDATA[整理：房玉辉 博客：https://ElonJelinek.github.io星云链Dapp开发系列在本地网络（localhost）部署super-dictionary智能合约super-dictionary智能合约源码下载地址：https://github.com/15010159959/super-dictionary 1、解决本地交易网络错误问题：进入go/src/github.com/nebulasio/go-nebulas/conf/default文件夹，打开config.conf文件，找到以下代码： 1234567rpc &#123; rpc_listen: ["0.0.0.0:8684"] http_listen: ["0.0.0.0:8685"] http_module: ["api","admin"] # HTTP CORS allowed origins # http_cors: []&#125; 去掉最后一行代码的注释，并更改如下：http_cors: [&quot;*&quot;] 2、进入super-dictionary-master/lib文件夹：打开nebPay.js文件：找到第四行代码：var payUrl = &quot;http://18.221.150.42/api/pay&quot;;更改为：var payUrl = &quot;http://localhost:8685/api/pay&quot;; 3、启动节点：打开第一个终端窗口，启动第一个星云节点： 12cd $GOPATH/src/github.com/nebulasio/go-nebulas./neb -c conf/default/config.conf 再打开一个终端窗口，启动第一个矿工节点： 12cd $GOPATH/src/github.com/nebulasio/go-nebulas./neb -c conf/example/miner.conf 4、部署合约：打开web-wallet钱包，部署super-dictionary智能合约到星云链localhost网络：进入web-wallet文件夹，用浏览器打开index.html文件，点击合约，再点击部署，找到super-dictionary-master/smartContract文件夹下的super-dictionary.js文件，将全部代码粘贴到合约代码框内：选择钱包文件，输入密码，点击解锁，再点击测试，再点击提交：保存好合约地址：n1wfeKn7GSjo8GbAE64CgUPyxwqLrpWWLnK点击交易哈希，查看交易状态，下图为部署成功： 5、执行、调用合约，与前端交互：进入super-dictionary-master文件夹，用开发工具打开index.html文件，找到第190行代码，将合约地址粘贴过来：var dappAddress = &quot;n1wfeKn7GSjo8GbAE64CgUPyxwqLrpWWLnK&quot;;保存后，用浏览器打开index.html文件，随便输入“比特币”一词，可以看到，没有释义，但是底下有一句话： Failed to find related information. Do you want to add infromation for “比特币”? 并且add可以点击，点击add后可以添加释义，输入如下释义：“比特币（BitCoin）的概念最初由中本聪在2009年提出，根据中本聪的思路设计发布的开源软件以及建构其上的P2P网络。比特币是一种P2P形式的数字货币。”点击submit，之后会弹出WebExtensionWallet钱包页面，选择localhost当地钱包文件，输入密码“passphrase”，点击生成交易，再点击交易确认，正在打包：交易打包成功：查询，如图所示：至此，super-dictionary智能合约部署成功，前端调用合约成功。 版权声明：博客中的文章版权归博主所有，未经授权，禁止转载，转载请注明出处，合作请点击“关于我”，扫码添加微信]]></content>
      <categories>
        <category>智能合约</category>
      </categories>
      <tags>
        <tag>星云链Dapp开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在星云链测试网部署super-dictionary智能合约]]></title>
    <url>%2F2018%2F05%2F02%2F%E5%9C%A8%E6%98%9F%E4%BA%91%E9%93%BE%E6%B5%8B%E8%AF%95%E7%BD%91%E9%83%A8%E7%BD%B2super-dictionary%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%2F</url>
    <content type="text"><![CDATA[整理：房玉辉 博客：https://ElonJelinek.github.io星云链Dapp开发系列在星云链测试网部署super-dictionary智能合约工具：Goland，Chrome，WebExtensionWallet插件钱包super-dictionary智能合约源码下载地址：https://github.com/15010159959/super-dictionary 1、下载星云链官方钱包：到GitHub的星云官方库下载web-wallet钱包https://github.com/nebulasio/web-wallet，用谷歌浏览器打开文件包里的index.html，点击右上角，选择testnet网络，再新建钱包，牢记密码，并下载保存好密码库文件，申请测试币https://testnet.nebulas.io/claim/ 2、在谷歌浏览器上安装WebExtensionWallet插件钱包，有详细安装攻略。3、部署合约下载super-dictionary智能合约：https://github.com/15010159959/super-dictionary打开super-dictionary-master/smartcontract文件夹下的super_dictionary.js文件，复制全部代码，打开web-wallet文件夹里的index.html文件，点击右上角选择Testnet测试网络，点击合约——部署，粘贴全部代码到合约部署框内，选择钱包文件，输入密码，点击解锁，再点击测试，后点击提交，保存好交易哈希和合约地址。合约地址：n1vPTmFsXNGCjZ3Dmf2ngEEyUeut7pqebaJ用goland开发工具打开super-dictionary-master文件夹下的index.html，找到第190行，把合约地址粘贴过去并保存：var dappAddress = &quot;n1vPTmFsXNGCjZ3Dmf2ngEEyUeut7pqebaJ&quot;; 4、执行合约：用谷歌浏览器打开super-dictionary-master文件夹下的index.html，点击浏览器右上角的插件钱包，选择Testnet测试网络，搜索“金庸”，可以看到没有释义，而输入框下面出现一句话，Failed to find related information. Do you want to add infromation for “金庸”?点击add添加释义，点击submit提交后，就会弹出插件钱包，选择钱包，输入密码，,点击生成交易，点击确认，大概一分钟后，交易成功，最后再次查询“金庸“，已经有了释义，如此，合约部署成功。执行合约成功。 版权声明：博客中的文章版权归博主所有，未经授权，禁止转载，转载请注明出处，合作请点击“关于我”，扫码添加微信]]></content>
      <categories>
        <category>智能合约</category>
      </categories>
      <tags>
        <tag>星云链Dapp开发</tag>
        <tag>super-dictionary智能合约</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建etcd多台服务器集群]]></title>
    <url>%2F2018%2F02%2F11%2F%E6%90%AD%E5%BB%BAetcd%E5%A4%9A%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9B%86%E7%BE%A4%2F</url>
    <content type="text"><![CDATA[整理：房玉辉 博客：https://ElonJelinek.github.io 1、清空缓存：在etcd目录下执行make clean 2、导入API：在etcd/bin目录下执行export ETCDCTL_API=3 3、设置服务器IP：在etcd/bin目录下执行三台机器按主机IP顺序执行以下同一段代码 123456789TOKEN=token-01CLUSTER_STATE=newNAME_1=machine-1NAME_2=machine-2NAME_3=machine-3HOST_1=10.0.154.189HOST_2=10.0.154.210HOST_3=10.0.154.244CLUSTER=$&#123;NAME_1&#125;=http://$&#123;HOST_1&#125;:2380,$&#123;NAME_2&#125;=http://$&#123;HOST_2&#125;:2380,$&#123;NAME_3&#125;=http://$&#123;HOST_3&#125;:2380 4、启动服务：在etcd/bin目录下执行 三台机器按顺序执行各自命令：machine1执行如下命令： 123THIS_NAME=$&#123;NAME_1&#125;THIS_IP=$&#123;HOST_1&#125;./etcd --data-dir=data.etcd --name $&#123;THIS_NAME&#125; --initial-advertise-peer-urls http://$&#123;THIS_IP&#125;:2380 --listen-peer-urls http://$&#123;THIS_IP&#125;:2380 --advertise-client-urls http://$&#123;THIS_IP&#125;:2379 --listen-client-urls http://$&#123;THIS_IP&#125;:2379 --initial-cluster $&#123;CLUSTER&#125; --initial-cluster-state $&#123;CLUSTER_STATE&#125; --initial-cluster-token $&#123;TOKEN&#125; machine2执行以下命令： 123THIS_NAME=$&#123;NAME_2&#125;THIS_IP=$&#123;HOST_2&#125;./etcd --data-dir=data.etcd --name $&#123;THIS_NAME&#125; --initial-advertise-peer-urls http://$&#123;THIS_IP&#125;:2380 --listen-peer-urls http://$&#123;THIS_IP&#125;:2380 --advertise-client-urls http://$&#123;THIS_IP&#125;:2379 --listen-client-urls http://$&#123;THIS_IP&#125;:2379 --initial-cluster $&#123;CLUSTER&#125; --initial-cluster-state $&#123;CLUSTER_STATE&#125; --initial-cluster-token $&#123;TOKEN&#125; machine3执行以下命令： 123THIS_NAME=$&#123;NAME_3&#125;THIS_IP=$&#123;HOST_3&#125;./etcd --data-dir=data.etcd --name $&#123;THIS_NAME&#125; --initial-advertise-peer-urls http://$&#123;THIS_IP&#125;:2380 --listen-peer-urls http://$&#123;THIS_IP&#125;:2380 --advertise-client-urls http://$&#123;THIS_IP&#125;:2379 --listen-client-urls http://$&#123;THIS_IP&#125;:2379 --initial-cluster $&#123;CLUSTER&#125; --initial-cluster-state $&#123;CLUSTER_STATE&#125; --initial-cluster-token $&#123;TOKEN&#125; machine3接入成功 5、检测几台机器接入集群： 新开一个终端：进入etcd/bin目录导入IP：export ETCDCTL_API=3执行以下命令： 123456HOST_1=10.0.154.189HOST_2=10.0.154.210HOST_3=10.0.154.244ENDPOINTS=$HOST_1:2379,$HOST_2:2379,$HOST_3:2379./etcdctl --endpoints=$ENDPOINTS member list 连接成功如图： 版权声明：博客中的文章版权归博主所有，未经授权，禁止转载，转载请注明出处，合作请点击“关于我”，扫码添加微信]]></content>
      <categories>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>etcd多台服务器集群</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go语言常见面试题（数学篇）]]></title>
    <url>%2F2018%2F01%2F03%2Fgo%E8%AF%AD%E8%A8%80%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E6%95%B0%E5%AD%A6%E7%AF%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[整理：房玉辉 博客：https://ElonJelinek.github.io一、分解质因数：比如90，分解出：90=2*3*3*5分析：质数为大于1的自然数，除了1和它本身没有其他因数。相反，除了1和它本身还有其他因数的数，称为合数，所以，分解法为：先用这个合数最小的那个因数（是质数的因数）去除，商如果是合数，就继续除：商如果是质数，就停止，最后的这个商是它的最大的质因数。因此，最后可以写成所有的除数乘以最后的商。 1234567891011121314151617181920package mainimport "fmt"func main() &#123; var n = 90 fun(n)&#125;func fun(n int) &#123; fmt.Print(n, "=", ) for i := 2; i &lt; n; i++ &#123; if n%i == 0 &#123; n = n / i fmt.Print(i, "*") i-- &#125; &#125; fmt.Println(n)&#125; 运行结果： 190=2*3*3*5 二、计算 sum(n) = 1/3 + 2/5 + 3/7 + … + n/2n+1 的前n项和123456789101112131415161718package mainimport "fmt"func main() &#123; var n float32 = 8 fmt.Print("sum(", n, ")=\t") sum := float32(0) for i := float32(1); i &lt;= n; i++ &#123; if i != n &#123; fmt.Print(i, "/", 2*i+1, "\t+\t") &#125; else &#123; fmt.Print(i, "/", 2*i+1, "\t") &#125; sum += i / (2*i + 1) &#125; fmt.Println("=", sum)&#125; 运行结果： 1sum(8)= 1/3 + 2/5 + 3/7 + 4/9 + 5/11 + 6/13 + 7/15 + 8/17 = 3.4596882 三、一球从100米高度自由落下，每次落地后又返跳回原高度的一半，再下落，求它第10次落地时，共经过多少米？分析：从第2次开始，每次经过的距离为下落点的2倍，所以第10次落地共经过的距离为后9次的下落点的高度和乘以2加上第一次的100米。 123456789101112131415package mainimport "fmt"func main() &#123; var hight float32 = 100 var jump = hight for i := 2; i &lt;= 10; i++ &#123; jump = jump / 2 hight += jump * 2 &#125; fmt.Println("第十次落地共经过：", hight, "米。")&#125; 运行结果： 1第十次落地共经过： 299.60938 米。 四、要求输入一个整数n，请你输出斐波那契数列的第n项[斐波那契数列0 1 1 2 3 5 8 13 21……]123456789101112131415package mainimport "fmt"func main() &#123; fmt.Println(fibonacci(8))&#125;func fibonacci(n int) int &#123; if n &lt;= 1 &#123; return n &#125; else &#123; return fibonacci(n-2) + fibonacci(n-1) &#125;&#125; 运行结果：21 五、求1+2!+3!+…+20!的和12345678910111213141516171819202122package mainimport ( "fmt")func main() &#123; sum := 0 // 把1到20的阶乘的和累加 for i := 1; i &lt;= 20; i++ &#123; sum += fact(i) &#125; fmt.Println(sum)&#125;// 用递归求阶乘func fact(n int) int &#123; if n &lt;= 1 &#123; return n &#125; else &#123; return n * fact(n-1) &#125;&#125; 运行结果： 12561327494111820313 六、求101-200之内的素数12345678910111213141516171819202122package mainimport ( "fmt")func main() &#123; n := 0 for i := 100; i &lt;= 200; i++ &#123; count := 0 for j := 2; j &lt; i; j++ &#123; if i%j == 0 &#123; count++ &#125; &#125; if count == 0 &#123; n++ fmt.Print(i, "\t") &#125; &#125; fmt.Println(n)&#125; 运行结果：101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 21共有21个。 七、打印出所有的 “水仙花数 “，所谓 “水仙花数 “是指一个三位数，其各位数字立方和等于该数本身。例如：153是一个 “水仙花数 “，因为153=1的三次方＋5的三次方＋3的三次方1234567891011121314package mainimport "fmt"func main() &#123; for i := 100; i &lt;= 999; i++ &#123; l := i / 100 m := i / 10 % 10 n := i % 10 if l*l*l+m*m*m+n*n*n == i &#123; fmt.Println(i) &#125; &#125;&#125; 运行结果： 1234153370371407 八、利用递归方法求5!12345678910111213141516package mainimport "fmt"func main() &#123; a := fact(5) fmt.Println(a)&#125;func fact(n int) int &#123; if n &lt;= 1 &#123; return 1 &#125; else &#123; return n * fact(n-1) &#125;&#125; 运行结果120 九、有1、2、3、4四个数字，能组成多少个互不相同且无重复的三位数1234567891011121314package mainimport "fmt"func main() &#123; for i := 123; i &lt;= 432; i++ &#123; g := i % 10 s := i % 100 / 10 b := i / 100 if g != s &amp;&amp; g != b &amp;&amp; s != b &amp;&amp; g &lt;= 4 &amp;&amp; s &lt;= 4 &amp;&amp; b &lt;= 4 &amp;&amp; g != 0 &amp;&amp; s != 0 &amp;&amp; b != 0 &#123; fmt.Print(i, "\t") &#125; &#125;&#125; 运行结果：123 124 132 134 142 143 213 214 231 234 241 243 312 314 321 324 341 342 412 413 421 423 431 432 十、输入三个整数x,y,z，请把这三个数由小到大输出12345678910111213141516171819202122232425package mainimport "fmt"func main() &#123; var x int var y int var z int fmt.Scanln(&amp;x, &amp;y, &amp;z) if x &gt; y &#123; x, y = y, x &#125; if x &gt; z &#123; x, z = z, x &#125; if y &gt; z &#123; y, z = z, y &#125; fmt.Println(x, y, z)&#125; 输入：15 20 2运行结果：2 15 20 十一、求S=a+aa+aaa+aaaa+aa…a的值，其中a是一个数字。例如2+22+222+2222+22222（此时共有5个数相加），几个数相加由键盘控制。1234567891011121314151617package mainimport "fmt"func main() &#123; test(5, 2)&#125;func test(n int, m int) &#123; a := 0 sum := 0 for i := 0; i &lt; n; i++ &#123; a = (a * 10) + m sum += a &#125; fmt.Println("sum=", sum)&#125; 运行结果：sum= 24690 十二、古典问题：有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？共12个月分析：从第三个月开始每个月的兔子总数为前两个月的兔子数量的和，因为上一个月的兔子到这个月都不生兔子，而上上一个月的兔子到这个月都会再生一对儿兔子，所以这个月新出生的兔子数量与上上个月的兔子总数相同。例如： 6月的兔子总数 = 5月的兔子总数 + 6月新出生的兔子的数量6月的兔子总数 = 5月的兔子总数 + 4月的兔子总数 123456789101112131415package mainimport "fmt"func main() &#123; a := 1 b := 1 var c int for i := 1; i &lt;= 12; i++ &#123; a = b b = c c = a + b fmt.Print(c,"\t") &#125;&#125; 运行结果：1 1 2 3 5 8 13 21 34 55 89 144这里还可以用递归方法做，12个月的兔子数量正好是一个斐波那契数列。 十三、猴子分桃：海滩上有一堆桃子，五只猴子来分。第一只猴子把这堆桃子平均分为五份，多了一个，这只猴子把多的一个扔入海中，拿走了一份。第二只猴子把剩下的桃子又平均分成五份，又多了一个，它同样把多的一个扔入海中，拿走了一份，第三、第四、第五只猴子都是这样做的，问海滩上原来最少有多少个桃子？分析：假如第五只猴子拿走的一份正好是一颗桃子，则最后一堆桃子数是：5+1=6（颗）。 1234567891011121314151617181920212223242526package mainimport "fmt"func main() &#123; num := 6 for &#123; num = num + 5 count := num monkey := 0 for i := 0; i &lt;= 5; i++ &#123; if (count-1)%5 == 0 &#123; count = (count - 1) / 5 * 4 monkey++ &#125; else &#123; break //如果不满足扔一个还能均分5份，就跳出内层循环，再给num加5 &#125; &#125; if monkey == 5 &#123; break //如果不满足monkey等于5，就一直循环 &#125; &#125; fmt.Println(num)&#125; 运行结果：3121 这里的很多题都有不止一种解法，就好像同样一种算法，可能每个人写的代码都不完全相同，有的可能逻辑更清晰，有的可能代码量更少，有的可能时间复杂度更低，实际开发中很多问题都需要针对不同的具体情况去优化。 版权声明：博客中的文章版权归博主所有，未经授权，禁止转载，转载请注明出处，合作请点击“关于我”，扫码添加微信]]></content>
      <categories>
        <category>go语言</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis开源库redigo的使用]]></title>
    <url>%2F2018%2F01%2F03%2FRedis%E5%BC%80%E6%BA%90%E5%BA%93redigo%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[整理：房玉辉 博客：https://ElonJelinek.github.io打开终端，获取开源库redigo，完成后启动Redis服务123456789101112131415161718192021222324252627ElonJelinek:~ ElonJelinek$ go get github.com/garyburd/redigo/redisElonJelinek:~ ElonJelinek$ redis-server /usr/local/etc/redis.conf2273:C 23 Aug 15:22:52.471 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo2273:C 23 Aug 15:22:52.471 # Redis version=4.0.11, bits=64, commit=00000000, modified=0, pid=2273, just started2273:C 23 Aug 15:22:52.471 # Configuration loaded2273:M 23 Aug 15:22:52.473 * Increased maximum number of open files to 10032 (it was originally set to 256). _._ _.-``__ ''-._ _.-`` `. `_. ''-._ Redis 4.0.11 (00000000/0) 64 bit .-`` .-```. ```\/ _.,_ ''-._ ( ' , .-` | `, ) Running in standalone mode |`-._`-...-` __...-.``-._|'` _.-'| Port: 6379 | `-._ `._ / _.-' | PID: 2273 `-._ `-._ `-./ _.-' _.-' |`-._`-._ `-.__.-' _.-'_.-'| | `-._`-._ _.-'_.-' | http://redis.io `-._ `-._`-.__.-'_.-' _.-' |`-._`-._ `-.__.-' _.-'_.-'| | `-._`-._ _.-'_.-' | `-._ `-._`-.__.-'_.-' _.-' `-._ `-.__.-' _.-' `-._ _.-' `-.__.-' 2273:M 23 Aug 15:22:52.474 # Server initialized2273:M 23 Aug 15:22:52.474 * DB loaded from disk: 0.000 seconds2273:M 23 Aug 15:22:52.474 * Ready to accept connections Goland编译器：123456789101112131415161718192021222324252627282930package mainimport ( "github.com/garyburd/redigo/redis" "fmt")func main() &#123;//连接Redis c, err := redis.Dial("tcp", "127.0.0.1:6379") if err != nil &#123; fmt.Println("Connect to redis error", err) return &#125; defer c.Close()//存入数据 _, err = c.Do("SET", "myname", "lixunhuan") if err != nil &#123; fmt.Println("redis set failed:", err) &#125;//读取数据 username, err := redis.String(c.Do("GET", "myname")) if err != nil &#123; fmt.Println("redis get failed:", err) &#125; else &#123; fmt.Printf("Get myname: %v \n", username) &#125;&#125; 运行： 1Get myname: lixunhuan 查询值是否存在：1234567891011121314151617181920212223package mainimport ( "github.com/garyburd/redigo/redis" "fmt")func main() &#123; c, err := redis.Dial("tcp", "127.0.0.1:6379") if err != nil &#123; fmt.Println("Connect to redis error", err) return &#125; defer c.Close() is_key_exit, err := redis.Bool(c.Do("EXISTS", "myname")) if err != nil &#123; fmt.Println("error:", err) &#125; else &#123; fmt.Printf("exists or not: %v \n", is_key_exit) &#125;&#125; 运行： 1exists or not: true 删除值：123456789101112131415161718192021222324252627package mainimport ( "github.com/garyburd/redigo/redis" "fmt")func main() &#123; c, err := redis.Dial("tcp", "127.0.0.1:6379") if err != nil &#123; fmt.Println("Connect to redis error", err) return &#125; defer c.Close() _, err = c.Do("DEL", "myname") if err != nil &#123; fmt.Println("redis delete failed:", err) &#125; username, err := redis.String(c.Do("GET", "myname")) if err != nil &#123; fmt.Println("reids get failed:", err) &#125; else &#123; fmt.Printf("Get myname: %v \n", username) &#125;&#125; 运行： 1reids get failed: redigo: nil returned json串的存取123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport ( "github.com/garyburd/redigo/redis" "fmt" "encoding/json")func main() &#123; c, err := redis.Dial("tcp", "127.0.0.1:6379") if err != nil &#123; fmt.Println("Connect to redis error", err) return &#125; defer c.Close() key := "varurr" map1 := map[string]string&#123;"name": "berry", "age": "22"&#125; value, _ := json.Marshal(map1) n, err := c.Do("SETNX", key, value) if err != nil &#123; fmt.Println(err) &#125; if n == int64(1) &#123; fmt.Println("success") &#125; var map2 map[string]string getVlue, err := redis.Bytes(c.Do("GET", key)) if err != nil &#123; fmt.Println(err) &#125; err = json.Unmarshal(getVlue, &amp;map2) if err != nil &#123; fmt.Println(err) &#125; fmt.Println(map2["name"]) fmt.Println(map2["age"])&#125; 运行： 123successberry22 版权声明：博客中的文章版权归博主所有，未经授权，禁止转载，转载请注明出处，合作请点击“关于我”，扫码添加微信]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Redis数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis数据库的安装（Mac环境）]]></title>
    <url>%2F2018%2F01%2F03%2FRedis%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[整理：房玉辉 博客：https://ElonJelinek.github.io1、利用Homebrew安装Redis打开终端，输入以下命令： brew install redis 会输出如下内容： 123456789101112（之前的输出省略）………………==&gt; Pouring redis--4.0.11.high_sierra.bottle.tar.gz==&gt; CaveatsTo have launchd start redis now and restart at login: brew services start redisOr, if you don't want/need a background service you can just run: redis-server /usr/local/etc/redis.conf==&gt; Summary🍺 /usr/local/Cellar/redis/4.0.11: 13 files, 2.8MB 到这里即安装完成。 启动Redis服务： redis-server 出现以下内容，说明安装成功，并启动成功 123456789101112131415161718192021222324（之前的输出省略）……………… _._ _.-``__ ''-._ _.-`` `. `_. ''-._ Redis 4.0.11 (00000000/0) 64 bit .-`` .-```. ```\/ _.,_ ''-._ ( ' , .-` | `, ) Running in standalone mode |`-._`-...-` __...-.``-._|'` _.-'| Port: 6379 | `-._ `._ / _.-' | PID: 78083 `-._ `-._ `-./ _.-' _.-' |`-._`-._ `-.__.-' _.-'_.-'| | `-._`-._ _.-'_.-' | http://redis.io `-._ `-._`-.__.-'_.-' _.-' |`-._`-._ `-.__.-' _.-'_.-'| | `-._`-._ _.-'_.-' | `-._ `-._`-.__.-'_.-' _.-' `-._ `-.__.-' _.-' `-._ _.-' `-.__.-' 78083:M 23 Aug 14:39:07.868 # Server initialized78083:M 23 Aug 14:39:07.868 * Ready to accept connections 此时，该终端窗口会一直保持启动状态，不能再输入命令，要写入数据，需要另外开启一个终端窗口打开另一个终端窗口，启动Redis客户端 redis-cli 会输出如下内容，表示已经进入Redis客户端，之后可进行数据的读写操作 1127.0.0.1:6379&gt; 2、数据的增删改查Redis是key-value型数据库，输入key *可查看所有的key-value键值对 set为写入命令get为读取命令append为追加命令del为删除shutdown为关闭Redis服务 接下来依次输入一些数据，查看效果 1234567891011121314151617181920212223127.0.0.1:6379&gt; keys *(empty list or set)127.0.0.1:6379&gt; set name "lucy"OK127.0.0.1:6379&gt; get name "lucy"127.0.0.1:6379&gt; keys *1) "name"127.0.0.1:6379&gt; append name Tom(integer) 7127.0.0.1:6379&gt; get name"lucyTom"127.0.0.1:6379&gt; set age 22OK127.0.0.1:6379&gt; keys *1) "name"2) "age"127.0.0.1:6379&gt; del name(integer) 1127.0.0.1:6379&gt; get name(nil)127.0.0.1:6379&gt; shutdownnot connected&gt; 输入shutdown之后，Redis服务会被关闭，前一个终端窗口会输出如下内容 1234576944:M 23 Aug 17:57:40.220 # User requested shutdown...76944:M 23 Aug 17:57:40.220 * Saving the final RDB snapshot before exiting.76944:M 23 Aug 17:57:40.221 * DB saved on disk76944:M 23 Aug 17:57:40.221 # Redis is now ready to exit, bye bye...ElonJelinek:~ ElonJelinek$ 之后，第二个终端窗口用exit退出Redis客户端。 版权声明：博客中的文章版权归博主所有，未经授权，禁止转载，转载请注明出处，合作请点击“关于我”，扫码添加微信]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Redis数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用go语言爬虫珍爱网所有城市网址]]></title>
    <url>%2F2018%2F01%2F02%2F%E7%94%A8go%E8%AF%AD%E8%A8%80%E7%88%AC%E8%99%AB%E7%8F%8D%E7%88%B1%E7%BD%91%E6%89%80%E6%9C%89%E5%9F%8E%E5%B8%82%E7%BD%91%E5%9D%80%2F</url>
    <content type="text"><![CDATA[整理：房玉辉 博客：https://ElonJelinek.github.io爬虫珍爱网系列文章go语言爬虫入门第一课1、查看网站编码格式工具：GoLand，Chrome浏览器，珍爱网 所有城市页面 http://www.zhenai.com/zhenghun首先右键鼠标，查看网页源代码，查看网站编码格式，这里以gbk格式为例，， 123456789101112131415161718192021222324252627282930313233343536package mainimport ( "net/http" "fmt" "golang.org/x/text/transform" "golang.org/x/text/encoding/simplifiedchinese" "io/ioutil")const cityListURL = "http://www.zhenai.com/zhenghun"func main() &#123; resp, err := http.Get(cityListURL) if err != nil &#123; panic(err) //如果err不为空,说明出现错误数据，Panic结束程序。 &#125; defer resp.Body.Close() //关闭数据解析请求 if resp.StatusCode != http.StatusOK &#123; fmt.Println("Error:Status Code:", resp.StatusCode) &#125; // 以gbk格式读取网站源代码， utf8Reader := transform.NewReader(resp.Body, simplifiedchinese.GBK.NewDecoder()) // 读取网页所有数据，ReadAll方法返回值为[]byte字节数组，和err allData, err1 := ioutil.ReadAll(utf8Reader) if err1 != nil &#123; panic(err1) &#125; // 将字节数组转换为字符串，并打印输出 fmt.Println(string(allData))&#125; 网站编码格式有很多种，比如还有utf-8等格式，为了更好的封装，我们来写个方法，自动判断网站的编码格式， 12345678func determinEncoding(r io.Reader) encoding.Encoding &#123; bytes, err := bufio.NewReader(r).Peek(1024) if err != nil &#123; return unicode.UTF8 &#125; e, _, _ := charset.DetermineEncoding(bytes, "") return e&#125; 该方法的参数是resp.body,返回值即是编码格式。 2、观察目标字段看一下需要获取的字段长什么样，Chrome浏览器查看，在goland控制台打印， 1234567891011121314&lt;dd&gt; &lt;a href=&quot;http://www.zhenai.com/zhenghun/eerduosi&quot; class=&quot;&quot;&gt;鄂尔多斯&lt;/a&gt; &lt;a href=&quot;http://www.zhenai.com/zhenghun/enshi&quot; class=&quot;&quot;&gt;恩施&lt;/a&gt; &lt;a href=&quot;http://www.zhenai.com/zhenghun/ezhou&quot; class=&quot;&quot;&gt;鄂州&lt;/a&gt; &lt;/dd&gt; 可以看到，目标字段是很简单的格式，很容易获取，每一个a标签就是一个目标字段，正则表达式为：&lt;a href=&quot;(http://www.zhenai.com/zhenghun/[a-z0-9]+)&quot;[^&gt;]+&gt;([^&lt;]+)&lt;/a&gt;该正则表达式中有两个()，第一个括号中为目标网址，第二个括号中为城市名。 3、获取目标字段123match := regexp.MustCompile(`&lt;a href="(http://www.zhenai.com/zhenghun/[a-z0-9]+)"[^&gt;]+&gt;([^&lt;]+)&lt;/a&gt;`) bytes := match.FindAllSubmatch(allData, -1) regexp.MustCompile用来在文本中查找匹配正则表达式的内容。FindAllSubmatch方法的第2个参数表示查找次数，-1表示不限次数，查找多少次，就返回多少个字节数组；返回值是一个字节数组，里面有三个元素，是匹配到的结果，及其分组内容，返回值中的第 0 个元素是整个正则表达式的匹配结果，分组顺序按照“(”的出现次序而定，所以第 1 个元素是网址，第 2 个元素是城市名，接下来只需要遍历返回的字节数组，转化为字符串输出及得到最终结果。最后，全部代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package mainimport ( "net/http" "fmt" "io/ioutil" "regexp" "io" "golang.org/x/text/encoding" "bufio" "golang.org/x/net/html/charset" "golang.org/x/text/transform" "golang.org/x/text/encoding/simplifiedchinese")const cityListURL = "http://www.zhenai.com/zhenghun"func main() &#123; resp, err := http.Get(cityListURL) if err != nil &#123; panic(err) //如果err不为空,说明出现错误数据，Panic结束程序。 &#125; defer resp.Body.Close() //关闭数据解析请求 if resp.StatusCode != http.StatusOK &#123; fmt.Println("Error:Status Code:", resp.StatusCode) &#125; utf8Reader := transform.NewReader(resp.Body, simplifiedchinese.GBK.NewDecoder()) //e := determinEncoding(resp.Body) //utf8Reader := transform.NewReader(resp.Body, e.NewDecoder()) allData, err1 := ioutil.ReadAll(utf8Reader) if err1 != nil &#123; panic(err1) &#125; //fmt.Println(string(allData)) match := regexp.MustCompile(`&lt;a href="(http://www.zhenai.com/zhenghun/[a-z0-9]+)"[^&gt;]+&gt;([^&lt;]+)&lt;/a&gt;`) bytes := match.FindAllSubmatch(allData, 50) for key, value := range bytes &#123; fmt.Println(key+1, "城市：", string(value[2]), "网址：", string(value[1])) &#125;&#125;func determinEncoding(r io.Reader) encoding.Encoding &#123; bytes, err := bufio.NewReader(r).Peek(1024) if err != nil &#123; panic(err) &#125; e, _, _ := charset.DetermineEncoding(bytes, "") return e&#125; 结果如下： 1234561 城市： 阿坝 网址： http://www.zhenai.com/zhenghun/aba2 城市： 阿克苏 网址： http://www.zhenai.com/zhenghun/akesu......468 城市： 自贡 网址： http://www.zhenai.com/zhenghun/zigong469 城市： 资阳 网址： http://www.zhenai.com/zhenghun/ziyang1470 城市： 遵义 网址： http://www.zhenai.com/zhenghun/zunyi 版权声明：博客中的文章版权归博主所有，未经授权，禁止转载，转载请注明出处，合作请点击“关于我”，扫码添加微信]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>go语言爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在一台电脑上搭建etcd服务器集群]]></title>
    <url>%2F2017%2F12%2F31%2F%E5%9C%A8%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91%E4%B8%8A%E6%90%AD%E5%BB%BAetcd%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9B%86%E7%BE%A4%2F</url>
    <content type="text"><![CDATA[整理：房玉辉 博客：https://ElonJelinek.github.io在同一台电脑上开启三个节点 进入etcd/bin目录：cd go/src/github.com/coreos/etcd/bin 节点1打开第一个终端，进入etcd/bin目录执行: 1./etcd --name cd0 --initial-advertise-peer-urls http://127.0.0.1:2380 --listen-peer-urls http://127.0.0.1:2380 --listen-client-urls http://127.0.0.1:2379 --advertise-client-urls http://127.0.0.1:2379 --initial-cluster-token etcd-cluster-1 --initial-cluster cd0=http://127.0.0.1:2380,cd1=http://127.0.0.1:2480,cd2=http://127.0.0.1:2080 --initial-cluster-state new 节点2打开第二个终端，进入etcd/bin目录执行: 1./etcd --name cd1 --initial-advertise-peer-urls http://127.0.0.1:2480 --listen-peer-urls http://127.0.0.1:2480 --listen-client-urls http://127.0.0.1:2479 --advertise-client-urls http://127.0.0.1:2479 --initial-cluster-token etcd-cluster-1 --initial-cluster cd0=http://127.0.0.1:2380,cd1=http://127.0.0.1:2480,cd2=http://127.0.0.1:2080 --initial-cluster-state new 节点3打开第三个终端，进入etcd/bin目录执行: 1./etcd --name cd2 --initial-advertise-peer-urls http://127.0.0.1:2080 --listen-peer-urls http://127.0.0.1:2080 --listen-client-urls http://127.0.0.1:2079 --advertise-client-urls http://127.0.0.1:2079 --initial-cluster-token etcd-cluster-1 --initial-cluster cd0=http://127.0.0.1:2380,cd1=http://127.0.0.1:2480,cd2=http://127.0.0.1:2080 --initial-cluster-state new 查询 member 列表新开一个终端，进入etcd/bin目录，执行: 1234export ETCDCTL_API=3ENDPOINTS=127.0.0.1:2379,127.0.0.1:2479,127.0.0.1:2079./etcdctl --endpoints=$ENDPOINTS member list 运行结果： 1237a46237d7e589f81, started, cd2, http://127.0.0.1:2080, http://127.0.0.1:2079bf9071f4639c75cc, started, cd0, http://127.0.0.1:2380, http://127.0.0.1:2379e3ba87c3b4858ef1, started, cd1, http://127.0.0.1:2480, http://127.0.0.1:2479 在终端手动添加 member 节点member add 添加节点 1./etcdctl --endpoints=$ENDPOINTS member add cd3 --peer-urls=http://127.0.0.1:2180 运行结果 1234ETCD_NAME=&quot;cd3&quot;ETCD_INITIAL_CLUSTER=&quot;cd2=http://127.0.0.1:2080,cd0=http://127.0.0.1:2380,cd3=http://127.0.0.1:2180,cd1=http://127.0.0.1:2480&quot;ETCD_INITIAL_ADVERTISE_PEER_URLS=&quot;http://127.0.0.1:2180&quot;ETCD_INITIAL_CLUSTER_STATE=&quot;existing&quot; 查询 member 节点列表信息 1./etcdctl --endpoints=$ENDPOINTS member list 运行结果： 12347a46237d7e589f81, started, cd2, http://127.0.0.1:2080, http://127.0.0.1:2079bf9071f4639c75cc, started, cd0, http://127.0.0.1:2380, http://127.0.0.1:2379c886a1da995d65c1, unstarted, , http://127.0.0.1:2180, e3ba87c3b4858ef1, started, cd1, http://127.0.0.1:2480, http://127.0.0.1:2479 通过查询结果可以发现：http://127.0.0.1:2180 显示状态为：unstarted 启动新节点 1./etcd --name cd3 --listen-client-urls http://127.0.0.1:2179 --advertise-client-urls http://127.0.0.1:2179 --listen-peer-urls http://127.0.0.1:2180 --initial-advertise-peer-urls http://127.0.0.1:2180 --initial-cluster-state existing --initial-cluster cd2=http://127.0.0.1:2080,cd0=http://127.0.0.1:2380,cd3=http://127.0.0.1:2180,cd1=http://127.0.0.1:2480 --initial-cluster-token etcd-cluster-1 查询 member 节点列表信息 1./etcdctl --endpoints=$ENDPOINTS member list 运行结果： 12347a46237d7e589f81, started, cd2, http://127.0.0.1:2080, http://127.0.0.1:2079bf9071f4639c75cc, started, cd0, http://127.0.0.1:2380, http://127.0.0.1:2379c886a1da995d65c1, started, cd3, http://127.0.0.1:2180, http://127.0.0.1:2179e3ba87c3b4858ef1, started, cd1, http://127.0.0.1:2480, http://127.0.0.1:2479 代码实现 member 的管理添加节点12345678910111213func addMember(cli *clientv3.Client, peerURLs []string) &#123; // //向系统中插入节点 _, err := cli.MemberAdd(context.Background(), peerURLs) if err != nil &#123; fmt.Println("MemberAdd", err) &#125; //显示刚才插入节点信息 resp, err := cli.MemberList(context.Background()) if err != nil &#123; fmt.Println("MemberList", err) &#125; fmt.Println("添加后的members为", resp.Members)&#125; 1234567891011121314151617181920var ( dialTimeout = 5 * time.Second requestTimeout = 2 * time.Second endpoints = []string&#123;"127.0.0.1:2379"&#125;)//在main函数中调用addMember，添加端口为2280的节点func main() &#123; cli, err := clientv3.New(clientv3.Config&#123; Endpoints: endpoints, DialTimeout: dialTimeout, &#125;) if err != nil &#123; fmt.Println("clientv3.New", err) &#125; defer cli.Close() peerURLs := []string&#123;"http://127.0.0.1:2280"&#125; addMember(cli, peerURLs)&#125; Goland控制台运行结果 1添加后的members为 [ID:2468423305315244021 peerURLs:"http://127.0.0.1:2280" ID:8810768742894575489 name:"cd2" peerURLs:"http://127.0.0.1:2080" clientURLs:"http://127.0.0.1:2079" ID:13803658152347727308 name:"cd0" peerURLs:"http://127.0.0.1:2380" clientURLs:"http://127.0.0.1:2379" ID:14449414414712792513 name:"cd3" peerURLs:"http://127.0.0.1:2180" clientURLs:"http://127.0.0.1:2179" ID:16409577466894847729 name:"cd1" peerURLs:"http://127.0.0.1:2480" clientURLs:"http://127.0.0.1:2479" ] etcd没有提供用代码启动节点的方法，因此，执行完添加节点，需要打开终端手动启动节点，启动节点之后，才能再次添加节点（即一次只能添加一个节点，不能连续添加）。 1./etcd --name cd4 --listen-client-urls http://127.0.0.1:2279 --advertise-client-urls http://127.0.0.1:2279 --listen-peer-urls http://127.0.0.1:2280 --initial-advertise-peer-urls http://127.0.0.1:2180 --initial-cluster-state existing --initial-cluster cd2=http://127.0.0.1:2080,cd4=http://127.0.0.1:2280,cd0=http://127.0.0.1:2380,cd3=http://127.0.0.1:2180,cd1=http://127.0.0.1:2480 --initial-cluster-token etcd-cluster-1 查询 member 节点列表信息新开一个终端，进入etcd/bin目录，不要导入API，直接查询member列表 1./etcdctl --endpoints=$ENDPOINTS member list 运行结果 12345224199eafc9c57f5: name=cd4 peerURLs=http://127.0.0.1:2280 clientURLs=http://127.0.0.1:2279 isLeader=false7a46237d7e589f81: name=cd2 peerURLs=http://127.0.0.1:2080 clientURLs=http://127.0.0.1:2079 isLeader=falsebf9071f4639c75cc: name=cd0 peerURLs=http://127.0.0.1:2380 clientURLs=http://127.0.0.1:2379 isLeader=truec886a1da995d65c1: name=cd3 peerURLs=http://127.0.0.1:2180 clientURLs=http://127.0.0.1:2179 isLeader=falsee3ba87c3b4858ef1: name=cd1 peerURLs=http://127.0.0.1:2480 clientURLs=http://127.0.0.1:2479 isLeader=false 启动后etcd/bin目录如图 删除 member删除节点cd4 1./etcdctl --endpoints=$ENDPOINTS member remove 224199eafc9c57f5 运行结果： 1Removed member 224199eafc9c57f5 from cluster 查询 member 节点列表信息 1./etcdctl --endpoints=$ENDPOINTS member list 运行结果： 12347a46237d7e589f81: name=cd2 peerURLs=http://127.0.0.1:2080 clientURLs=http://127.0.0.1:2079 isLeader=falsebf9071f4639c75cc: name=cd0 peerURLs=http://127.0.0.1:2380 clientURLs=http://127.0.0.1:2379 isLeader=truec886a1da995d65c1: name=cd3 peerURLs=http://127.0.0.1:2180 clientURLs=http://127.0.0.1:2179 isLeader=falsee3ba87c3b4858ef1: name=cd1 peerURLs=http://127.0.0.1:2480 clientURLs=http://127.0.0.1:2479 isLeader=false 在Goland用程序删除节点 12345678func delMember(cli *clientv3.Client, memberId uint64) &#123; _, err := cli.MemberRemove(context.Background(), memberId) if err != nil &#123; fmt.Println("delMember", err) &#125; else &#123; fmt.Printf("删除节点%d成功\n", memberId) &#125;&#125; 1234567891011121314151617//在main函数中调用delMember，删除端口为2180的节点，即节点cd3func main() &#123; cli, err := clientv3.New(clientv3.Config&#123; Endpoints: endpoints, DialTimeout: dialTimeout, &#125;) if err != nil &#123; fmt.Println("clientv3.New", err) &#125; defer cli.Close() //第一种写法，14449414414712792513为Goland控制台输出的十进制ID //delMember(cli, 14449414414712792513) //第二种写法，c886a1da995d65c1为终端输出的十六进制ID delMember(cli, uint64(0xc886a1da995d65c1)) //2180，cd3&#125; Goland控制台运行结果 1删除节点14449414414712792513成功 版权声明：博客中的文章版权归博主所有，未经授权，禁止转载，转载请注明出处，合作请点击“关于我”，扫码添加微信]]></content>
      <categories>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>单机模拟etcd服务器集群</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go语言链表]]></title>
    <url>%2F2017%2F12%2F27%2Fgo%E8%AF%AD%E8%A8%80%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[整理：房玉辉 博客：https://ElonJelinek.github.io1、什么是链表：链表是一种数据存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列节点组成，节点可以在运行时动态生成。每个节点包括两个部分 存储数据元素的数据域存储下一个节点地址的地址域 2、链表与数组的区别： 数组长度固定，链表长度不固定数组的内存地址是连续的，链表的内存地址是不连续的数组可以随机读取，链表不可以随机读取数组内存空间开销比链表小，因为链表增加了地址域 3、链表结构： 数据域地址域第一个节点称为头节点，最后一个节点称为尾节点 123456type Node struct &#123; //数据域 Data string //地址域 NextNode *Node&#125; //声明全局变量，保存头节点和当前节点 var head *Node //头节点var curr *Node //当前节点、最新节点 创建头节点 12345678910func CreateHeadNode(data string) *Node &#123; var node = new(Node) node.Data = data node.NextNode = nil //保存头节点 head = node //保存当前节点 curr = node return node&#125; 添加节点 1234567891011func AddNode(data string) *Node &#123; var newNode = new(Node) newNode.Data = data newNode.NextNode = nil //挂接节点，当前节点的后节点为新节点 curr.NextNode = newNode //更新当前节点 curr = newNode return newNode&#125; 遍历链表 123456789101112131415func ShowNodes() &#123; fmt.Println("------------------") fmt.Println("遍历节点：") var node = head for &#123; //若遍历到某个节点，它的后节点为nil，则该节点为最后一个节点，则跳出循环 if node.NextNode == nil &#123; fmt.Print(node.Data, "\n") break &#125; else &#123; fmt.Println(node.Data) node = node.NextNode &#125; &#125;&#125; 统计节点个数 1234567891011121314func NodeCount() int &#123; var node = head var count = 0 for &#123; count++ if node.NextNode == nil &#123; //到最后一个节点的时候，跳出循环 break &#125; node = node.NextNode &#125; //fmt.Println("总共有", count, "个节点。") return count&#125; 在指定位置插入节点： 如果index为0，则插入的节点为头节点；如果index大于当前节点总数，则插入的节点为尾节点，直接调用AddNode()方法即可；如果index既不为0，又大于当前节点的index，则属于在两个节点中间插入节点，需要先找到index-1这个目标节点，再将找到的该目标节点的后一个节点指向新添加的节点的后节点，再将目标节点的后节点指向新添加的节点。 1234567891011121314151617181920212223func InsertNodeByIndex(index int, data string) &#123; if index == 0 &#123; var node = new(Node) node.Data = data node.NextNode = head head = node &#125; else if index &gt; NodeCount()-1 &#123; AddNode(data) &#125; else &#123; var n = head //找到目标节点，即index-1节点 for i := 0; i &lt; index-1; i++ &#123; n = n.NextNode &#125; var newNode = new(Node) newNode.Data = data //将新节点的后节点指向目标节点的后节点 newNode.NextNode = n.NextNode //目标节点的后节点指向新节点 n.NextNode = newNode &#125;&#125; 修改指定节点的内容 1234567891011func UpdateNodeByIndex(index int, data string) &#123; var node = head if index == 0 &#123; head.Data = data &#125; else &#123; for i := 0; i &lt; index; i++ &#123; node = node.NextNode &#125; node.Data = data &#125;&#125; 删除指定节点 1234567891011func DeleteNodeByIndex(index int) &#123; var node = head if index == 0 &#123; head = node.NextNode &#125; else &#123; for i := 0; i &lt; index-1; i++ &#123; node = node.NextNode &#125; node.NextNode = node.NextNode.NextNode &#125;&#125; 这是最简单的链表形式，实际中链表还分为单向链表，双向链表，循环链表，并且链表存储的数据可以是多种类型。而更新节点，删除、插入节点也要考虑更多方面。这里只是简单介绍一下。 版权声明：博客中的文章版权归博主所有，未经授权，禁止转载，转载请注明出处，合作请点击“关于我”，扫码添加微信]]></content>
      <categories>
        <category>go语言</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的GO语言实现]]></title>
    <url>%2F2017%2F12%2F13%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84GO%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[整理：房玉辉 博客：https://ElonJelinek.github.io二叉树的GO语言实现相关函数与方法 12345678910111213Insert()插入节点Max()找出最大值Min()找出最小值String()格式化输出Search()搜索某个值是否存在Remove()删除节点PreOrderTraverse()前序遍历InOrderTraverse()中序遍历PostOrderTraverse()后序遍历breadthFirstTraverse()广度优先遍历getCount()统计节点个数GetLeafCount()统计叶子节点个数GetDepth()二叉树的深度 代码实现： 12345678910111213141516171819202122package mainimport ( "sync" "fmt")type Item interface&#123;&#125;//节点的结构type Node struct &#123; key int value Item Left *Node Right *Node&#125;//树的结构type BinarySearchTree struct &#123; root *Node lock sync.RWMutex&#125; 插入节点 1234567891011121314151617181920212223242526272829//插入节点func (tree *BinarySearchTree) Insert(key int, value Item) &#123; tree.lock.Lock() defer tree.lock.Unlock() node := &amp;Node&#123;key, value, nil, nil&#125; if tree.root == nil &#123; tree.root = node &#125; else &#123; insertNode(tree.root, node) &#125;&#125;func insertNode(node, newNode *Node) &#123; if newNode.key &lt; node.key &#123; if node.Left == nil &#123; node.Left = newNode &#125; else &#123; insertNode(node.Left, newNode) &#125; &#125; else &#123; if node.Right == nil &#123; node.Right = newNode &#125; else &#123; insertNode(node.Right, newNode) &#125; &#125;&#125; 找出最大节点 123456789101112131415func (tree *BinarySearchTree) Max() *Item &#123; tree.lock.Lock() defer tree.lock.Unlock() node := tree.root if node == nil &#123; return nil &#125; for &#123; if node.Right == nil &#123; return &amp;node.value &#125; node = node.Right &#125;&#125; 最小节点 123456789101112131415func (tree *BinarySearchTree) Min() *Item &#123; tree.lock.Lock() defer tree.lock.Unlock() node := tree.root if node == nil &#123; return nil &#125; for &#123; if node.Left == nil &#123; return &amp;node.value &#125; node = node.Left &#125;&#125; 格式化输出二叉树 12345678910111213141516171819202122func (tree *BinarySearchTree) String() &#123; tree.lock.Lock() defer tree.lock.Unlock() fmt.Println("-----------------------------") stringify(tree.root, 0) fmt.Println("-----------------------------")&#125;func stringify(node *Node, level int) &#123; if node != nil &#123; format := "" for i := 0; i &lt; level; i++ &#123; format += " " &#125; format += "---[ " level++ stringify(node.Right, level) fmt.Printf(format+"%d\n", node.key) stringify(node.Left, level) &#125;&#125; 查找是否存在某个节点 12345678910111213141516171819202122func (tree *BinarySearchTree) Search(key int) bool &#123; tree.lock.Lock() defer tree.lock.Unlock() fmt.Print("是否存在节点", key, "：") return search(tree.root, key)&#125;func search(node *Node, key int) bool &#123; if node == nil &#123; return false &#125; if key &lt; node.key &#123; return search(node.Left, key) &#125; if key &gt; node.key &#123; return search(node.Right, key) &#125; return true&#125; 删除节点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950func (tree *BinarySearchTree) Remove(key int) &#123; tree.lock.Lock() defer tree.lock.Unlock() fmt.Println("删除节点：", key) remove(tree.root, key)&#125;func remove(node *Node, key int) *Node &#123; if node == nil &#123; return nil &#125; if key &lt; node.key &#123; node.Left = remove(node.Left, key) return node &#125; if key &gt; node.key &#123; node.Right = remove(node.Right, key) return node &#125; if node.Left == nil &amp;&amp; node.Right == nil &#123; node = nil return node &#125; if node.Left == nil &#123; node = node.Right return node &#125; if node.Right == nil &#123; node = node.Left return node &#125; mostRightNode := node.Left for &#123; if mostRightNode != nil &amp;&amp; mostRightNode.Right != nil &#123; mostRightNode = mostRightNode.Right &#125; else &#123; break &#125; &#125; node.key, node.value = mostRightNode.key, mostRightNode.value node.Left = remove(node.Left, node.key) return node&#125; 深度优先遍历：前序遍历，中序遍历，后序遍历是深度优先遍历的三种形式。前序遍历 1234567891011121314151617func (tree *BinarySearchTree) PreOrderTraverse() &#123; tree.lock.Lock() defer tree.lock.Unlock() fmt.Println("前序遍历：") node := tree.root preOrder(node) fmt.Println()&#125;func preOrder(node *Node) &#123; if node == nil &#123; return &#125; fmt.Print(node.value, "\t") preOrder(node.Left) preOrder(node.Right)&#125; 中序遍历 12345678910111213141516func (tree *BinarySearchTree) InOrderTraverse() &#123; tree.lock.Lock() defer tree.lock.Unlock() fmt.Println("中序遍历：") node := tree.root inOrder(node) fmt.Println()&#125;func inOrder(node *Node) &#123; if node != nil &#123; inOrder(node.Left) fmt.Print(node.value, "\t") inOrder(node.Right) &#125;&#125; 后序遍历 12345678910111213141516func (tree *BinarySearchTree) PostOrderTraverse() &#123; tree.lock.Lock() defer tree.lock.Unlock() fmt.Println("后序遍历：") node := tree.root postOrder(node) fmt.Println()&#125;func postOrder(node *Node) &#123; if node != nil &#123; postOrder(node.Left) postOrder(node.Right) fmt.Print(node.value, "\t") &#125;&#125; 广度优先遍历： 12345678910111213141516171819func (tree *BinarySearchTree) breadthFirstTraverse(node *Node) &#123; fmt.Println("广度优先遍历：") var result []Item var nodes = []Node&#123;*node&#125; for len(nodes) &gt; 0 &#123; node := nodes[0] nodes = nodes[1:] result = append(result, node.value) if node.Left != nil &#123; nodes = append(nodes, *node.Left) &#125; if node.Right != nil &#123; nodes = append(nodes, *node.Right) &#125; &#125; fmt.Println(result)&#125; 统计节点的个数 123456func getCount(node *Node) int &#123; if node == nil &#123; return 0 &#125; return getCount(node.Left) + getCount(node.Right) + 1&#125; 统计叶子节点的个数 123456789101112func GetLeafCount(node *Node) int &#123; if node == nil &#123; return 0 &#125; var sum = 0 if node.Left == nil &amp;&amp; node.Right == nil &#123; return 1 &#125; sum += GetLeafCount(node.Left) sum += GetLeafCount(node.Right) return sum&#125; 二叉树的深度 1234567891011121314func GetDepth(node *Node) int &#123; if node == nil &#123; return 0 &#125; return max(GetDepth(node.Left), GetDepth(node.Right)) + 1&#125;func max(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125; 运行结果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849----------------------------- ---[ 16 ---[ 14 ---[ 13 ---[ 12 ---[ 10 ---[ 9---[ 8 ---[ 7 ---[ 6 ---[ 5 ---[ 4 ---[ 3 ---[ 2 ---[ 1 ---[ 0-----------------------------最大值是： 16最小值是： 0是否存在节点11：false删除节点： 8----------------------------- ---[ 16 ---[ 14 ---[ 13 ---[ 12 ---[ 10 ---[ 9---[ 7 ---[ 6 ---[ 5 ---[ 4 ---[ 3 ---[ 2 ---[ 1 ---[ 0-----------------------------前序遍历：7 4 2 1 0 3 6 5 13 10 9 12 16 14 中序遍历：0 1 2 3 4 5 6 7 9 10 12 13 14 16 后序遍历：0 1 3 2 5 6 4 9 12 10 14 16 13 7 共有 14 个节点。叶子节点的个数为： 6二叉树的深度为： 5广度优先遍历：[7 4 13 2 6 10 16 1 3 5 9 12 14 0] 版权声明：博客中的文章版权归博主所有，未经授权，禁止转载，转载请注明出处，合作请点击“关于我”，扫码添加微信]]></content>
      <categories>
        <category>go语言</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用go语言简单实现SHA256哈希算法]]></title>
    <url>%2F2017%2F12%2F01%2F%E7%94%A8go%E8%AF%AD%E8%A8%80%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0SHA256%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[整理：房玉辉 博客：https://ElonJelinek.github.io用go语言简单实现SHA256哈希算法：12345678910111213141516package mainimport ( "crypto/sha256" "fmt")func main() &#123; string := "Hello" //需要哈希的字符串内容 hash := sha256.New() //声明sha256哈希函数 hash.Write([]byte(string)) bs := hash.Sum(nil) fmt.Printf("%x", bs)&#125; 运行结果：185f8db32271fe25f561a6fc938b2e264306ec304eda518007d1764826381969其中，hash.Write()写入需要生成哈希的内容，h.Sum()添加额外的[]byte到当前的哈希中。 生成符合某一条件的哈希：12345678910111213141516171819202122232425262728293031323334353637383940package mainimport ( "fmt" "crypto/sha256")func isvhd(hash string, diff int) bool &#123; var i int for i = 0; i &lt; len(hash); i++ &#123; if hash[i] != '8' &#123; //哈希字符串的前diff个字符是否为8，如果不为8，结束循环。 break &#125; &#125; return i &gt;= diff&#125;func main() &#123; nonce := 0 hash := "" shaobj := sha256.New() prehash := "0000fedaa499741317a18f1ad626f933776ad24822cb422634978bfe8005c94b" //prehash := "185f8db32271fe25f561a6fc938b2e264306ec304eda518007d1764826381969" count := 0 //循环的次数 for !isvhd(hash, 4) &#123; nonce++ input := "100" + prehash + "Thu, 26 Apr 2018 03:30:54 GMT" + "A -&gt; B 1000" + string(nonce) shaobj.Write([]byte(input)) hash = fmt.Sprintf("%x", shaobj.Sum(nil)) fmt.Println(hash) count++ &#125; fmt.Println("count:", count) fmt.Println("nonce:", nonce) fmt.Println(hash) fmt.Println(len(hash)) //哈希字符串的长度&#125; 运行结果：············0c7d465c78faf8dcc359343df18d535497b6dee228577f84b236e908193c65228888448863c33dff9acdc99dc6b85ca3329716c4d6fa3f51a540e2b977347ac6count: 11743nonce: 117438888448863c33dff9acdc99dc6b85ca3329716c4d6fa3f51a540e2b977347ac664 分析：isvhd（）函数用来判断生成的哈希内容是否满足某一条件，此处为判断生成的哈希数，前4位数是否为8。若不满足这一条件，则给nonce加1，再次生成哈希，直到生成一个前4位数均为8的哈希，结束循环。生成了一个前四位数为8的哈希，哈希字符串长度为64，循环了11743次。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>sha256哈希算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac下生成RSA私钥和公钥]]></title>
    <url>%2F2017%2F11%2F30%2Fmac%E4%B8%8B%E7%94%9F%E6%88%90rsa%E7%A7%81%E9%92%A5%E5%92%8C%E5%85%AC%E9%92%A5%2F</url>
    <content type="text"><![CDATA[整理：房玉辉 博客：https://ElonJelinek.github.io第一种方式（执行第2步之后，需要输入两次开机密码）：打开终端：输入：openssl依次输入命令：1、制作私钥genrsa -out rsa_private_key.pem 20482、设置私钥为PKCS8格式pkcs8 -topk8 -inform PEM -in rsa_private_key.pem -outform PEM 注意：执行完第2步，终端会输出以—–BEGIN ENCRYPTED PRIVATE KEY—–开头，以—–END ENCRYPTED PRIVATE KEY—–结尾的私钥，不是RSA私钥：记住不要用此私钥，可以把这里的私钥保存一下，查看其长度，为1784。此时，/Users/（用户名）目录下也有了名为rsa_private_key.pem的私钥文件，可用记事本查看一下，是以—–BEGIN RSA PRIVATE KEY—–开头，以—–END RSA PRIVATE KEY—–结尾。这才是RSA私钥。3、通过私钥产生公钥rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem执行完第三步/Users/（用户名）目录下就已经有了两个文件：rsa_private_key.pemrsa_public_key.pem前者为私钥，后者为公钥。此时可以用记事本打开文件，公钥长度为450，私钥长度为1678，私钥与刚才控制台输出的私钥不一样也可以用命令行在终端查看秘钥：cat /Users/charlienike/rsa_private_key.pem### 第二种方式（不需要输密码）：打开终端：输入 openssl依次输入命令：1、genrsa -out rsa_private_key.pem 20482、pkcs8 -topk8 -inform PEM -in rsa_private_key.pem -outform PEM –nocrypt3、rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem命令执行过程中控制台不会输出私钥最后/Users/(用户名)目录下会生成两个文件，一个公钥，一个私钥，用记事本打开（或者用终端：cat 文件路径），公钥长度为450，私钥长度为1674。私钥的长度与第一种方式生成的私钥不一样长（1678、1674）。 注意：RSA私钥是以—–BEGIN RSA PRIVATE KEY—–开头，以—–END RSA PRIVATE KEY—–结尾，公钥是以—–BEGIN PUBLIC KEY—–开头，以—–END PUBLIC KEY—–结尾，第一种方式执行过程中终端输出的并不是RSA私钥。两种方式的不同是第二种方式的第2条命令后面多了个–nocrypt，第二种方式执行过程中不会输出私钥，也不需要输入密码，因此推荐使用第二种方式，以避免混淆。 同理：如果要生成1024字节的秘钥，只需要将第1行命令最后的2048改成1024即可：rsa_private_key.pem 1024同样推荐使用第二种方式，因为不需要输密码，且不易混淆。若使用第一种方式，过程中终端输出的私钥同样不是以—–BEGIN RSA PRIVATE KEY—–开头，不是RSA私钥，长度为992。正确的秘钥，即在用户名目录下生成的两个秘钥文件，私钥长度为886，公钥长度为271。 版权声明：博客中的文章版权归博主所有，未经授权，禁止转载，转载请注明出处，合作请点击“关于我”，扫码添加微信]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>RSA秘钥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序算法]]></title>
    <url>%2F2017%2F11%2F28%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[整理：房玉辉 博客：https://ElonJelinek.github.io快速排序算法目前世界上一般情况下最好的算法是“快速排序算法”，该算法由英国计算机科学家托尼·霍尔于1961年发表，是迄今为止世界计算机产业中使用最多的排序算法。 什么是快速排序：快速排序强调少做事情，其原理大致如下： 首先，对一个无序数组，从中随机挑选一个，比如是68，这个被随机选中的数字被称为枢值，之后，把数组中的所有数字分成两部分，第一部分是大于等于68的，第二部分是小于68的。在第一部完成之后，无序数组就变得稍微有序一点了。 第二步，将上面得到的两个数组，分别采用第一步的方法各自再找一个枢值。对于第一部分数字，由于所有的数字都大于或等于68，因此，第二次随机挑选的枢值肯定是一个大于68的数字，比如79；类似的，对于第二部分由于所有数字都小于68，因此第二次随机挑选的枢值肯定小于它，比如15。接下来，再把两堆数字各自分成大于等于相应枢值的数组，以及小于枢值的数组。这样做下来，原来的一个数组就变成了四个小的数组，他们分别是小于15的数字，介于15到68之间的数字，介于68到79之间的数字，以及大于79的数字。 再接下来，用同样的方法，四组变八组，八组变十六组，很快所有的数字就排好序列了。快速排序与其他排序：快速排序通常情况下复杂度是N乘以log(N)，和归并排序相同。根据计算机科学的标准，它们同样好，不过在工程上，快速排序一般比归并排序块两倍，因此在工程上还是有意义的，这也是很多人用快速排序的原因。快速排序比归并排序快一些，可以在计算机科学上证明，这里打个比方，比较一下：假如有一个学区，里面有20000名高中生，如果让大家到一个超级大的学校上大课，从里面跳出学生中的尖子，效率一定不高。这就是冒泡排序，每个人都要和所有人比较。如果把这20000人放到10所学校中，每所学校都只有两千人，从各个学校各自跳出尖子生，再进行比较，效率就高的多了。这就是归并排序。如果先划出几个分数线，根据个人成绩的高低把20000名学生分到10所学校，第一所学校的学生成绩最好，第十所最差，再找出尖子生，那就容易多了，工作量最小。这就是快速排序，所以快速排序比归并排序要快。 代码实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344package mainimport ( "fmt")func main() &#123; arr := []int&#123;12, 12, 8, 9, 0, 18, 6, 2, 24, 4, 22, 13, 11, 3, 5, 12, 6&#125; quickSort(arr, 0, len(arr)-1) fmt.Println(arr)&#125;func quickSort(arr []int, left, right int) &#123; i := left j := right temp := arr[left] //枢值 for i != j &#123; for arr[j] &gt;= temp &amp;&amp; i &lt; j &#123; //从最后一个数开始，直到找到小于枢值的数，停止循环 j-- &#125; for arr[i] &lt;= temp &amp;&amp; i &lt; j &#123; //从第一个数开始，直到找到大于枢值的数，停止循环 i++ &#125; if i &lt; j &#123; arr[i], arr[j] = arr[j], arr[i] &#125; &#125; //最后，当i等于j的时候，i之前（包括i）是小于枢值的数字，i之后是大于枢值的数字，所以，将枢值与下标为i的数字互换，之后，分别处理枢值两边的数。 arr[i], arr[left] = temp, arr[i] //递归处理枢值左边未处理的 if left &lt; i-1 &#123; quickSort(arr, left, i-1) &#125; //递归处理枢值右边未处理的 if i != len(arr)-1 &amp;&amp; i+1 &lt; right &#123; quickSort(arr, i+1, right) &#125;&#125; 运行结果： 1[0 2 3 4 5 6 6 8 9 11 12 12 12 13 18 22 24] 快速排序通常是最好的算法，但是，在极端情况下，其复杂度是N的平方，和冒泡排序一样糟糕。而归并排序即使是在最坏的情况下，也能保证N乘以log(N)的复杂度。所以，并没有绝对最好的算法。 版权声明：博客中的文章版权归博主所有，未经授权，禁止转载，转载请注明出处，合作请点击“关于我”，扫码添加微信]]></content>
      <categories>
        <category>go语言</category>
      </categories>
      <tags>
        <tag>快速排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac配置环境变量]]></title>
    <url>%2F2017%2F03%2F26%2FMac%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[整理：房玉辉 博客：https://ElonJelinek.github.io1、找到.bash_profile文件Mac上的环境变量都在隐藏文件.bash_profile里配置，该文件一般都在Mac的用户名目录下，打开访达，进入到用户名目录，按shift+command+•，就可以看见用户名目录下的所有文件（包括隐藏文件），如图，我的用户名为CharlieNike第三个文件.bash_profile就是Mac的配置环境变量的文件；或者打开终端，输入：ls -a，就可以看见用户名目录下的所有文件和文件夹（包括隐藏的）；如果用户名目录下没有该文件，说明之前未配置过环境变量，该文件不存在，就打开终端，输入： 1touch .bash_profile 创建.bash_profile文件。 2、编辑.bash_profile文件有了该文件之后，可用记事本打开，进行编辑；或者在终端输入： 1open -e .bash_profile 就可以调用记事本打开该文件，编辑完成后，保存退出。例如，我的golang的环境变量如下 12export GOPATH=/Users/charlienike/goexport PATH=/Users/charlienike/bin:$GOPATH/bin:$PATH 3、使配置生效编辑完成后，在终端输入： 1source .bash_profile 才能使刚刚配置的环境变量生效。 版权声明：博客中的文章版权归博主所有，未经授权，禁止转载，转载请注明出处，合作请点击“关于我”，扫码添加微信]]></content>
      <categories>
        <category>Mac操作</category>
      </categories>
      <tags>
        <tag>环境变量</tag>
      </tags>
  </entry>
</search>
