{"meta":{"title":"商山早行人","subtitle":"房玉辉区块链博客","description":"拥抱这个时代，疯狂这个青春，用青春点亮未来，为时代树立标杆！","author":"房玉辉","url":"http://yoursite.com"},"pages":[{"title":"关于我","date":"2018-05-03T12:02:12.000Z","updated":"2018-05-06T08:39:44.679Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"房玉辉，区块链底层开发者、架构师，国内区块链高级专家。 联系我 微信： QQ："},{"title":"categories","date":"2018-05-04T12:30:30.000Z","updated":"2018-05-10T01:12:07.827Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-04-30T16:00:01.000Z","updated":"2018-05-10T01:09:46.950Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"MySQL慢查询","slug":"MySQL慢查询","date":"2018-08-01T11:19:10.000Z","updated":"2018-09-26T10:24:50.215Z","comments":true,"path":"2018/08/01/MySQL慢查询/","link":"","permalink":"http://yoursite.com/2018/08/01/MySQL慢查询/","excerpt":"整理：房玉辉","text":"整理：房玉辉 博客：https://ElonJelinek.github.io查看MySQL慢查询的时间上限：show variables like &quot;long%&quot;;查看慢查询是否开启：show variables like &quot;slow%&quot;; 12345678910111213141516171819mysql&gt; show variables like \"long%\";+-----------------+-----------+| Variable_name | Value |+-----------------+-----------+| long_query_time | 10.000000 |+-----------------+-----------+1 row in set (0.06 sec)mysql&gt; show variables like \"slow%\";+---------------------+-------------------------------------------+| Variable_name | Value |+---------------------+-------------------------------------------+| slow_launch_time | 2 || slow_query_log | OFF || slow_query_log_file | /usr/local/var/mysql/ElonJelinek-slow.log |+---------------------+-------------------------------------------+3 rows in set (0.00 sec)mysql&gt; long_query_time的默认值为10秒，表示超过10秒的查询就写入慢查询日志，这个时间可以修改，如果设置为0，表示记录所有的查询。slow_query_log的值有两个，OFF和ON，OFF表示关闭日志记录，ON表示开启日志记录，默认为关闭。slow_query_log_file的值表示慢查询日志的存放位置，和慢查询日志的文件名。slow_launch_time的默认值为2秒，这个字段与创建线程有关，如果创建线程的时间超过2秒，MySQL就会增加一个字段Slow_launch_threads。 设置慢查询时间1234567891011121314151617181920mysql&gt; show variables like \"long%\";+-----------------+-----------+| Variable_name | Value |+-----------------+-----------+| long_query_time | 10.000000 |+-----------------+-----------+1 row in set (0.01 sec)mysql&gt; set global long_query_time=5;Query OK, 0 rows affected (0.00 sec)mysql&gt; show variables like \"long%\";+-----------------+-----------+| Variable_name | Value |+-----------------+-----------+| long_query_time | 10.000000 |+-----------------+-----------+1 row in set (0.01 sec)mysql&gt; exit 这里其实已经更改成功了，但是再次查看，发现时间还是10，是因为更改后需要重启MySQL，或者退出MySQL，再重新进入，再来看，已经变成了5 123456789mysql&gt; show variables like \"long%\";+-----------------+----------+| Variable_name | Value |+-----------------+----------+| long_query_time | 5.000000 |+-----------------+----------+1 row in set (0.00 sec)mysql&gt; 打开日志记录1234567891011121314mysql&gt; set global slow_query_log=on;Query OK, 0 rows affected (0.00 sec)mysql&gt; show variables like \"slow%\";+---------------------+-------------------------------------------+| Variable_name | Value |+---------------------+-------------------------------------------+| slow_launch_time | 2 || slow_query_log | ON || slow_query_log_file | /usr/local/var/mysql/ElonJelinek-slow.log |+---------------------+-------------------------------------------+3 rows in set (0.01 sec)mysql&gt; 这里更改后slow_query_log的值直接就变成了ON，这样，查询时间超过5秒的查询语句，就会被写进慢查询日志。 慢查询时间不宜设置过长，否则意义不大，对于一般web程序来说，一个SQL语句的执行时间超过1秒，就算慢的了。如果某条SQL语句经常查询慢那基本可以判断是可以再次优化的。 打开慢查询可能会对系统性能有些影响。 show命令show命令用来查看MySQL状态及变量，找到系统瓶颈。 下面四个命令，在MySQL中输入 12345678// 显示状态信息（扩展show status like 'XXX'）Mysql&gt; show status;// 显示系统变量（扩展show variables like 'XXX'）Mysql&gt; show variables;// 显示InnoDB存储引擎的状态Mysql&gt; show engine innodb status;// 查看当前SQL执行，包括执行状态、是否锁表等Mysql&gt; show processlist; innodb存储引擎状态部分信息 12345678910111213141516171819202122232425262728293031323334353637mysql&gt; show engine innodb status;（……………………省略…………………）LOG---Log sequence number 20011557Log buffer assigned up to 20011557Log buffer completed up to 20011557Log written up to 20011557Log flushed up to 20011557Added dirty pages up to 20011557Pages flushed up to 20011557Last checkpoint at 2001155711 log i/o's done, 0.00 log i/o's/second----------------------BUFFER POOL AND MEMORY----------------------Total large memory allocated 137428992Dictionary memory allocated 380672Buffer pool size 8192Free buffers 7130Database pages 1058Old database pages 410Modified db pages 0Pending reads 0Pending writes: LRU 0, flush list 0, single page 0Pages made young 0, not young 00.00 youngs/s, 0.00 non-youngs/sPages read 926, created 132, written 1390.00 reads/s, 0.00 creates/s, 0.00 writes/sNo buffer pool page gets since the last printoutPages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/sLRU len: 1058, unzip_LRU len: 0I/O sum[0]:cur[0], unzip sum[0]:cur[0]（……………………省略…………………） 下面两个命令直接在终端中输入mysqladmin variables -u username -p passwordmysqladmin extended-status -u username -p password 示例 1234// 显示系统变量Shell&gt; mysqladmin variables -h 127.0.0.1 -u Tom -p// 显示状态信息Shell&gt; mysqladmin extended-status -h 127.0.0.1 -u Tom -p MySQL慢查询日志分析工具mysqldumpslow是MySQL自带的慢查询日志分析工具，直接在终端查看其使用帮助 123456789101112131415161718192021222324252627282930313233ElonJelinek:~ ElonJelinek$ mysqldumpslow -hOption h requires an argumentERROR: bad optionUsage: mysqldumpslow [ OPTS... ] [ LOGS... ]Parse and summarize the MySQL slow query log. Options are --verbose verbose --debug debug --help write this text to standard output -v verbose -d debug -s ORDER what to sort by (al, at, ar, c, l, r, t), 'at' is default al: average lock time ar: average rows sent at: average query time c: count l: lock time r: rows sent t: query time -r reverse the sort order (largest last instead of first) -t NUM just show the top n queries -a don't abstract all numbers to N and strings to 'S' -n NUM abstract numbers with at least n digits within names -g PATTERN grep: only consider stmts that include this string -h HOSTNAME hostname of db server for *-slow.log filename (can be wildcard), default is '*', i.e. match all -i NAME name of server instance (if using mysql.server startup script) -l don't subtract lock time from total timeElonJelinek:~ ElonJelinek$ 版权声明：博客中的文章版权归博主所有，未经授权，禁止转载，转载请注明出处，合作请点击“关于我”，扫码添加微信","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"MySQL数据库","slug":"MySQL数据库","permalink":"http://yoursite.com/tags/MySQL数据库/"}]},{"title":"MySQL8.0：Go连接MySQL","slug":"MySQL8.0：Go连接MySQL","date":"2018-07-31T13:20:00.000Z","updated":"2018-09-09T02:45:52.636Z","comments":true,"path":"2018/07/31/MySQL8.0：Go连接MySQL/","link":"","permalink":"http://yoursite.com/2018/07/31/MySQL8.0：Go连接MySQL/","excerpt":"整理：房玉辉","text":"整理：房玉辉 博客：https://ElonJelinek.github.iogo连接MySQL需要使用第三方包：github.com/Go-SQL-Driver/MySQL，因此，首先下载这个包，打开终端，输入：go get github.com/Go-SQL-Driver/MySQL，这个包就会被下载到gopath的src/github.com目录下。 连接打开数据库，使用open()函数： 1db, err := sql.Open(\"mysql\", \"用户名:密码@tcp(IP:端口)/数据库?charset=utf8\") 示例：db, err := sql.Open(&quot;mysql&quot;, &quot;Tom:456789@tcp(127.0.0.1:3306)/mysql2018?charset=utf8&quot;) 增删改查添加数据第一种方法：直接使用三方库的Exec()函数添加 1func (db *DB) Exec(query string, args ...interface&#123;&#125;) (Result, error) 示例： 1result, err := db.Exec(\"INSERT INTO userinfo (username, departname, created) VALUES (?, ?, ?)\",\"lily\",\"销售\",\"2016-06-21\") 返回的result是个接口，里面有两个函数，第一个LastInsertId()用来查看最近插入的数据的ID，第二个RowsAffected()用来查看本次插入对原表的影响有几行，也就是插入了几行数据。其中，LastInsertId()函数只支持查询字段属性为自增长的ID。 完整示例：这里加载的驱动是匿名的，限定其别名为_，所以整个代码中没有一个可见的MySQL包名。 1234567891011121314151617181920212223242526272829package mainimport ( \"database/sql\" \"fmt\" _ \"github.com/Go-SQL-Driver/MySQL\")func main() &#123; db, err := sql.Open(\"mysql\", \"Tom:456789@tcp(127.0.0.1:3306)/mysql2018?charset=utf8\") if err != nil &#123; fmt.Println(\"打开数据库失败：\", err) return &#125; result, err := db.Exec(\"INSERT INTO students (StudentID, name, age, sex, username) VALUES (?, ?, ?, ?, ?)\", 9565, \"总钻风\", 29, \"男\", \"巡山\") if err != nil &#123; fmt.Println(\"exec失败\", err) &#125; rows, _ := result.RowsAffected() insertId, _ := result.LastInsertId() if err != nil &#123; fmt.Println(\"result失败\", err) &#125; fmt.Println(\"成功插入：\", rows, \"行。\") fmt.Println(\"插入数据的ID：\", insertId)&#125; 运行结果： 12成功插入： 1 行。插入数据的ID： 9565 在终端查看： 123456789101112131415mysql&gt; select * from students;+-----------+-----------+------+------+----------+----------+| StudentID | name | age | sex | username | password |+-----------+-----------+------+------+----------+----------+| 9556 | Lily | 21 | 女 | | 123456 || 9559 | 梅长苏 | 28 | 男 | | 123456 || 9560 | 穆霓凰 | 26 | 女 | | 123456 || 9561 | 飞流 | 17 | 男 | | 123456 || 9562 | 萧景琰 | 28 | 男 | 靖王 | 123456 || 9563 | 萧景琰 | 28 | 男 | 靖王 | 123456 || 9565 | 总钻风 | 29 | 男 | 巡山 | 123456 |+-----------+-----------+------+------+----------+----------+7 rows in set (0.00 sec)mysql&gt; 第二种方法：首先使用Prepare()函数获得stmt，然后调用Exec添加 1func (db *DB) Prepare(query string) (*Stmt, error) 示例代码： 123stmt, err := db.Prepare(\"INSERT userinfo SET username=?,departname=?,created=?\")result, err := stmt.Exec(\"zhja\", \"研发\", \"2016-06-17\") 查看影响的行数，以判断是否插入成功： 1count, err := result.RowsAffected() 获得刚刚添加数据的自增ID： 1id, err := result.LastInsertId() 完整示例：在mysql2018数据库的emp表中插入一条数据，用Tom@127.0.0.1用户进行登录，操作 123456789101112131415161718192021222324252627282930package mainimport ( \"database/sql\" \"fmt\" _ \"github.com/Go-SQL-Driver/MySQL\")func main() &#123; db, err := sql.Open(\"mysql\", \"Tom:456789@tcp(127.0.0.1:3306)/mysql2018?charset=utf8\") if err != nil &#123; fmt.Println(\"打开数据库失败\", err) return &#125; stmt, err1 := db.Prepare(\"INSERT INTO emp(empno,ename,job,hiredate,sal) values(?,?,?,?,?)\") if err1 != nil &#123; fmt.Println(\"Prepare 失败！\", err1) return &#125; rest, err2 := stmt.Exec(9599, \"小钻风\", \"巡山\", \"2018-04-21\", 30.8) if err2 != nil &#123; fmt.Println(\"插入数据失败\", err2) return &#125; count, _ := rest.RowsAffected() fmt.Println(\"影响的行数\", count)&#125; 运行结果： 1影响的行数 1 在终端打开MySQL查询一下： 1234567891011121314151617181920212223mysql&gt; select * from emp;+-------+-----------+-----------+------+---------------------+---------+---------+--------+| empno | ename | job | mgr | hiredate | sal | comm | deptno |+-------+-----------+-----------+------+---------------------+---------+---------+--------+| 7369 | SMITH | CLERK | 7902 | 1980-12-17 00:00:00 | 800.00 | NULL | 20 || 7499 | ALLEN | SALESMAN | 7698 | 1981-02-20 00:00:00 | 1600.00 | 300.00 | 30 || 7521 | WARD | SALESMAN | 7698 | 1981-02-22 00:00:00 | 1250.00 | 500.00 | 30 || 7566 | JONES | MANAGER | 7839 | 1981-04-02 00:00:00 | 2975.00 | NULL | 20 || 7654 | MARTIN | SALESMAN | 7698 | 1981-09-28 00:00:00 | 1250.00 | 1400.00 | 30 || 7698 | BLAKE | MANAGER | 7839 | 1981-05-01 00:00:00 | 2850.00 | NULL | 30 || 7782 | CLARK | MANAGER | 7839 | 1981-06-09 00:00:00 | 2450.00 | NULL | 10 || 7788 | SCOTT | ANALYST | 7566 | 1982-12-09 00:00:00 | 3000.00 | NULL | 20 || 7839 | KING | PRESIDENT | NULL | 1981-11-17 00:00:00 | 5000.00 | NULL | 10 || 7844 | TURNER | SALESMAN | 7698 | 1981-09-08 00:00:00 | 1500.00 | 0.00 | 30 || 7876 | ADAMS | CLERK | 7788 | 1983-01-12 00:00:00 | 1100.00 | NULL | 20 || 7900 | JAMES | CLERK | 7698 | 1981-12-03 00:00:00 | 950.00 | NULL | 30 || 7902 | FORD | ANALYST | 7566 | 1981-12-03 00:00:00 | 3000.00 | NULL | 20 || 7934 | MILLER | CLERK | 7782 | 1982-01-23 00:00:00 | 1300.00 | NULL | 10 || 9599 | 小钻风 | 巡山 | NULL | 2018-04-21 00:00:00 | 30.80 | NULL | NULL |+-------+-----------+-----------+------+---------------------+---------+---------+--------+15 rows in set (0.00 sec)mysql&gt; 插入成功。 查询数据查询一条数据：调用函数QueryRow()，再调用Scan()函数将查询结果进行保存 1func (db *DB) QueryRow(query string, args ...interface&#123;&#125;) *Row 保存结果： 1func (r *Row) Scan(dest ...interface&#123;&#125;) error 完整代码： 123456789101112131415161718192021222324252627282930package mainimport ( \"database/sql\" \"fmt\" _ \"github.com/Go-SQL-Driver/MySQL\")func main() &#123; db, err := sql.Open(\"mysql\", \"Tom:456789@tcp(127.0.0.1:3306)/mysql2018?charset=utf8\") defer db.Close() if err != nil &#123; fmt.Println(\"打开数据库失败：\", err) return &#125; var StudentID int var name string var age string var sex string var username string var password string row := db.QueryRow(\"select * from students where name=?\", \"飞流\") err1 := row.Scan(&amp;StudentID, &amp;name, &amp;age, &amp;sex, &amp;username, &amp;password) if err1 != nil &#123; fmt.Println(\"获取失败：\", err1) &#125; fmt.Println(StudentID, name, age, sex, username, password)&#125; 运行结果： 19561 飞流 17 男 123456 查询多条数据：直接调用函数Query()获取数据，再调用函数Next()遍历数据。 1func (db *DB) Query(query string, args ...interface&#123;&#125;) (*Rows, error) 遍历： 1func (rs *Rows) Next() bool 完整示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package mainimport ( \"database/sql\" \"fmt\" _ \"github.com/Go-SQL-Driver/MySQL\")type Emp struct &#123; empno int ename string job string hiredate string salary float64 deptno int&#125;func main() &#123; db, err := sql.Open(\"mysql\", \"Tom:456789@tcp(127.0.0.1:3306)/mysql2018?charset=utf8\") defer db.Close() if err != nil &#123; fmt.Println(\"打开数据库失败：\", err) return &#125; rows, err1 := db.Query(\"select empno,ename,job,hiredate,sal,deptno from emp where deptno=?\", 20) defer rows.Close() if err1 != nil &#123; fmt.Println(\"查询失败\", err1) return &#125; datas := make([] Emp, 0) for rows.Next() &#123; var empno int var ename string var job string var hiredate string var salary float64 var deptno int if err2 := rows.Scan(&amp;empno, &amp;ename, &amp;job, &amp;hiredate, &amp;salary, &amp;deptno); err2 != nil &#123; fmt.Println(\"获取失败\", err2) return &#125; emp := Emp&#123;empno, ename, job, hiredate, salary, deptno&#125; datas = append(datas, emp) &#125; for _, value := range datas &#123; fmt.Println(value) &#125;&#125; 运行结果： 12345&#123;7369 SMITH CLERK 1980-12-17 00:00:00 800 20&#125;&#123;7566 JONES MANAGER 1981-04-02 00:00:00 2975 20&#125;&#123;7788 SCOTT ANALYST 1982-12-09 00:00:00 3000 20&#125;&#123;7876 ADAMS CLERK 1983-01-12 00:00:00 1100 20&#125;&#123;7902 FORD ANALYST 1981-12-03 00:00:00 3000 20&#125; 修改数据完整示例： 123456789101112131415161718192021222324252627282930package mainimport ( \"database/sql\" \"fmt\" _ \"github.com/Go-SQL-Driver/MySQL\")func main() &#123; db, err := sql.Open(\"mysql\", \"Tom:456789@tcp(127.0.0.1:3306)/mysql2018?charset=utf8\") if err != nil &#123; fmt.Println(\"打开数据库失败\", err) return &#125; stmt, err1 := db.Prepare(\"update emp set mgr=?,sal=?,comm=?,deptno=? where empno=?\") if err1 != nil &#123; fmt.Println(\"Prepare 失败！\", err1) return &#125; rest, err2 := stmt.Exec(7934, 1100, 0,40, 9599) if err2 != nil &#123; fmt.Println(\"执行失败\", err2) return &#125; count, _ := rest.RowsAffected() fmt.Println(\"影响的行数\", count)&#125; 运行结果： 1影响的行数 1 删除数据完整示例： 123456789101112131415161718192021222324252627282930313233package mainimport ( \"database/sql\" \"fmt\" _ \"github.com/Go-SQL-Driver/MySQL\")func main() &#123; db, err := sql.Open(\"mysql\", \"Tom:456789@tcp(127.0.0.1:3306)/mysql2018?charset=utf8\") defer db.Close() if err != nil &#123; fmt.Println(\"连接数据库失败：\", err) return &#125; stmt, err := db.Prepare(\"delete from emp where ename=?\") if err != nil &#123; fmt.Println(err) &#125; res, err := stmt.Exec(\"总钻风\") if err != nil &#123; fmt.Println(\"删除失败\") &#125; num, err := res.RowsAffected() if err != nil &#123; fmt.Println(\"查询rows失败\") &#125; fmt.Println(\"影响的行数：\",num,\"行。\")&#125; 运行结果： 1影响的行数： 1 行。 这里的修改和删除操作都比较简单，只要修改func (db *DB) Prepare(query string) (*Stmt, error)函数里面的sql语句，和修改func (s *Stmt) Exec(args ...interface{}) (Result, error)函数里面的参数就可以了。 版权声明：博客中的文章版权归博主所有，未经授权，禁止转载，转载请注明出处，合作请点击“关于我”，扫码添加微信","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"MySQL数据库","slug":"MySQL数据库","permalink":"http://yoursite.com/tags/MySQL数据库/"}]},{"title":"MySQL8.0：复杂查询","slug":"MySQL8.0：复杂查询","date":"2018-07-30T11:10:00.000Z","updated":"2018-09-17T03:02:07.304Z","comments":true,"path":"2018/07/30/MySQL8.0：复杂查询/","link":"","permalink":"http://yoursite.com/2018/07/30/MySQL8.0：复杂查询/","excerpt":"整理：房玉辉","text":"整理：房玉辉 博客：https://ElonJelinek.github.io聚合函数MySQL聚合函数也叫分组函数或多行函数，接收多个输入，返回一个输出，包括 求和：sum()求最大值：max()求最小值：min()求平均值：avg()统计：count() 聚合函数经常搭配group by或having一起使用，接下来一一学习一下他们的用法 求和：sum(列名) 用来对不是null的值进行求和演示：select sum(sal) from emp; 表示求所有员工的月薪之和演示：select sum(comm) from emp; 表示求所有员工的奖金之和 1234567891011121314151617mysql&gt; select sum(sal) from emp;+----------+| sum(sal) |+----------+| 29025.00 |+----------+1 row in set (0.00 sec)mysql&gt; select sum(comm) from emp;+-----------+| sum(comm) |+-----------+| 2200.00 |+-----------+1 row in set (0.00 sec)mysql&gt; 求最大值：max(列名) 用来计算不是null的值得最大值演示：select max(sal) from emp; 查询最高月薪演示：select max(comm) as 最高奖金 from emp; 查询最高奖金 1234567891011121314151617mysql&gt; select max(sal) from emp;+----------+| max(sal) |+----------+| 5000.00 |+----------+1 row in set (0.00 sec)mysql&gt; select max(comm) as 最高奖金 from emp;+--------------+| 最高奖金 |+--------------+| 1400.00 |+--------------+1 row in set (0.00 sec)mysql&gt; 求平均值：avg(列名) 用来计算不是null的值的平均值演示：select avg(sal) as 平均工资 from emp; 123456789mysql&gt; select avg(sal) as 平均工资 from emp;+--------------+| 平均工资 |+--------------+| 2073.214286 |+--------------+1 row in set (0.00 sec)mysql&gt; 统计函数：count(列名) 统计某列总共有多少条记录演示：select count(*) from emp; 统计总共有多少条记录演示：select count(comm) from emp; 统计有奖金的人数 1234567891011121314151617mysql&gt; select count(*) from emp;+----------+| count(*) |+----------+| 14 |+----------+1 row in set (0.00 sec)mysql&gt; select count(comm) from emp;+-------------+| count(comm) |+-------------+| 4 |+-------------+1 row in set (0.00 sec)mysql&gt; 分组查询group by 列名，按照指定的列进行分组，值相同的在一起，但是，group by 单独使用的意义不大，例如： 123456789101112131415161718192021222324252627282930mysql&gt; select deptno from emp group by deptno;+--------+| deptno |+--------+| 20 || 30 || 10 |+--------+3 rows in set (0.00 sec)mysql&gt; select deptno,sal from emp group by deptno,sal;+--------+---------+| deptno | sal |+--------+---------+| 20 | 800.00 || 30 | 1600.00 || 30 | 1250.00 || 20 | 2975.00 || 30 | 2850.00 || 10 | 2450.00 || 20 | 3000.00 || 10 | 5000.00 || 30 | 1500.00 || 20 | 1100.00 || 30 | 950.00 || 10 | 1300.00 |+--------+---------+12 rows in set (0.00 sec)mysql&gt; 因此group by 的主要用法是配合聚合函数来使用，比如下面这样 1234567891011mysql&gt; select deptno,max(sal),avg(sal),min(sal),sum(sal),count(sal) from emp group by deptno;+--------+----------+-------------+----------+----------+------------+| deptno | max(sal) | avg(sal) | min(sal) | sum(sal) | count(sal) |+--------+----------+-------------+----------+----------+------------+| 20 | 3000.00 | 2175.000000 | 800.00 | 10875.00 | 5 || 30 | 2850.00 | 1566.666667 | 950.00 | 9400.00 | 6 || 10 | 5000.00 | 2916.666667 | 1300.00 | 8750.00 | 3 |+--------+----------+-------------+----------+----------+------------+3 rows in set (0.00 sec)mysql&gt; 也可以在分组之后，再加上排序，下面是用部门编号进行排序 1234567891011mysql&gt; select deptno,max(sal),avg(sal),min(sal),sum(sal),count(sal) from emp group by deptno order by deptno;+--------+----------+-------------+----------+----------+------------+| deptno | max(sal) | avg(sal) | min(sal) | sum(sal) | count(sal) |+--------+----------+-------------+----------+----------+------------+| 10 | 5000.00 | 2916.666667 | 1300.00 | 8750.00 | 3 || 20 | 3000.00 | 2175.000000 | 800.00 | 10875.00 | 5 || 30 | 2850.00 | 1566.666667 | 950.00 | 9400.00 | 6 |+--------+----------+-------------+----------+----------+------------+3 rows in set (0.00 sec)mysql&gt; 按部门平均工资进行排序 1234567891011mysql&gt; select deptno,max(sal),avg(sal),min(sal),sum(sal),count(sal) from emp group by deptno order by avg(sal);+--------+----------+-------------+----------+----------+------------+| deptno | max(sal) | avg(sal) | min(sal) | sum(sal) | count(sal) |+--------+----------+-------------+----------+----------+------------+| 30 | 2850.00 | 1566.666667 | 950.00 | 9400.00 | 6 || 20 | 3000.00 | 2175.000000 | 800.00 | 10875.00 | 5 || 10 | 5000.00 | 2916.666667 | 1300.00 | 8750.00 | 3 |+--------+----------+-------------+----------+----------+------------+3 rows in set (0.00 sec)mysql&gt; 上面的几个例子是以部门为单位进行分组，再统计各个部门的最高工资，平均工资，最低工资，工资之和，以及各个部门的员工人数。之后再按部门编号或者平均工资进行排序。 还可以先使用where对原始数据进行筛选，之后再通过group by进行分组，再使用聚合函数统计个部门工资情况，例如下面这个例子：首先排除每个部门月薪低于1000元的人员，之后再统计各部门的最高工资，平均工资，工资之和，对统计结果以部门编号进行排序 1234567891011mysql&gt; select deptno,max(sal),avg(sal),sum(sal) from emp where sal &gt;= 1000 group by deptno order by deptno;+--------+----------+-------------+----------+| deptno | max(sal) | avg(sal) | sum(sal) |+--------+----------+-------------+----------+| 10 | 5000.00 | 2916.666667 | 8750.00 || 20 | 3000.00 | 2518.750000 | 10075.00 || 30 | 2850.00 | 1690.000000 | 8450.00 |+--------+----------+-------------+----------+3 rows in set (0.00 sec)mysql&gt; 分组后限定查询having子句：在分组后再对数据进行筛选，需要使用having子句来完成 语法：select 列名 from 表名 group by 列名 having 条件;演示：select mgr from emp group by mgr having mgr is not null; 12345678910111213141516171819202122232425262728mysql&gt; select mgr from emp group by mgr;+------+| mgr |+------+| 7902 || 7698 || 7839 || 7566 || NULL || 7788 || 7782 |+------+7 rows in set (0.00 sec)mysql&gt; select mgr from emp group by mgr having mgr is not null;+------+| mgr |+------+| 7902 || 7698 || 7839 || 7566 || 7788 || 7782 |+------+6 rows in set (0.00 sec)mysql&gt; 更复杂一些的查询，按部门统计各部门的最高工资，以及部门工资之和，并挑选出工资之和小于1万元的，再按部门编号进行排序按部门统计各部门的最高工资，各部门工资之和，并挑选出部门编号大于10的，再按部门编号进行排序 12345678910111213141516171819202122232425262728mysql&gt; select deptno,max(sal),sum(sal) from emp group by deptno having sum(sal) &lt; 10000;+--------+----------+----------+| deptno | max(sal) | sum(sal) |+--------+----------+----------+| 30 | 2850.00 | 9400.00 || 10 | 5000.00 | 8750.00 |+--------+----------+----------+2 rows in set (0.00 sec)mysql&gt; select deptno,max(sal),sum(sal) from emp group by deptno having sum(sal) &lt; 10000 order by deptno;+--------+----------+----------+| deptno | max(sal) | sum(sal) |+--------+----------+----------+| 10 | 5000.00 | 8750.00 || 30 | 2850.00 | 9400.00 |+--------+----------+----------+2 rows in set (0.00 sec)mysql&gt; select deptno,max(sal),sum(sal) from emp group by deptno having deptno &gt; 10 order by deptno; +--------+----------+----------+| deptno | max(sal) | sum(sal) |+--------+----------+----------+| 20 | 3000.00 | 10875.00 || 30 | 2850.00 | 9400.00 |+--------+----------+----------+2 rows in set (0.00 sec)mysql&gt; 还可以在where之后，再跟着使用group by和having，例如：首先排除每个部门工资低于1000元的员工，再按部门统计各部门的最高工资，平均工资，工资之和，再挑选出部门编号大于10的部门，筛选结果以部门编号进行排序 12345678910mysql&gt; select deptno,max(sal),avg(sal),sum(sal) from emp where sal &gt;= 1000 group by deptno having deptno &gt; 10 order by deptno ;+--------+----------+-------------+----------+| deptno | max(sal) | avg(sal) | sum(sal) |+--------+----------+-------------+----------+| 20 | 3000.00 | 2518.750000 | 10075.00 || 30 | 2850.00 | 1690.000000 | 8450.00 |+--------+----------+-------------+----------+2 rows in set (0.00 sec)mysql&gt; having子句的作用是对group by分组后的结果，进行再次筛选，其与where语句的区别如下： where和having后面都是跟条件 where是对表中的数据进行原始筛选 having是对group by的结果的二次筛选 having必须配合group by使用，一般也配合聚合函数使用 可以先有where，后面跟着group by和having where是先过滤再分组，having是先分组再过滤 如果有order by 排序的，order by一般放在最后。 分页查询limit子句：用于限定查询结果的起始行，以及总行数 语法：select 列名 from 表名 limit start，count;这里的start表示查询结果的起始行，表示从start➕1行开始，count表示总行数。演示：select * from emp limit 0,3; 表示从第1行开始，查询3行。演示：select * from emp limit 13,3; 表示从第14行开始，查询3行。演示：select * from emp limit 14,3; 表示从第15行开始，查询3行。由于没有第15行，所以查询结果为空。 12345678910111213141516171819202122mysql&gt; select * from emp limit 0,3;+-------+-------+----------+------+---------------------+---------+--------+--------+| empno | ename | job | mgr | hiredate | sal | comm | deptno |+-------+-------+----------+------+---------------------+---------+--------+--------+| 7369 | SMITH | CLERK | 7902 | 1980-12-17 00:00:00 | 800.00 | NULL | 20 || 7499 | ALLEN | SALESMAN | 7698 | 1981-02-20 00:00:00 | 1600.00 | 300.00 | 30 || 7521 | WARD | SALESMAN | 7698 | 1981-02-22 00:00:00 | 1250.00 | 500.00 | 30 |+-------+-------+----------+------+---------------------+---------+--------+--------+3 rows in set (0.00 sec)mysql&gt; select * from emp limit 13,3;+-------+--------+-------+------+---------------------+---------+------+--------+| empno | ename | job | mgr | hiredate | sal | comm | deptno |+-------+--------+-------+------+---------------------+---------+------+--------+| 7934 | MILLER | CLERK | 7782 | 1982-01-23 00:00:00 | 1300.00 | NULL | 10 |+-------+--------+-------+------+---------------------+---------+------+--------+1 row in set (0.00 sec)mysql&gt; select * from emp limit 14,3;Empty set (0.00 sec)mysql&gt; 内置函数字符串函数查看字符的ASCII编码：select ascii(&#39;a&#39;); 字符串空串返回0查看ASCII编码对应的字符：select char(97); 编码0返回空字符串字符串拼接：select concat(12,34,&#39;ab&#39;); 1234567891011121314151617181920212223242526272829303132333435363738394041mysql&gt; select ascii('');+-----------+| ascii('') |+-----------+| 0 |+-----------+1 row in set (0.00 sec)mysql&gt; select char(0);+---------+| char(0) |+---------+| |+---------+1 row in set (0.01 sec)mysql&gt; select ascii('a');+------------+| ascii('a') |+------------+| 97 |+------------+1 row in set (0.00 sec)mysql&gt; select char(97);+----------+| char(97) |+----------+| a |+----------+1 row in set (0.00 sec)mysql&gt; select concat(12,34,'ab');+--------------------+| concat(12,34,'ab') |+--------------------+| 1234ab |+--------------------+1 row in set (0.00 sec)mysql&gt; 包含字符个数length(str) str包含几个字符截取字符串left(str,count) 返回str左端count个字符截取字符串right(str,count) 返回str右端count个字符 12345678910111213141516171819202122232425262728293031323334353637383940mysql&gt; select length(name) from students;+--------------+| length(name) |+--------------+| 4 || 9 || 9 || 6 || 9 || 9 |+--------------+6 rows in set (0.00 sec)mysql&gt; select left(name,2) from students;+--------------+| left(name,2) |+--------------+| Li || 梅长 || 穆霓 || 飞流 || 萧景 || 萧景 |+--------------+6 rows in set (0.00 sec)mysql&gt; select right(name,2) from students;+---------------+| right(name,2) |+---------------+| ly || 长苏 || 霓凰 || 飞流 || 景琰 || 景琰 |+---------------+6 rows in set (0.01 sec)mysql&gt; 除此之外，substring()，ltrim()，rtrim()，trim()，space()，replace()，lower()，upper()等函数，用法都很简单，就不一一列举了。 另外MySQL还提供了数学函数，时间日期函数，这里也不在列举。下面重点学习多表查询。 多表查询一张表的数据不够，需要其他表的数据来补充，需要同时对多张表进行查询，例如：查询部门不在accounting和sales中的员工信息 12345678910111213mysql&gt; select * from emp e,dept d where e.deptno=d.deptno and dname!= \"accounting\" and dname != \"sales\";+-------+-------+---------+------+---------------------+---------+------+--------+--------+----------+--------+| empno | ename | job | mgr | hiredate | sal | comm | deptno | deptno | dname | loc |+-------+-------+---------+------+---------------------+---------+------+--------+--------+----------+--------+| 7369 | SMITH | CLERK | 7902 | 1980-12-17 00:00:00 | 800.00 | NULL | 20 | 20 | RESEARCH | DALLAS || 7566 | JONES | MANAGER | 7839 | 1981-04-02 00:00:00 | 2975.00 | NULL | 20 | 20 | RESEARCH | DALLAS || 7788 | SCOTT | ANALYST | 7566 | 1982-12-09 00:00:00 | 3000.00 | NULL | 20 | 20 | RESEARCH | DALLAS || 7876 | ADAMS | CLERK | 7788 | 1983-01-12 00:00:00 | 1100.00 | NULL | 20 | 20 | RESEARCH | DALLAS || 7902 | FORD | ANALYST | 7566 | 1981-12-03 00:00:00 | 3000.00 | NULL | 20 | 20 | RESEARCH | DALLAS |+-------+-------+---------+------+---------------------+---------+------+--------+--------+----------+--------+5 rows in set (0.00 sec)mysql&gt; 除上面这样对多张表进行连接查询外，还有左外连接、右外连接以及自然连接等查询方法，需要使用join关键字，进行连接 左外连接左表记录无论是否满足条件都会查询出来，而右表只有满足条件才能查询出来，左表中不满足条件的记录，右表部分都为null 语法：select * from 表1 别名1 left outer join 表2 别名2 on 别名1.xx=别名2.xx演示：select empno,ename,job,sal,comm,d.deptno,d.dname from emp as e left outer join dept as d on e.deptno=d.deptno;这里的两个as都可以省略 12345678910111213141516171819202122mysql&gt; select empno,ename,job,sal,comm,d.deptno,d.dname from emp as e left outer join dept as d on e.deptno=d.deptno;+-------+--------+-----------+---------+---------+--------+------------+| empno | ename | job | sal | comm | deptno | dname |+-------+--------+-----------+---------+---------+--------+------------+| 7782 | CLARK | MANAGER | 2450.00 | NULL | 10 | ACCOUNTING || 7839 | KING | PRESIDENT | 5000.00 | NULL | 10 | ACCOUNTING || 7934 | MILLER | CLERK | 1300.00 | NULL | 10 | ACCOUNTING || 7369 | SMITH | CLERK | 800.00 | NULL | 20 | RESEARCH || 7566 | JONES | MANAGER | 2975.00 | NULL | 20 | RESEARCH || 7788 | SCOTT | ANALYST | 3000.00 | NULL | 20 | RESEARCH || 7876 | ADAMS | CLERK | 1100.00 | NULL | 20 | RESEARCH || 7902 | FORD | ANALYST | 3000.00 | NULL | 20 | RESEARCH || 7499 | ALLEN | SALESMAN | 1600.00 | 300.00 | 30 | SALES || 7521 | WARD | SALESMAN | 1250.00 | 500.00 | 30 | SALES || 7654 | MARTIN | SALESMAN | 1250.00 | 1400.00 | 30 | SALES || 7698 | BLAKE | MANAGER | 2850.00 | NULL | 30 | SALES || 7844 | TURNER | SALESMAN | 1500.00 | 0.00 | 30 | SALES || 7900 | JAMES | CLERK | 950.00 | NULL | 30 | SALES |+-------+--------+-----------+---------+---------+--------+------------+14 rows in set (0.00 sec)mysql&gt; 左外自然以emp表和dept表为例：查询所有员工的工号、姓名、工作、月薪、奖金、部门编号，以及部门名称、所在城市。显然，这些信息一部分在emp表中，一部分在dept表中，所以必须对两张表进行连接查询，才能得到所有信息。 语法：select * from 表1 别名1 natural left outer join 表2 别名2;演示：select * from emp e natural left outer join dept d; 12345678910111213141516171819202122mysql&gt; select * from emp e natural left outer join dept d;+--------+-------+--------+-----------+------+---------------------+---------+---------+------------+----------+| deptno | empno | ename | job | mgr | hiredate | sal | comm | dname | loc |+--------+-------+--------+-----------+------+---------------------+---------+---------+------------+----------+| 10 | 7782 | CLARK | MANAGER | 7839 | 1981-06-09 00:00:00 | 2450.00 | NULL | ACCOUNTING | NEW YORK || 10 | 7839 | KING | PRESIDENT | NULL | 1981-11-17 00:00:00 | 5000.00 | NULL | ACCOUNTING | NEW YORK || 10 | 7934 | MILLER | CLERK | 7782 | 1982-01-23 00:00:00 | 1300.00 | NULL | ACCOUNTING | NEW YORK || 20 | 7369 | SMITH | CLERK | 7902 | 1980-12-17 00:00:00 | 800.00 | NULL | RESEARCH | DALLAS || 20 | 7566 | JONES | MANAGER | 7839 | 1981-04-02 00:00:00 | 2975.00 | NULL | RESEARCH | DALLAS || 20 | 7788 | SCOTT | ANALYST | 7566 | 1982-12-09 00:00:00 | 3000.00 | NULL | RESEARCH | DALLAS || 20 | 7876 | ADAMS | CLERK | 7788 | 1983-01-12 00:00:00 | 1100.00 | NULL | RESEARCH | DALLAS || 20 | 7902 | FORD | ANALYST | 7566 | 1981-12-03 00:00:00 | 3000.00 | NULL | RESEARCH | DALLAS || 30 | 7499 | ALLEN | SALESMAN | 7698 | 1981-02-20 00:00:00 | 1600.00 | 300.00 | SALES | CHICAGO || 30 | 7521 | WARD | SALESMAN | 7698 | 1981-02-22 00:00:00 | 1250.00 | 500.00 | SALES | CHICAGO || 30 | 7654 | MARTIN | SALESMAN | 7698 | 1981-09-28 00:00:00 | 1250.00 | 1400.00 | SALES | CHICAGO || 30 | 7698 | BLAKE | MANAGER | 7839 | 1981-05-01 00:00:00 | 2850.00 | NULL | SALES | CHICAGO || 30 | 7844 | TURNER | SALESMAN | 7698 | 1981-09-08 00:00:00 | 1500.00 | 0.00 | SALES | CHICAGO || 30 | 7900 | JAMES | CLERK | 7698 | 1981-12-03 00:00:00 | 950.00 | NULL | SALES | CHICAGO |+--------+-------+--------+-----------+------+---------------------+---------+---------+------------+----------+14 rows in set (0.00 sec)mysql&gt; 可见，左外自然连接查询，两张表的重复字段会被放到查询结果的第一列，其余的不变。 右外连接右表记录无论是否满足条件都会查询出来，而左表只有满足条件才能查询出来。右表中不满足条件的记录，左表部分都为null。 语法：select * from 表1 别名1 right outer join 表2 别名2 on 别名1.xx=别名2.xx;演示：select empno,ename,job,mgr,sal,comm,e.deptno,dname,loc from emp e right outer join dept d on e.deptno=d.deptno;或者：select empno,ename,job,mgr,sal,comm,d.deptno,dname,loc from emp e right outer join dept d on e.deptno=d.deptno;或者：select empno,ename,job,mgr,sal,comm,emp.deptno,dname,loc from emp right outer join dept on emp.deptno=dept.deptno;或者：select empno,ename,job,mgr,sal,comm,d.deptno,d.dname,d.loc from emp e right outer join dept d on e.deptno=d.deptno;两张表中都有的字段，必须要写成表名.字段名或者别名.字段名，否则会报错。比如deptno字段，两张表中都有，所以必须要写成d.deptno或者e.deptno。 1234567891011121314151617181920212223mysql&gt; select empno,ename,job,mgr,sal,comm,e.deptno,dname,loc from emp e right outer join dept d on e.deptno=d.deptno;+-------+--------+-----------+------+---------+---------+--------+------------+----------+| empno | ename | job | mgr | sal | comm | deptno | dname | loc |+-------+--------+-----------+------+---------+---------+--------+------------+----------+| 7369 | SMITH | CLERK | 7902 | 800.00 | NULL | 20 | RESEARCH | DALLAS || 7499 | ALLEN | SALESMAN | 7698 | 1600.00 | 300.00 | 30 | SALES | CHICAGO || 7521 | WARD | SALESMAN | 7698 | 1250.00 | 500.00 | 30 | SALES | CHICAGO || 7566 | JONES | MANAGER | 7839 | 2975.00 | NULL | 20 | RESEARCH | DALLAS || 7654 | MARTIN | SALESMAN | 7698 | 1250.00 | 1400.00 | 30 | SALES | CHICAGO || 7698 | BLAKE | MANAGER | 7839 | 2850.00 | NULL | 30 | SALES | CHICAGO || 7782 | CLARK | MANAGER | 7839 | 2450.00 | NULL | 10 | ACCOUNTING | NEW YORK || 7788 | SCOTT | ANALYST | 7566 | 3000.00 | NULL | 20 | RESEARCH | DALLAS || 7839 | KING | PRESIDENT | NULL | 5000.00 | NULL | 10 | ACCOUNTING | NEW YORK || 7844 | TURNER | SALESMAN | 7698 | 1500.00 | 0.00 | 30 | SALES | CHICAGO || 7876 | ADAMS | CLERK | 7788 | 1100.00 | NULL | 20 | RESEARCH | DALLAS || 7900 | JAMES | CLERK | 7698 | 950.00 | NULL | 30 | SALES | CHICAGO || 7902 | FORD | ANALYST | 7566 | 3000.00 | NULL | 20 | RESEARCH | DALLAS || 7934 | MILLER | CLERK | 7782 | 1300.00 | NULL | 10 | ACCOUNTING | NEW YORK || NULL | NULL | NULL | NULL | NULL | NULL | NULL | OPERATIONS | BOSTON |+-------+--------+-----------+------+---------+---------+--------+------------+----------+15 rows in set (0.00 sec)mysql&gt; 右外自然语法：select * from 表1 别名1 natural right outer join 表2 别名2;演示：select * from emp natural right outer join dept; 1234567891011121314151617181920212223mysql&gt; select * from emp natural right outer join dept;+--------+------------+----------+-------+--------+-----------+------+---------------------+---------+---------+| deptno | dname | loc | empno | ename | job | mgr | hiredate | sal | comm |+--------+------------+----------+-------+--------+-----------+------+---------------------+---------+---------+| 20 | RESEARCH | DALLAS | 7369 | SMITH | CLERK | 7902 | 1980-12-17 00:00:00 | 800.00 | NULL || 30 | SALES | CHICAGO | 7499 | ALLEN | SALESMAN | 7698 | 1981-02-20 00:00:00 | 1600.00 | 300.00 || 30 | SALES | CHICAGO | 7521 | WARD | SALESMAN | 7698 | 1981-02-22 00:00:00 | 1250.00 | 500.00 || 20 | RESEARCH | DALLAS | 7566 | JONES | MANAGER | 7839 | 1981-04-02 00:00:00 | 2975.00 | NULL || 30 | SALES | CHICAGO | 7654 | MARTIN | SALESMAN | 7698 | 1981-09-28 00:00:00 | 1250.00 | 1400.00 || 30 | SALES | CHICAGO | 7698 | BLAKE | MANAGER | 7839 | 1981-05-01 00:00:00 | 2850.00 | NULL || 10 | ACCOUNTING | NEW YORK | 7782 | CLARK | MANAGER | 7839 | 1981-06-09 00:00:00 | 2450.00 | NULL || 20 | RESEARCH | DALLAS | 7788 | SCOTT | ANALYST | 7566 | 1982-12-09 00:00:00 | 3000.00 | NULL || 10 | ACCOUNTING | NEW YORK | 7839 | KING | PRESIDENT | NULL | 1981-11-17 00:00:00 | 5000.00 | NULL || 30 | SALES | CHICAGO | 7844 | TURNER | SALESMAN | 7698 | 1981-09-08 00:00:00 | 1500.00 | 0.00 || 20 | RESEARCH | DALLAS | 7876 | ADAMS | CLERK | 7788 | 1983-01-12 00:00:00 | 1100.00 | NULL || 30 | SALES | CHICAGO | 7900 | JAMES | CLERK | 7698 | 1981-12-03 00:00:00 | 950.00 | NULL || 20 | RESEARCH | DALLAS | 7902 | FORD | ANALYST | 7566 | 1981-12-03 00:00:00 | 3000.00 | NULL || 10 | ACCOUNTING | NEW YORK | 7934 | MILLER | CLERK | 7782 | 1982-01-23 00:00:00 | 1300.00 | NULL || 40 | OPERATIONS | BOSTON | NULL | NULL | NULL | NULL | NULL | NULL | NULL |+--------+------------+----------+-------+--------+-----------+------+---------------------+---------+---------+15 rows in set (0.00 sec)mysql&gt; 演示：select empno,ename,job,sal,comm,e.deptno,dname,loc from emp e natural right outer join dept d; 1234567891011121314151617181920212223mysql&gt; select empno,ename,job,sal,comm,e.deptno,dname,loc from emp e natural right outer join dept d;+-------+--------+-----------+---------+---------+--------+------------+----------+| empno | ename | job | sal | comm | deptno | dname | loc |+-------+--------+-----------+---------+---------+--------+------------+----------+| 7369 | SMITH | CLERK | 800.00 | NULL | 20 | RESEARCH | DALLAS || 7499 | ALLEN | SALESMAN | 1600.00 | 300.00 | 30 | SALES | CHICAGO || 7521 | WARD | SALESMAN | 1250.00 | 500.00 | 30 | SALES | CHICAGO || 7566 | JONES | MANAGER | 2975.00 | NULL | 20 | RESEARCH | DALLAS || 7654 | MARTIN | SALESMAN | 1250.00 | 1400.00 | 30 | SALES | CHICAGO || 7698 | BLAKE | MANAGER | 2850.00 | NULL | 30 | SALES | CHICAGO || 7782 | CLARK | MANAGER | 2450.00 | NULL | 10 | ACCOUNTING | NEW YORK || 7788 | SCOTT | ANALYST | 3000.00 | NULL | 20 | RESEARCH | DALLAS || 7839 | KING | PRESIDENT | 5000.00 | NULL | 10 | ACCOUNTING | NEW YORK || 7844 | TURNER | SALESMAN | 1500.00 | 0.00 | 30 | SALES | CHICAGO || 7876 | ADAMS | CLERK | 1100.00 | NULL | 20 | RESEARCH | DALLAS || 7900 | JAMES | CLERK | 950.00 | NULL | 30 | SALES | CHICAGO || 7902 | FORD | ANALYST | 3000.00 | NULL | 20 | RESEARCH | DALLAS || 7934 | MILLER | CLERK | 1300.00 | NULL | 10 | ACCOUNTING | NEW YORK || NULL | NULL | NULL | NULL | NULL | NULL | OPERATIONS | BOSTON |+-------+--------+-----------+---------+---------+--------+------------+----------+15 rows in set (0.00 sec)mysql&gt; 自连接自连接就是一张表连接自己 语法：select 别名1.字段1,别名1.字段2,别名1.字段3,别名2.字段a,别名2.字段b from 表名 as 别名1 left outer join 表名 as 别名2 on 别名1.某字段=别名2.某字段; 从emp表中查询所有员工的编号，姓名，上级领导，及其上级领导的编号和姓名演示：select e.empno,e.ename,e.mgr,m.empno,m.ename from emp as e left outer join emp as m on e.mgr=m.empno;这里的两个as都可以省略 12345678910111213141516171819202122mysql&gt; select e.empno,e.ename,e.mgr,m.empno,m.ename from emp as e left outer join emp as m on e.mgr=m.empno;+-------+--------+------+-------+-------+| empno | ename | mgr | empno | ename |+-------+--------+------+-------+-------+| 7788 | SCOTT | 7566 | 7566 | JONES || 7902 | FORD | 7566 | 7566 | JONES || 7499 | ALLEN | 7698 | 7698 | BLAKE || 7521 | WARD | 7698 | 7698 | BLAKE || 7654 | MARTIN | 7698 | 7698 | BLAKE || 7844 | TURNER | 7698 | 7698 | BLAKE || 7900 | JAMES | 7698 | 7698 | BLAKE || 7934 | MILLER | 7782 | 7782 | CLARK || 7876 | ADAMS | 7788 | 7788 | SCOTT || 7566 | JONES | 7839 | 7839 | KING || 7698 | BLAKE | 7839 | 7839 | KING || 7782 | CLARK | 7839 | 7839 | KING || 7369 | SMITH | 7902 | 7902 | FORD || 7839 | KING | NULL | NULL | NULL |+-------+--------+------+-------+-------+14 rows in set (0.00 sec)mysql&gt; 子查询子查询是指sql语句中包含另一个select语句 一条sql语句中，包含多个select关键字外查询，内查询 子查询可以出现的位置：from后面，作为表where后面，作为条件 注意事项：1、子查询必须在()里；2、在子查询中不能使用order by子句。3、子查询可以再嵌套子查询，最多不超过255层。 子查询还分为：单行子查询，多行子查询，关联子查询。 例如：查询工资至少比20部门一个员工高的员工信息 123456789101112131415161718192021mysql&gt; select * from emp where sal &gt; any(select sal from emp where deptno=20);+-------+--------+-----------+------+---------------------+---------+---------+--------+| empno | ename | job | mgr | hiredate | sal | comm | deptno |+-------+--------+-----------+------+---------------------+---------+---------+--------+| 7499 | ALLEN | SALESMAN | 7698 | 1981-02-20 00:00:00 | 1600.00 | 300.00 | 30 || 7521 | WARD | SALESMAN | 7698 | 1981-02-22 00:00:00 | 1250.00 | 500.00 | 30 || 7566 | JONES | MANAGER | 7839 | 1981-04-02 00:00:00 | 2975.00 | NULL | 20 || 7654 | MARTIN | SALESMAN | 7698 | 1981-09-28 00:00:00 | 1250.00 | 1400.00 | 30 || 7698 | BLAKE | MANAGER | 7839 | 1981-05-01 00:00:00 | 2850.00 | NULL | 30 || 7782 | CLARK | MANAGER | 7839 | 1981-06-09 00:00:00 | 2450.00 | NULL | 10 || 7788 | SCOTT | ANALYST | 7566 | 1982-12-09 00:00:00 | 3000.00 | NULL | 20 || 7839 | KING | PRESIDENT | NULL | 1981-11-17 00:00:00 | 5000.00 | NULL | 10 || 7844 | TURNER | SALESMAN | 7698 | 1981-09-08 00:00:00 | 1500.00 | 0.00 | 30 || 7876 | ADAMS | CLERK | 7788 | 1983-01-12 00:00:00 | 1100.00 | NULL | 20 || 7900 | JAMES | CLERK | 7698 | 1981-12-03 00:00:00 | 950.00 | NULL | 30 || 7902 | FORD | ANALYST | 7566 | 1981-12-03 00:00:00 | 3000.00 | NULL | 20 || 7934 | MILLER | CLERK | 7782 | 1982-01-23 00:00:00 | 1300.00 | NULL | 10 |+-------+--------+-----------+------+---------------------+---------+---------+--------+13 rows in set (0.00 sec)mysql&gt; 查询工资比20部门所有员工都高的员工信息 123456789mysql&gt; select * from emp where sal &gt; all(select sal from emp where deptno=20);+-------+-------+-----------+------+---------------------+---------+------+--------+| empno | ename | job | mgr | hiredate | sal | comm | deptno |+-------+-------+-----------+------+---------------------+---------+------+--------+| 7839 | KING | PRESIDENT | NULL | 1981-11-17 00:00:00 | 5000.00 | NULL | 10 |+-------+-------+-----------+------+---------------------+---------+------+--------+1 row in set (0.00 sec)mysql&gt; 查询不是领导的员工信息 12345678910111213141516mysql&gt; select * from emp where empno not in(select ifnull(mgr,0) from emp);+-------+--------+----------+------+---------------------+---------+---------+--------+| empno | ename | job | mgr | hiredate | sal | comm | deptno |+-------+--------+----------+------+---------------------+---------+---------+--------+| 7369 | SMITH | CLERK | 7902 | 1980-12-17 00:00:00 | 800.00 | NULL | 20 || 7499 | ALLEN | SALESMAN | 7698 | 1981-02-20 00:00:00 | 1600.00 | 300.00 | 30 || 7521 | WARD | SALESMAN | 7698 | 1981-02-22 00:00:00 | 1250.00 | 500.00 | 30 || 7654 | MARTIN | SALESMAN | 7698 | 1981-09-28 00:00:00 | 1250.00 | 1400.00 | 30 || 7844 | TURNER | SALESMAN | 7698 | 1981-09-08 00:00:00 | 1500.00 | 0.00 | 30 || 7876 | ADAMS | CLERK | 7788 | 1983-01-12 00:00:00 | 1100.00 | NULL | 20 || 7900 | JAMES | CLERK | 7698 | 1981-12-03 00:00:00 | 950.00 | NULL | 30 || 7934 | MILLER | CLERK | 7782 | 1982-01-23 00:00:00 | 1300.00 | NULL | 10 |+-------+--------+----------+------+---------------------+---------+---------+--------+8 rows in set (0.00 sec)mysql&gt; 窗口函数MySQL8.0新增了窗口函数，over()，row_number()，rank(),dense_rank()函数，以前都是Oracle特有的功能，这里分别看看怎么用 over()不能单独使用，要和rank()，dense_rank()，row_number()等函数一起使用 这几个函数都是用来排名和编号，区别在于，rank()的排名会跳号，比如有两个人成绩相同，并列第一名，那么两个第一名之后，紧接着是第三名，而没有第二名，而dense_rank()则是两个第一名之后，紧接着是第二名，这里来查询一下演示：select rank() over(partition by mgr order by sal desc) as sal_no,empno,ename,job,mgr,deptno from emp;这里解释下over()函数，over(partition by columnname1 order by columnname2)含义：按字段columnname1进行分组，按字段column2进行排名，具体到本例的意思就是，以上级领导的编号进行分组，在每组内以工资进行排名。即把每个部门的员工按工资进行排名 12345678910111213141516171819202122mysql&gt; select rank() over(partition by mgr order by sal desc) as sal_no,empno,ename,job,mgr,sal,deptno from emp; +--------+-------+--------+-----------+------+---------+--------+| sal_no | empno | ename | job | mgr | sal | deptno |+--------+-------+--------+-----------+------+---------+--------+| 1 | 7839 | KING | PRESIDENT | NULL | 5000.00 | 10 || 1 | 7788 | SCOTT | ANALYST | 7566 | 3000.00 | 20 || 1 | 7902 | FORD | ANALYST | 7566 | 3000.00 | 20 || 1 | 7499 | ALLEN | SALESMAN | 7698 | 1600.00 | 30 || 2 | 7844 | TURNER | SALESMAN | 7698 | 1500.00 | 30 || 3 | 7521 | WARD | SALESMAN | 7698 | 1250.00 | 30 || 3 | 7654 | MARTIN | SALESMAN | 7698 | 1250.00 | 30 || 5 | 7900 | JAMES | CLERK | 7698 | 950.00 | 30 || 1 | 7934 | MILLER | CLERK | 7782 | 1300.00 | 10 || 1 | 7876 | ADAMS | CLERK | 7788 | 1100.00 | 20 || 1 | 7566 | JONES | MANAGER | 7839 | 2975.00 | 20 || 2 | 7698 | BLAKE | MANAGER | 7839 | 2850.00 | 30 || 3 | 7782 | CLARK | MANAGER | 7839 | 2450.00 | 10 || 1 | 7369 | SMITH | CLERK | 7902 | 800.00 | 20 |+--------+-------+--------+-----------+------+---------+--------+14 rows in set (0.00 sec)mysql&gt; 用dense_rank()函数排名 12345678910111213141516171819202122mysql&gt; select dense_rank() over(partition by mgr order by sal desc) as sal_no,empno,ename,job,mgr,sal,deptno from emp;+--------+-------+--------+-----------+------+---------+--------+| sal_no | empno | ename | job | mgr | sal | deptno |+--------+-------+--------+-----------+------+---------+--------+| 1 | 7839 | KING | PRESIDENT | NULL | 5000.00 | 10 || 1 | 7788 | SCOTT | ANALYST | 7566 | 3000.00 | 20 || 1 | 7902 | FORD | ANALYST | 7566 | 3000.00 | 20 || 1 | 7499 | ALLEN | SALESMAN | 7698 | 1600.00 | 30 || 2 | 7844 | TURNER | SALESMAN | 7698 | 1500.00 | 30 || 3 | 7521 | WARD | SALESMAN | 7698 | 1250.00 | 30 || 3 | 7654 | MARTIN | SALESMAN | 7698 | 1250.00 | 30 || 4 | 7900 | JAMES | CLERK | 7698 | 950.00 | 30 || 1 | 7934 | MILLER | CLERK | 7782 | 1300.00 | 10 || 1 | 7876 | ADAMS | CLERK | 7788 | 1100.00 | 20 || 1 | 7566 | JONES | MANAGER | 7839 | 2975.00 | 20 || 2 | 7698 | BLAKE | MANAGER | 7839 | 2850.00 | 30 || 3 | 7782 | CLARK | MANAGER | 7839 | 2450.00 | 10 || 1 | 7369 | SMITH | CLERK | 7902 | 800.00 | 20 |+--------+-------+--------+-----------+------+---------+--------+14 rows in set (0.00 sec)mysql&gt; 对比两次查询结果发现，使用rank()函数的时候，第三组7698中六个员工的排名是1、2、3、3、5，而使用dense_rank()函数的时候，六个人排名变成了1、2、3、3、4 接下来再看看row_number()函数，其作用是为每一条记录编号，并且编号不重复，演示：select row_number() over(partition by mgr order by sal) as sal_no,empno,ename,job,mgr,deptno from emp;这里的意思是，以上级领导进行分组，以工资进行排序，并按顺序编号，工资相同的，以其他字段排名。 12345678910111213141516171819202122mysql&gt; select row_number() over(partition by mgr order by sal desc) as sal_no,empno,ename,job,mgr,sal,deptno from emp;+--------+-------+--------+-----------+------+---------+--------+| sal_no | empno | ename | job | mgr | sal | deptno |+--------+-------+--------+-----------+------+---------+--------+| 1 | 7839 | KING | PRESIDENT | NULL | 5000.00 | 10 || 1 | 7788 | SCOTT | ANALYST | 7566 | 3000.00 | 20 || 2 | 7902 | FORD | ANALYST | 7566 | 3000.00 | 20 || 1 | 7499 | ALLEN | SALESMAN | 7698 | 1600.00 | 30 || 2 | 7844 | TURNER | SALESMAN | 7698 | 1500.00 | 30 || 3 | 7521 | WARD | SALESMAN | 7698 | 1250.00 | 30 || 4 | 7654 | MARTIN | SALESMAN | 7698 | 1250.00 | 30 || 5 | 7900 | JAMES | CLERK | 7698 | 950.00 | 30 || 1 | 7934 | MILLER | CLERK | 7782 | 1300.00 | 10 || 1 | 7876 | ADAMS | CLERK | 7788 | 1100.00 | 20 || 1 | 7566 | JONES | MANAGER | 7839 | 2975.00 | 20 || 2 | 7698 | BLAKE | MANAGER | 7839 | 2850.00 | 30 || 3 | 7782 | CLARK | MANAGER | 7839 | 2450.00 | 10 || 1 | 7369 | SMITH | CLERK | 7902 | 800.00 | 20 |+--------+-------+--------+-----------+------+---------+--------+14 rows in set (0.00 sec)mysql&gt; 以部门分组，并以工资高低排序 12345678910111213141516171819202122mysql&gt; select rank() over(partition by deptno order by sal) as sal_no,empno,ename,job,mgr,sal,deptno from emp;+--------+-------+--------+-----------+------+---------+--------+| sal_no | empno | ename | job | mgr | sal | deptno |+--------+-------+--------+-----------+------+---------+--------+| 1 | 7934 | MILLER | CLERK | 7782 | 1300.00 | 10 || 2 | 7782 | CLARK | MANAGER | 7839 | 2450.00 | 10 || 3 | 7839 | KING | PRESIDENT | NULL | 5000.00 | 10 || 1 | 7369 | SMITH | CLERK | 7902 | 800.00 | 20 || 2 | 7876 | ADAMS | CLERK | 7788 | 1100.00 | 20 || 3 | 7566 | JONES | MANAGER | 7839 | 2975.00 | 20 || 4 | 7788 | SCOTT | ANALYST | 7566 | 3000.00 | 20 || 4 | 7902 | FORD | ANALYST | 7566 | 3000.00 | 20 || 1 | 7900 | JAMES | CLERK | 7698 | 950.00 | 30 || 2 | 7521 | WARD | SALESMAN | 7698 | 1250.00 | 30 || 2 | 7654 | MARTIN | SALESMAN | 7698 | 1250.00 | 30 || 4 | 7844 | TURNER | SALESMAN | 7698 | 1500.00 | 30 || 5 | 7499 | ALLEN | SALESMAN | 7698 | 1600.00 | 30 || 6 | 7698 | BLAKE | MANAGER | 7839 | 2850.00 | 30 |+--------+-------+--------+-----------+------+---------+--------+14 rows in set (0.00 sec)mysql&gt; 按部门分组，并以工资高低按顺序编号 12345678910111213141516171819202122mysql&gt; select row_number() over(partition by deptno order by sal desc) as dept_no,empno,ename,job,mgr,sal,deptno from emp;+---------+-------+--------+-----------+------+---------+--------+| dept_no | empno | ename | job | mgr | sal | deptno |+---------+-------+--------+-----------+------+---------+--------+| 1 | 7839 | KING | PRESIDENT | NULL | 5000.00 | 10 || 2 | 7782 | CLARK | MANAGER | 7839 | 2450.00 | 10 || 3 | 7934 | MILLER | CLERK | 7782 | 1300.00 | 10 || 1 | 7788 | SCOTT | ANALYST | 7566 | 3000.00 | 20 || 2 | 7902 | FORD | ANALYST | 7566 | 3000.00 | 20 || 3 | 7566 | JONES | MANAGER | 7839 | 2975.00 | 20 || 4 | 7876 | ADAMS | CLERK | 7788 | 1100.00 | 20 || 5 | 7369 | SMITH | CLERK | 7902 | 800.00 | 20 || 1 | 7698 | BLAKE | MANAGER | 7839 | 2850.00 | 30 || 2 | 7499 | ALLEN | SALESMAN | 7698 | 1600.00 | 30 || 3 | 7844 | TURNER | SALESMAN | 7698 | 1500.00 | 30 || 4 | 7521 | WARD | SALESMAN | 7698 | 1250.00 | 30 || 5 | 7654 | MARTIN | SALESMAN | 7698 | 1250.00 | 30 || 6 | 7900 | JAMES | CLERK | 7698 | 950.00 | 30 |+---------+-------+--------+-----------+------+---------+--------+14 rows in set (0.00 sec)mysql&gt; 找出每个部门工资最高的员工 123456789101112131415161718192021222324252627282930313233mysql&gt; select dense_rank() over(partition by deptno order by sal desc) as dept_no,empno,ename,job,mgr,sal,deptno from emp;+---------+-------+--------+-----------+------+---------+--------+| dept_no | empno | ename | job | mgr | sal | deptno |+---------+-------+--------+-----------+------+---------+--------+| 1 | 7839 | KING | PRESIDENT | NULL | 5000.00 | 10 || 2 | 7782 | CLARK | MANAGER | 7839 | 2450.00 | 10 || 3 | 7934 | MILLER | CLERK | 7782 | 1300.00 | 10 || 1 | 7788 | SCOTT | ANALYST | 7566 | 3000.00 | 20 || 1 | 7902 | FORD | ANALYST | 7566 | 3000.00 | 20 || 2 | 7566 | JONES | MANAGER | 7839 | 2975.00 | 20 || 3 | 7876 | ADAMS | CLERK | 7788 | 1100.00 | 20 || 4 | 7369 | SMITH | CLERK | 7902 | 800.00 | 20 || 1 | 7698 | BLAKE | MANAGER | 7839 | 2850.00 | 30 || 2 | 7499 | ALLEN | SALESMAN | 7698 | 1600.00 | 30 || 3 | 7844 | TURNER | SALESMAN | 7698 | 1500.00 | 30 || 4 | 7521 | WARD | SALESMAN | 7698 | 1250.00 | 30 || 4 | 7654 | MARTIN | SALESMAN | 7698 | 1250.00 | 30 || 5 | 7900 | JAMES | CLERK | 7698 | 950.00 | 30 |+---------+-------+--------+-----------+------+---------+--------+14 rows in set (0.00 sec)mysql&gt; select * from ( select dense_rank() over(partition by deptno order by sal desc) as dept_no,empno,ename,job,mgr,sal,deptno from emp ) as t where dept_no=1;+---------+-------+-------+-----------+------+---------+--------+| dept_no | empno | ename | job | mgr | sal | deptno |+---------+-------+-------+-----------+------+---------+--------+| 1 | 7839 | KING | PRESIDENT | NULL | 5000.00 | 10 || 1 | 7788 | SCOTT | ANALYST | 7566 | 3000.00 | 20 || 1 | 7902 | FORD | ANALYST | 7566 | 3000.00 | 20 || 1 | 7698 | BLAKE | MANAGER | 7839 | 2850.00 | 30 |+---------+-------+-------+-----------+------+---------+--------+4 rows in set (0.01 sec)mysql&gt; 综合运用窗口函数、嵌套查询、外连接的综合运用 将所有员工以其工资从高到底在部门内排序，查询所有员工的详细信息，包括部门编号、部门名称、和部门所在地演示：select * from (select rank() over(partition by deptno order by sal desc) as sal_no,empno,ename,job,mgr,comm,sal,deptno from emp ) as t left outer join dept d on t.deptno=d.deptno; 1234567891011121314151617181920mysql&gt; select * from (select rank() over(partition by deptno order by sal desc) as sal_no,empno,ename,job,mgr,comm,sal,deptno from emp ) as t left outer join dept d on t.deptno=d.deptno;+--------+-------+--------+-----------+------+---------+---------+--------+--------+------------+----------+| sal_no | empno | ename | job | mgr | comm | sal | deptno | deptno | dname | loc |+--------+-------+--------+-----------+------+---------+---------+--------+--------+------------+----------+| 1 | 7839 | KING | PRESIDENT | NULL | NULL | 5000.00 | 10 | 10 | ACCOUNTING | NEW YORK || 2 | 7782 | CLARK | MANAGER | 7839 | NULL | 2450.00 | 10 | 10 | ACCOUNTING | NEW YORK || 3 | 7934 | MILLER | CLERK | 7782 | NULL | 1300.00 | 10 | 10 | ACCOUNTING | NEW YORK || 1 | 7788 | SCOTT | ANALYST | 7566 | NULL | 3000.00 | 20 | 20 | RESEARCH | DALLAS || 1 | 7902 | FORD | ANALYST | 7566 | NULL | 3000.00 | 20 | 20 | RESEARCH | DALLAS || 3 | 7566 | JONES | MANAGER | 7839 | NULL | 2975.00 | 20 | 20 | RESEARCH | DALLAS || 4 | 7876 | ADAMS | CLERK | 7788 | NULL | 1100.00 | 20 | 20 | RESEARCH | DALLAS || 5 | 7369 | SMITH | CLERK | 7902 | NULL | 800.00 | 20 | 20 | RESEARCH | DALLAS || 1 | 7698 | BLAKE | MANAGER | 7839 | NULL | 2850.00 | 30 | 30 | SALES | CHICAGO || 2 | 7499 | ALLEN | SALESMAN | 7698 | 300.00 | 1600.00 | 30 | 30 | SALES | CHICAGO || 3 | 7844 | TURNER | SALESMAN | 7698 | 0.00 | 1500.00 | 30 | 30 | SALES | CHICAGO || 4 | 7521 | WARD | SALESMAN | 7698 | 500.00 | 1250.00 | 30 | 30 | SALES | CHICAGO || 4 | 7654 | MARTIN | SALESMAN | 7698 | 1400.00 | 1250.00 | 30 | 30 | SALES | CHICAGO || 6 | 7900 | JAMES | CLERK | 7698 | NULL | 950.00 | 30 | 30 | SALES | CHICAGO |+--------+-------+--------+-----------+------+---------+---------+--------+--------+------------+----------+14 rows in set (0.00 sec) 查询每个部门工资最高的员工的详细信息，包括其部门编号、部门名称和部门所在地演示：select * from (select rank() over(partition by deptno order by sal desc) as sal_no,empno,ename,job,mgr,comm,sal,deptno from emp ) as t natural left outer join dept d where sal_no=1; 123456789101112mysql&gt; select * from (select rank() over(partition by deptno order by sal desc) as sal_no,empno,ename,job,mgr,comm,sal,deptno from emp ) as t natural left outer join dept d where sal_no=1;+--------+--------+-------+-------+-----------+------+------+---------+------------+----------+| deptno | sal_no | empno | ename | job | mgr | comm | sal | dname | loc |+--------+--------+-------+-------+-----------+------+------+---------+------------+----------+| 10 | 1 | 7839 | KING | PRESIDENT | NULL | NULL | 5000.00 | ACCOUNTING | NEW YORK || 20 | 1 | 7788 | SCOTT | ANALYST | 7566 | NULL | 3000.00 | RESEARCH | DALLAS || 20 | 1 | 7902 | FORD | ANALYST | 7566 | NULL | 3000.00 | RESEARCH | DALLAS || 30 | 1 | 7698 | BLAKE | MANAGER | 7839 | NULL | 2850.00 | SALES | CHICAGO |+--------+--------+-------+-------+-----------+------+------+---------+------------+----------+4 rows in set (0.00 sec)mysql&gt; 本节就到这里，MySQL8.0还新增了很多功能，下一节继续学习。 版权声明：博客中的文章版权归博主所有，未经授权，禁止转载，转载请注明出处，合作请点击“关于我”，扫码添加微信","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"MySQL数据库","slug":"MySQL数据库","permalink":"http://yoursite.com/tags/MySQL数据库/"}]},{"title":"MySQL8.0：查询数据--简单查询","slug":"MySQL8.0 简单查询","date":"2018-07-29T02:10:00.000Z","updated":"2018-09-01T08:09:19.981Z","comments":true,"path":"2018/07/29/MySQL8.0 简单查询/","link":"","permalink":"http://yoursite.com/2018/07/29/MySQL8.0 简单查询/","excerpt":"整理：房玉辉","text":"整理：房玉辉 博客：https://ElonJelinek.github.io首先创建三张表：第一张表emp：建表语句： 12345678910create table emp (empno numeric(4) not null,ename varchar(10),job varchar(9),mgr numeric(4),hiredate datetime,sal numeric(7, 2),comm numeric(7, 2),deptno numeric(2)); 演示： 12345678910111213mysql&gt; create table emp ( -&gt; empno numeric(4) not null, -&gt; ename varchar(10), -&gt; job varchar(9), -&gt; mgr numeric(4), -&gt; hiredate datetime, -&gt; sal numeric(7, 2), -&gt; comm numeric(7, 2), -&gt; deptno numeric(2) -&gt; );Query OK, 0 rows affected (0.06 sec)mysql&gt; emp表的结构： 12345678910111213141516mysql&gt; describe emp;+----------+--------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+--------------+------+-----+---------+-------+| empno | decimal(4,0) | NO | | NULL | || ename | varchar(10) | YES | | NULL | || job | varchar(9) | YES | | NULL | || mgr | decimal(4,0) | YES | | NULL | || hiredate | datetime | YES | | NULL | || sal | decimal(7,2) | YES | | NULL | || comm | decimal(7,2) | YES | | NULL | || deptno | decimal(2,0) | YES | | NULL | |+----------+--------------+------+-----+---------+-------+8 rows in set (0.00 sec)mysql&gt; 插入一些数据： 插入语句： 1234567891011121314insert into emp values (7369, 'SMITH', 'CLERK', 7902, '1980-12-17', 800, null, 20),(7499, 'ALLEN', 'SALESMAN', 7698, '1981-02-20', 1600, 300, 30),(7521, 'WARD', 'SALESMAN', 7698, '1981-02-22', 1250, 500, 30),(7566, 'JONES', 'MANAGER', 7839, '1981-04-02', 2975, null, 20),(7654, 'MARTIN', 'SALESMAN', 7698, '1981-09-28', 1250, 1400, 30),(7698, 'BLAKE', 'MANAGER', 7839, '1981-05-01', 2850, null, 30),(7782, 'CLARK', 'MANAGER', 7839, '1981-06-09', 2450, null, 10),(7788, 'SCOTT', 'ANALYST', 7566, '1982-12-09', 3000, null, 20),(7839, 'KING', 'PRESIDENT', null, '1981-11-17', 5000, null, 10),(7844, 'TURNER', 'SALESMAN', 7698, '1981-09-08', 1500, 0, 30),(7876, 'ADAMS', 'CLERK', 7788, '1983-01-12', 1100, null, 20),(7900, 'JAMES', 'CLERK', 7698, '1981-12-03', 950, null, 30),(7902, 'FORD', 'ANALYST', 7566, '1981-12-03', 3000, null, 20),(7934, 'MILLER', 'CLERK', 7782, '1982-01-23', 1300, null, 10); 演示： 123456789101112131415161718mysql&gt; insert into emp values (7369, 'SMITH', 'CLERK', 7902, '1980-12-17', 800, null, 20), -&gt; (7499, 'ALLEN', 'SALESMAN', 7698, '1981-02-20', 1600, 300, 30), -&gt; (7521, 'WARD', 'SALESMAN', 7698, '1981-02-22', 1250, 500, 30), -&gt; (7566, 'JONES', 'MANAGER', 7839, '1981-04-02', 2975, null, 20), -&gt; (7654, 'MARTIN', 'SALESMAN', 7698, '1981-09-28', 1250, 1400, 30), -&gt; (7698, 'BLAKE', 'MANAGER', 7839, '1981-05-01', 2850, null, 30), -&gt; (7782, 'CLARK', 'MANAGER', 7839, '1981-06-09', 2450, null, 10), -&gt; (7788, 'SCOTT', 'ANALYST', 7566, '1982-12-09', 3000, null, 20), -&gt; (7839, 'KING', 'PRESIDENT', null, '1981-11-17', 5000, null, 10), -&gt; (7844, 'TURNER', 'SALESMAN', 7698, '1981-09-08', 1500, 0, 30), -&gt; (7876, 'ADAMS', 'CLERK', 7788, '1983-01-12', 1100, null, 20), -&gt; (7900, 'JAMES', 'CLERK', 7698, '1981-12-03', 950, null, 30), -&gt; (7902, 'FORD', 'ANALYST', 7566, '1981-12-03', 3000, null, 20), -&gt; (7934, 'MILLER', 'CLERK', 7782, '1982-01-23', 1300, null, 10);Query OK, 14 rows affected (0.03 sec)Records: 14 Duplicates: 0 Warnings: 0mysql&gt; 第二张表dept：建表语句： 12345create table dept (deptno numeric(2),dname varchar(14),loc varchar(13)); 演示： 12345678mysql&gt; create table dept ( -&gt; deptno numeric(2), -&gt; dname varchar(14), -&gt; loc varchar(13) -&gt; );Query OK, 0 rows affected (0.09 sec)mysql&gt; dept表的结构： 1234567891011mysql&gt; describe dept;+--------+--------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+--------------+------+-----+---------+-------+| deptno | decimal(2,0) | YES | | NULL | || dname | varchar(14) | YES | | NULL | || loc | varchar(13) | YES | | NULL | |+--------+--------------+------+-----+---------+-------+3 rows in set (0.00 sec)mysql&gt; 插入数据： 1234insert into dept values (10, 'ACCOUNTING', 'NEW YORK'),(20, 'RESEARCH', 'DALLAS'),(30, 'SALES', 'CHICAGO'),(40, 'OPERATIONS', 'BOSTON'); 演示： 12345678mysql&gt; insert into dept values (10, 'ACCOUNTING', 'NEW YORK'), -&gt; (20, 'RESEARCH', 'DALLAS'), -&gt; (30, 'SALES', 'CHICAGO'), -&gt; (40, 'OPERATIONS', 'BOSTON');Query OK, 4 rows affected (0.17 sec)Records: 4 Duplicates: 0 Warnings: 0mysql&gt; 第三张表salgrade：建表语句： 12345create table salgrade (grade numeric,losal numeric,hisal numeric); 演示： 12345678mysql&gt; create table salgrade ( -&gt; grade numeric, -&gt; losal numeric, -&gt; hisal numeric -&gt; );Query OK, 0 rows affected (0.07 sec)mysql&gt; 插入数据： 12345insert into salgrade values (1, 700, 1200),(2, 1201, 1400),(3, 1401, 2000),(4, 2001, 3000),(5, 3001, 9999); 演示： 123456789mysql&gt; insert into salgrade values (1, 700, 1200), -&gt; (2, 1201, 1400), -&gt; (3, 1401, 2000), -&gt; (4, 2001, 3000), -&gt; (5, 3001, 9999);Query OK, 5 rows affected (0.07 sec)Records: 5 Duplicates: 0 Warnings: 0mysql&gt; 简单查询：查询所有字段：以表dept为例：语法：select * from 表名;演示：select * from dept; 123456789101112mysql&gt; select * from dept;+--------+------------+----------+| deptno | dname | loc |+--------+------------+----------+| 10 | ACCOUNTING | NEW YORK || 20 | RESEARCH | DALLAS || 30 | SALES | CHICAGO || 40 | OPERATIONS | BOSTON |+--------+------------+----------+4 rows in set (0.01 sec)mysql&gt; 查询指定列：以emp表为例：语法：select 列名,列名 from 表名;演示：select empno,ename,job from emp; 12345678910111213141516171819202122mysql&gt; select empno,ename,job from emp;+-------+--------+-----------+| empno | ename | job |+-------+--------+-----------+| 7369 | SMITH | CLERK || 7499 | ALLEN | SALESMAN || 7521 | WARD | SALESMAN || 7566 | JONES | MANAGER || 7654 | MARTIN | SALESMAN || 7698 | BLAKE | MANAGER || 7782 | CLARK | MANAGER || 7788 | SCOTT | ANALYST || 7839 | KING | PRESIDENT || 7844 | TURNER | SALESMAN || 7876 | ADAMS | CLERK || 7900 | JAMES | CLERK || 7902 | FORD | ANALYST || 7934 | MILLER | CLERK |+-------+--------+-----------+14 rows in set (0.00 sec)mysql&gt; 起别名：以emp表为例：语法：select 列名 as 别名,列名 as 别名,列名 as 别名 from 表名;演示：select empno as 工号,ename as 姓名,job as 工作 from emp; 12345678910111213141516171819202122mysql&gt; select empno as 工号,ename as 姓名,job as 工作 from emp;+--------+--------+-----------+| 工号 | 姓名 | 工作 |+--------+--------+-----------+| 7369 | SMITH | CLERK || 7499 | ALLEN | SALESMAN || 7521 | WARD | SALESMAN || 7566 | JONES | MANAGER || 7654 | MARTIN | SALESMAN || 7698 | BLAKE | MANAGER || 7782 | CLARK | MANAGER || 7788 | SCOTT | ANALYST || 7839 | KING | PRESIDENT || 7844 | TURNER | SALESMAN || 7876 | ADAMS | CLERK || 7900 | JAMES | CLERK || 7902 | FORD | ANALYST || 7934 | MILLER | CLERK |+--------+--------+-----------+14 rows in set (0.00 sec)mysql&gt; 列运算：在select语句中，对于number和date类型的值可以使用算术表达式加法：+减法：-乘法：*除法：/括号：() 如果某个字段有null值，那么计算后的结果也是null，可以用函数ifnull(a,b)，若a为null则取b，若a不为null则取a的值。 演示：select empno as 工号,ename as 姓名,job as 工作,sal*12+ifnull(comm,0) as 年薪 from emp; 12345678910111213141516171819202122mysql&gt; select empno as 工号,ename as 姓名,job as 工作,sal*12+ifnull(comm,0) as 年薪 from emp;+--------+--------+-----------+----------+| 工号 | 姓名 | 工作 | 年薪 |+--------+--------+-----------+----------+| 7369 | SMITH | CLERK | 9600.00 || 7499 | ALLEN | SALESMAN | 19500.00 || 7521 | WARD | SALESMAN | 15500.00 || 7566 | JONES | MANAGER | 35700.00 || 7654 | MARTIN | SALESMAN | 16400.00 || 7698 | BLAKE | MANAGER | 34200.00 || 7782 | CLARK | MANAGER | 29400.00 || 7788 | SCOTT | ANALYST | 36000.00 || 7839 | KING | PRESIDENT | 60000.00 || 7844 | TURNER | SALESMAN | 18000.00 || 7876 | ADAMS | CLERK | 13200.00 || 7900 | JAMES | CLERK | 11400.00 || 7902 | FORD | ANALYST | 36000.00 || 7934 | MILLER | CLERK | 15600.00 |+--------+--------+-----------+----------+14 rows in set (0.00 sec)mysql&gt; 字符串类型的连续运算：concat函数用来把搜索到的列和列进行拼接显示：语法：concat(&quot;字符串&quot;,字段1,&quot;字符串&quot;,字段2,...)演示：select concat(&quot;我是&quot;,ename,&quot;，我的年薪是&quot;,sal*12+ifnull(comm,0),&quot;欧元。&quot;) as 员工薪酬 from emp; 12345678910111213141516171819202122mysql&gt; select concat(\"我是\",ename,\"，我的年薪是\",sal*12+ifnull(comm,0),\"欧元。\") as 员工薪酬 from emp; +-------------------------------------------------+| 员工薪酬 |+-------------------------------------------------+| 我是SMITH，我的年薪是9600.00欧元。 || 我是ALLEN，我的年薪是19500.00欧元。 || 我是WARD，我的年薪是15500.00欧元。 || 我是JONES，我的年薪是35700.00欧元。 || 我是MARTIN，我的年薪是16400.00欧元。 || 我是BLAKE，我的年薪是34200.00欧元。 || 我是CLARK，我的年薪是29400.00欧元。 || 我是SCOTT，我的年薪是36000.00欧元。 || 我是KING，我的年薪是60000.00欧元。 || 我是TURNER，我的年薪是18000.00欧元。 || 我是ADAMS，我的年薪是13200.00欧元。 || 我是JAMES，我的年薪是11400.00欧元。 || 我是FORD，我的年薪是36000.00欧元。 || 我是MILLER，我的年薪是15600.00欧元。 |+-------------------------------------------------+14 rows in set (0.00 sec)mysql&gt; distinct去除重复项distinct的用法稍微复杂一点，这里分别演示一下：首先，在之前的students表中增加两条数据，以备接下来的查询， 12345678910111213141516171819202122232425262728293031mysql&gt; select * from students;+-----------+-----------+------+------+----------+----------+| StudentID | name | age | sex | username | password |+-----------+-----------+------+------+----------+----------+| 9556 | Lily | 21 | 女 | | 123456 || 9559 | 梅长苏 | 28 | 男 | | 123456 || 9560 | 穆霓凰 | 26 | 女 | | 123456 || 9561 | 飞流 | 17 | 男 | | 123456 |+-----------+-----------+------+------+----------+----------+4 rows in set (0.00 sec)mysql&gt; insert into students values (0,\"萧景琰\",28,\"男\",\"靖王\",123456);Query OK, 1 row affected (0.12 sec)mysql&gt; insert into students values (0,\"萧景琰\",28,\"男\",\"靖王\",123456);Query OK, 1 row affected (0.05 sec)mysql&gt; select * from students;+-----------+-----------+------+------+----------+----------+| StudentID | name | age | sex | username | password |+-----------+-----------+------+------+----------+----------+| 9556 | Lily | 21 | 女 | | 123456 || 9559 | 梅长苏 | 28 | 男 | | 123456 || 9560 | 穆霓凰 | 26 | 女 | | 123456 || 9561 | 飞流 | 17 | 男 | | 123456 || 9562 | 萧景琰 | 28 | 男 | 靖王 | 123456 || 9563 | 萧景琰 | 28 | 男 | 靖王 | 123456 |+-----------+-----------+------+------+----------+----------+6 rows in set (0.00 sec)mysql&gt; 现在students表中最后两条数据，除了第一个字段不一样外，其余字段都完全相同，接下来就看看distinct怎么用 首先，distinct必须放在要查询字段的前面，而不能跟在字段后面： 语法：select distinct 字段名 from 表名;distinct后面可跟多个字段， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364mysql&gt; select distinct name from students;+-----------+| name |+-----------+| Lily || 梅长苏 || 穆霓凰 || 飞流 || 萧景琰 |+-----------+5 rows in set (0.00 sec)mysql&gt; select distinct StudentID,name from students;+-----------+-----------+| StudentID | name |+-----------+-----------+| 9556 | Lily || 9559 | 梅长苏 || 9560 | 穆霓凰 || 9561 | 飞流 || 9562 | 萧景琰 || 9563 | 萧景琰 |+-----------+-----------+6 rows in set (0.00 sec)mysql&gt; select distinct StudentID,name,age from students;+-----------+-----------+------+| StudentID | name | age |+-----------+-----------+------+| 9556 | Lily | 21 || 9559 | 梅长苏 | 28 || 9560 | 穆霓凰 | 26 || 9561 | 飞流 | 17 || 9562 | 萧景琰 | 28 || 9563 | 萧景琰 | 28 |+-----------+-----------+------+6 rows in set (0.00 sec)mysql&gt; select distinct name,age,sex from students;+-----------+------+------+| name | age | sex |+-----------+------+------+| Lily | 21 | 女 || 梅长苏 | 28 | 男 || 穆霓凰 | 26 | 女 || 飞流 | 17 | 男 || 萧景琰 | 28 | 男 |+-----------+------+------+5 rows in set (0.01 sec)mysql&gt; select distinct StudentID,name,age,sex from students;+-----------+-----------+------+------+| StudentID | name | age | sex |+-----------+-----------+------+------+| 9556 | Lily | 21 | 女 || 9559 | 梅长苏 | 28 | 男 || 9560 | 穆霓凰 | 26 | 女 || 9561 | 飞流 | 17 | 男 || 9562 | 萧景琰 | 28 | 男 || 9563 | 萧景琰 | 28 | 男 |+-----------+-----------+------+------+6 rows in set (0.00 sec)mysql&gt; 上面分别是distinct后面有一个字段、两个字段、三个字段和四个字段的情形，可见，如果distinct后面如果有多个字段的话，只有多个字段的内容全部相同，才会被视为重复，只要有一个字段不相同，就不认为是重复。 除此之外，distinct经常用来统计不重复字段的条数， 语法：select count(distinct 字段名) from 表名;演示：select count(distinct StudentID) from students;演示：select count(distinct name) from students; 1234567891011121314151617mysql&gt; select count(distinct StudentID) from students;+---------------------------+| count(distinct StudentID) |+---------------------------+| 6 |+---------------------------+1 row in set (0.00 sec)mysql&gt; select count(distinct name) from students;+----------------------+| count(distinct name) |+----------------------+| 5 |+----------------------+1 row in set (0.00 sec)mysql&gt; 以上两条查询结果表示在students表中，ID不相同的记录有6条，而name不相同的记录有5条。 条件查询比较运算符 等于 = 大于 &gt; 小于 &lt; 大于等于 &gt;= 小于等于 &lt;= 不等于 != 或 &lt;&gt; 单条件比较运算很简单，与以下类似，就不一一列举了语法：select 列名 from 表名 where 条件;演示：select * from students where age &gt; 25; 年龄大于25的；演示：select * from students where age &lt;&gt; 28; 年龄不等于28的；演示：select * from students where age &lt;= 25; 年龄小于等于25的；演示：select * from students where sex = &quot;女&quot;; 性别为女性的； 12345678910111213141516171819202122232425262728293031323334353637383940mysql&gt; select * from students where age &gt; 25;+-----------+-----------+------+------+----------+----------+| StudentID | name | age | sex | username | password |+-----------+-----------+------+------+----------+----------+| 9559 | 梅长苏 | 28 | 男 | | 123456 || 9560 | 穆霓凰 | 26 | 女 | | 123456 || 9562 | 萧景琰 | 28 | 男 | 靖王 | 123456 || 9563 | 萧景琰 | 28 | 男 | 靖王 | 123456 |+-----------+-----------+------+------+----------+----------+4 rows in set (0.00 sec)mysql&gt; select * from students where age &lt;&gt; 28;+-----------+-----------+------+------+----------+----------+| StudentID | name | age | sex | username | password |+-----------+-----------+------+------+----------+----------+| 9556 | Lily | 21 | 女 | | 123456 || 9560 | 穆霓凰 | 26 | 女 | | 123456 || 9561 | 飞流 | 17 | 男 | | 123456 |+-----------+-----------+------+------+----------+----------+3 rows in set (0.00 sec)mysql&gt; select * from students where age &lt;= 25;+-----------+--------+------+------+----------+----------+| StudentID | name | age | sex | username | password |+-----------+--------+------+------+----------+----------+| 9556 | Lily | 21 | 女 | | 123456 || 9561 | 飞流 | 17 | 男 | | 123456 |+-----------+--------+------+------+----------+----------+2 rows in set (0.00 sec)mysql&gt; select * from students where sex = \"女\";+-----------+-----------+------+------+----------+----------+| StudentID | name | age | sex | username | password |+-----------+-----------+------+------+----------+----------+| 9556 | Lily | 21 | 女 | | 123456 || 9560 | 穆霓凰 | 26 | 女 | | 123456 |+-----------+-----------+------+------+----------+----------+2 rows in set (0.00 sec)mysql&gt; 逻辑运算符 and, &amp;&amp; (与) or, || (或) not, !(非) xor (异或) 从students表中找出年龄大于25的或者性别为女性的学生演示：select * from students where age &gt; 25 or sex = &quot;女&quot;或者：select * from students where age &gt; 25 || sex = &quot;女&quot; 12345678910111213mysql&gt; select * from students where age &gt; 25 or sex = \"女\";+-----------+-----------+------+------+----------+----------+| StudentID | name | age | sex | username | password |+-----------+-----------+------+------+----------+----------+| 9556 | Lily | 21 | 女 | | 123456 || 9559 | 梅长苏 | 28 | 男 | | 123456 || 9560 | 穆霓凰 | 26 | 女 | | 123456 || 9562 | 萧景琰 | 28 | 男 | 靖王 | 123456 || 9563 | 萧景琰 | 28 | 男 | 靖王 | 123456 |+-----------+-----------+------+------+----------+----------+5 rows in set (0.00 sec)mysql&gt; 从students表中找出要么年龄大于25的，要么性别为女性的学生演示：select * from students where age &gt; 25 xor sex = &quot;女&quot;;这里的异或表示两个条件既不能同时满足，也不能同时不满足， 12345678910111213mysql&gt; select * from students where age &gt; 25 xor sex = \"女\";+-----------+-----------+------+------+----------+----------+| StudentID | name | age | sex | username | password |+-----------+-----------+------+------+----------+----------+| 9556 | Lily | 21 | 女 | | 123456 || 9559 | 梅长苏 | 28 | 男 | | 123456 || 9562 | 萧景琰 | 28 | 男 | 靖王 | 123456 || 9563 | 萧景琰 | 28 | 男 | 靖王 | 123456 |+-----------+-----------+------+------+----------+----------+4 rows in set (0.00 sec)mysql&gt; 模糊查询从students表中查询姓名中含有“梅”字的学生，使用like关键字，演示：select * from students where name like &quot;%梅%&quot;;这里的 % 表示任意多个字符， 1234567891011121314151617mysql&gt; select * from students where name like \"%梅%\";+-----------+-----------+------+------+----------+----------+| StudentID | name | age | sex | username | password |+-----------+-----------+------+------+----------+----------+| 9559 | 梅长苏 | 28 | 男 | | 123456 |+-----------+-----------+------+------+----------+----------+1 row in set (0.00 sec)mysql&gt; select * from students where name like \"%凰\";+-----------+-----------+------+------+----------+----------+| StudentID | name | age | sex | username | password |+-----------+-----------+------+------+----------+----------+| 9560 | 穆霓凰 | 26 | 女 | | 123456 |+-----------+-----------+------+------+----------+----------+1 row in set (0.00 sec)mysql&gt; 找出名字是两个字的学生，演示：select * from students where name like &quot;__&quot;;这里用下划线_表示，一个下划线表示任意一个字符，两个下划线表示任意两个字符， 123456789mysql&gt; select * from students where name like \"__\";+-----------+--------+------+------+----------+----------+| StudentID | name | age | sex | username | password |+-----------+--------+------+------+----------+----------+| 9561 | 飞流 | 17 | 男 | | 123456 |+-----------+--------+------+------+----------+----------+1 row in set (0.00 sec)mysql&gt; 区间查询非连续区间语法：in(条件1，条件2)演示：select * from students where age in(21,26,28);表示找出年龄是21岁，26岁，或者28岁的学生 12345678910111213mysql&gt; select * from students where age in(21,26,28);+-----------+-----------+------+------+----------+----------+| StudentID | name | age | sex | username | password |+-----------+-----------+------+------+----------+----------+| 9556 | Lily | 21 | 女 | | 123456 || 9559 | 梅长苏 | 28 | 男 | | 123456 || 9560 | 穆霓凰 | 26 | 女 | | 123456 || 9562 | 萧景琰 | 28 | 男 | 靖王 | 123456 || 9563 | 萧景琰 | 28 | 男 | 靖王 | 123456 |+-----------+-----------+------+------+----------+----------+5 rows in set (0.00 sec)mysql&gt; 连续区间语法：between 条件1 and 条件2演示：select * from students where StudentID between 9561 and 9563;表示查询ID在9561和9563之间的学生 1234567891011mysql&gt; select * from students where StudentID between 9561 and 9563;+-----------+-----------+------+------+----------+----------+| StudentID | name | age | sex | username | password |+-----------+-----------+------+------+----------+----------+| 9561 | 飞流 | 17 | 男 | | 123456 || 9562 | 萧景琰 | 28 | 男 | 靖王 | 123456 || 9563 | 萧景琰 | 28 | 男 | 靖王 | 123456 |+-----------+-----------+------+------+----------+----------+3 rows in set (0.00 sec)mysql&gt; null判断is null 和 is not null从emp表中查询comm为null的，再查询comm不为null的数据 1234567891011121314151617181920212223242526272829mysql&gt; select * from emp where comm is null;+-------+--------+-----------+------+---------------------+---------+------+--------+| empno | ename | job | mgr | hiredate | sal | comm | deptno |+-------+--------+-----------+------+---------------------+---------+------+--------+| 7369 | SMITH | CLERK | 7902 | 1980-12-17 00:00:00 | 800.00 | NULL | 20 || 7566 | JONES | MANAGER | 7839 | 1981-04-02 00:00:00 | 2975.00 | NULL | 20 || 7698 | BLAKE | MANAGER | 7839 | 1981-05-01 00:00:00 | 2850.00 | NULL | 30 || 7782 | CLARK | MANAGER | 7839 | 1981-06-09 00:00:00 | 2450.00 | NULL | 10 || 7788 | SCOTT | ANALYST | 7566 | 1982-12-09 00:00:00 | 3000.00 | NULL | 20 || 7839 | KING | PRESIDENT | NULL | 1981-11-17 00:00:00 | 5000.00 | NULL | 10 || 7876 | ADAMS | CLERK | 7788 | 1983-01-12 00:00:00 | 1100.00 | NULL | 20 || 7900 | JAMES | CLERK | 7698 | 1981-12-03 00:00:00 | 950.00 | NULL | 30 || 7902 | FORD | ANALYST | 7566 | 1981-12-03 00:00:00 | 3000.00 | NULL | 20 || 7934 | MILLER | CLERK | 7782 | 1982-01-23 00:00:00 | 1300.00 | NULL | 10 |+-------+--------+-----------+------+---------------------+---------+------+--------+10 rows in set (0.00 sec)mysql&gt; select * from emp where comm is not null;+-------+--------+----------+------+---------------------+---------+---------+--------+| empno | ename | job | mgr | hiredate | sal | comm | deptno |+-------+--------+----------+------+---------------------+---------+---------+--------+| 7499 | ALLEN | SALESMAN | 7698 | 1981-02-20 00:00:00 | 1600.00 | 300.00 | 30 || 7521 | WARD | SALESMAN | 7698 | 1981-02-22 00:00:00 | 1250.00 | 500.00 | 30 || 7654 | MARTIN | SALESMAN | 7698 | 1981-09-28 00:00:00 | 1250.00 | 1400.00 | 30 || 7844 | TURNER | SALESMAN | 7698 | 1981-09-08 00:00:00 | 1500.00 | 0.00 | 30 |+-------+--------+----------+------+---------------------+---------+---------+--------+4 rows in set (0.00 sec)mysql&gt; 排序order by 排序，包括升序（asc）和降序（desc），order by 默认为升序，所以asc关键字可省略 从students表中查询所有的学生，并按年龄从小到大排序，演示：select * from students order by age; 这里省略了关键字asc 1234567891011121314mysql&gt; select * from students order by age;+-----------+-----------+------+------+----------+----------+| StudentID | name | age | sex | username | password |+-----------+-----------+------+------+----------+----------+| 9561 | 飞流 | 17 | 男 | | 123456 || 9556 | Lily | 21 | 女 | | 123456 || 9560 | 穆霓凰 | 26 | 女 | | 123456 || 9559 | 梅长苏 | 28 | 男 | | 123456 || 9562 | 萧景琰 | 28 | 男 | 靖王 | 123456 || 9563 | 萧景琰 | 28 | 男 | 靖王 | 123456 |+-----------+-----------+------+------+----------+----------+6 rows in set (0.00 sec)mysql&gt; 从students表中查询所有的学生信息，并按年龄从大到小排序，演示：select * from students order by age desc; 1234567891011121314mysql&gt; select * from students order by age desc;+-----------+-----------+------+------+----------+----------+| StudentID | name | age | sex | username | password |+-----------+-----------+------+------+----------+----------+| 9559 | 梅长苏 | 28 | 男 | | 123456 || 9562 | 萧景琰 | 28 | 男 | 靖王 | 123456 || 9563 | 萧景琰 | 28 | 男 | 靖王 | 123456 || 9560 | 穆霓凰 | 26 | 女 | | 123456 || 9556 | Lily | 21 | 女 | | 123456 || 9561 | 飞流 | 17 | 男 | | 123456 |+-----------+-----------+------+------+----------+----------+6 rows in set (0.00 sec)mysql&gt; 多种规则排序从students表中查询所有学生信息，并按年龄从小到大排列，年龄相同的，按学号从大到小排列演示：select * from students order by age,studentID desc; 1234567891011121314mysql&gt; select * from students order by age,studentID desc;+-----------+-----------+------+------+----------+----------+| StudentID | name | age | sex | username | password |+-----------+-----------+------+------+----------+----------+| 9561 | 飞流 | 17 | 男 | | 123456 || 9556 | Lily | 21 | 女 | | 123456 || 9560 | 穆霓凰 | 26 | 女 | | 123456 || 9563 | 萧景琰 | 28 | 男 | 靖王 | 123456 || 9562 | 萧景琰 | 28 | 男 | 靖王 | 123456 || 9559 | 梅长苏 | 28 | 男 | | 123456 |+-----------+-----------+------+------+----------+----------+6 rows in set (0.00 sec)mysql&gt; MySQL查询这一节就到这里，下一节继续复杂查询，并学习多表联查。 版权声明：博客中的文章版权归博主所有，未经授权，禁止转载，转载请注明出处，合作请点击“关于我”，扫码添加微信","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"MySQL数据库","slug":"MySQL数据库","permalink":"http://yoursite.com/tags/MySQL数据库/"}]},{"title":"MySQL8.0：添加、修改、删除数据，修改表结构","slug":"MySQL8.0：添加、修改、删除数据，修改表结构","date":"2018-07-28T02:10:00.000Z","updated":"2018-10-24T00:48:27.113Z","comments":true,"path":"2018/07/28/MySQL8.0：添加、修改、删除数据，修改表结构/","link":"","permalink":"http://yoursite.com/2018/07/28/MySQL8.0：添加、修改、删除数据，修改表结构/","excerpt":"整理：房玉辉","text":"整理：房玉辉 博客：https://ElonJelinek.github.io基于上一节中创建的student表，这一节中，来对student表进行进一步的增删改查。 MySQL的数据类型最常用的类型：int：整型double：浮点型char：固定长度字符串类型，中文汉字属于字符串类型varchar：可变长度字符串类型，中文汉字属于字符串类型text：字符串类型，存储超大文本date：日期类型，格式为：yyyy-MM-ddtime：时间类型，格式为：hh:mm:sstimestamp：时间戳 表的约束这里的约束是指在创建表的时候，对表的字段所设置的约束条件，用来限制该列的数据类型和内容 default：默认值not null ：非空约束，其值不能为空，不是0，也不是空字符串””，也可以是nullunique：唯一性约束，强调该字段所有的值都是唯一的，不允许重复，但允许空值，且可以有多个空值primary key：主键约束，要求该字段数值不能为空，而且数值唯一auto_increment：自增约束，要求该字段不能为空，数值唯一，类型为整型，并根据前一条数据自动加1 添加数据：先看一下表的结构：mysql&gt; describe student; 123456789101112mysql&gt; describe student;+-------+-------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || name | varchar(16) | NO | | NULL | || age | int(11) | YES | | NULL | || sex | char(1) | YES | | NULL | |+-------+-------------+------+-----+---------+----------------+4 rows in set (0.01 sec)mysql&gt; 全列插入：name和sex字段为字符串类型，注意加双引号，英文符号。 插入一行数据：语法：insert into 表名 values(值1，值2，....);演示：insert into student values(9527,&quot;jack&quot;,23,&quot;男&quot;); 1234mysql&gt; insert into student values(9527,\"jack\",23,\"男\");Query OK, 1 row affected (0.01 sec)mysql&gt; 全列插入的时候，每一列的数据都要填。查询数据： 123456789mysql&gt; select * from student;+------+------+------+------+| id | name | age | sex |+------+------+------+------+| 9527 | jack | 23 | 男 |+------+------+------+------+1 row in set (0.00 sec)mysql&gt; 同时插入多条数据：语法：insert into 表名 values(值1, 值2,...), (值1, 值2,...),...;演示：insert into student value (9529,&quot;Tom&quot;,22,&quot;男&quot;), (9555,&quot;lucy&quot;,20,&quot;女&quot;), (0,&quot;liiy&quot;,21,&quot;女&quot;);value和values均可，一行写不完，可以按回车，在下一行继续写，一般一条数据占一行，即一个括号占一行，以便整洁美观。 12345678910111213141516171819mysql&gt; insert into student value -&gt; (9529,\"Tom\",22,\"男\"), -&gt; (9555,\"lucy\",20,\"女\"), -&gt; (0,\"liiy\",21,\"女\");Query OK, 3 rows affected (0.09 sec)Records: 3 Duplicates: 0 Warnings: 0mysql&gt; select * from student;+------+------+------+------+| id | name | age | sex |+------+------+------+------+| 9527 | jack | 23 | 男 || 9529 | Tom | 22 | 男 || 9555 | lucy | 20 | 女 || 9556 | liiy | 21 | 女 |+------+------+------+------+4 rows in set (0.00 sec)mysql&gt; 每一条数据用一个英文()括起来，两个括号之间，用逗号隔开，字符串类型的值，要加双引号，最后一个括号后面用分号结束。 其中id字段为自增长类型，0用来对自增长的数据占位，表示前一个id加1。 缺省插入同时插入多条数据：语法：insert into 表名(列1, 列2, ...) values(值1, 值2, ...);演示：insert into student(name,age,sex) values (&quot;梅长苏&quot;,28,&quot;男&quot;), (&quot;穆霓凰&quot;,26,&quot;女&quot;), (&quot;飞流&quot;,17,&quot;男&quot;); 12345678910111213141516171819202122mysql&gt; insert into student(name,age,sex) values -&gt; (\"梅长苏\",28,\"男\"), -&gt; (\"穆霓凰\",26,\"女\"), -&gt; (\"飞流\",17,\"男\");Query OK, 3 rows affected (0.10 sec)Records: 3 Duplicates: 0 Warnings: 0mysql&gt; select * from student;+------+-----------+------+------+| id | name | age | sex |+------+-----------+------+------+| 9527 | jack | 23 | 男 || 9529 | Tom | 22 | 男 || 9555 | lucy | 20 | 女 || 9556 | liiy | 21 | 女 || 9559 | 梅长苏 | 28 | 男 || 9560 | 穆霓凰 | 26 | 女 || 9561 | 飞流 | 17 | 男 |+------+-----------+------+------+7 rows in set (0.00 sec)mysql&gt; not null和primary key字段必须赋值，其他字段可以省略。 修改数据语法：update 表名 set 列1=值1,列2=值2,... where 条件 演示：update student set name=&quot;Lily&quot; where name=&quot;liiy&quot;; 123456789101112131415161718mysql&gt; update student set name=\"Lily\" where name=\"liiy\";Query OK, 1 row affected (0.04 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from student; +------+-----------+------+------+| id | name | age | sex |+------+-----------+------+------+| 9527 | jack | 23 | 男 || 9529 | Tom | 22 | 男 || 9555 | lucy | 20 | 女 || 9556 | Lily | 21 | 女 || 9559 | 梅长苏 | 28 | 男 || 9560 | 穆霓凰 | 26 | 女 || 9561 | 飞流 | 17 | 男 |+------+-----------+------+------+7 rows in set (0.00 sec)mysql&gt; 删除数据语法：delete from 表名 where 条件演示：delete from student where id=9555; 1234mysql&gt; delete from student where id=9555;Query OK, 1 row affected (0.15 sec)mysql&gt; 1234mysql&gt; delete from student where id=9527 or name=\"Tom\";Query OK, 2 rows affected (0.01 sec)mysql&gt; 修改表结构添加字段语法：alter table 表名 add 列名 列类型;演示：alter table student add username varchar(18) not null;演示：alter table student add password varchar(12) default &quot;123456&quot;; 修改列类型语法：alter table 表名 modify 列名 列类型;演示：alter table student modify password varchar(10) default &quot;123456&quot;; 修改列名语法：alter table 表名 change 原列名 新列名 列类型;演示：alter table student change id StudentID int(11) auto_increment; 修改表名称语法：rename table 原表名 to 新表名;演示：rename table student to students; 演示结果： 1234567891011121314151617181920212223242526272829303132333435363738394041424344mysql&gt; alter table student add username varchar(18) not null;Query OK, 0 rows affected (0.12 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; alter table student add password varchar(12) default \"123456\";Query OK, 0 rows affected (0.18 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; alter table student modify password varchar(10) default \"123456\";Query OK, 4 rows affected (0.20 sec)Records: 4 Duplicates: 0 Warnings: 0mysql&gt; alter table student change id StudentID int(11) auto_increment;Query OK, 4 rows affected (0.05 sec)Records: 4 Duplicates: 0 Warnings: 0mysql&gt; rename table student to students;Query OK, 0 rows affected (0.04 sec)mysql&gt; describe students;+-----------+-------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-----------+-------------+------+-----+---------+----------------+| StudentID | int(11) | NO | PRI | NULL | auto_increment || name | varchar(16) | NO | | NULL | || age | int(11) | YES | | NULL | || sex | char(1) | YES | | NULL | || username | varchar(18) | NO | | NULL | || password | varchar(10) | YES | | 123456 | |+-----------+-------------+------+-----+---------+----------------+6 rows in set (0.00 sec)mysql&gt; select * from students;+-----------+-----------+------+------+----------+----------+| StudentID | name | age | sex | username | password |+-----------+-----------+------+------+----------+----------+| 9556 | Lily | 21 | 女 | | 123456 || 9559 | 梅长苏 | 28 | 男 | | 123456 || 9560 | 穆霓凰 | 26 | 女 | | 123456 || 9561 | 飞流 | 17 | 男 | | 123456 |+-----------+-----------+------+------+----------+----------+4 rows in set (0.00 sec)mysql&gt; 注意add添加列不会影响数据，更改表的名称也不会影响到数据，而modify修改列类型，change修改列名都会影响到数据，所以当表中有数据的时候，修改列名和列类型的时候要格外注意。 补充内容删除字段语法：alter table 表名 drop 列名;演示：alter table userinfo drop age; 1234567mysql&gt; alter table userinfo drop telephone;Query OK, 0 rows affected (0.15 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; alter table userinfo drop age;Query OK, 0 rows affected (0.30 sec)Records: 0 Duplicates: 0 Warnings: 0 版权声明：博客中的文章版权归博主所有，未经授权，禁止转载，转载请注明出处，合作请点击“关于我”，扫码添加微信","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"MySQL数据库","slug":"MySQL数据库","permalink":"http://yoursite.com/tags/MySQL数据库/"}]},{"title":"MySQL8.0 创建用户，创建数据库，授权和创建表","slug":"MySQL8.0 创建用户，创建数据库，授权和创建表","date":"2018-07-27T14:29:00.000Z","updated":"2018-10-24T06:59:49.787Z","comments":true,"path":"2018/07/27/MySQL8.0 创建用户，创建数据库，授权和创建表/","link":"","permalink":"http://yoursite.com/2018/07/27/MySQL8.0 创建用户，创建数据库，授权和创建表/","excerpt":"整理：房玉辉","text":"整理：房玉辉 博客：https://ElonJelinek.github.io创建用户创建一个指定主机为127.0.0.1的用户，该用户只能在IP为127.0.0.1的主机登录，用户名叫做Tom，密码为234567 1234mysql&gt; create user 'Tom'@'127.0.0.1' identified by '234567';Query OK, 0 rows affected (0.14 sec)mysql&gt; 为新用户授权为`Tom@127.0.0.1用户授权，grant all`表示授权所有权限 1234mysql&gt; grant all on *.* to 'Tom'@'127.0.0.1' with grant option;Query OK, 0 rows affected (0.16 sec)mysql&gt; 查看权限查看用户`Tom@127.0.0.1`的权限 12345678910mysql&gt; show grants for 'Tom'@'127.0.0.1';+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| Grants for Tom@127.0.0.1 |+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| GRANT SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, RELOAD, SHUTDOWN, PROCESS, FILE, REFERENCES, INDEX, ALTER, SHOW DATABASES, SUPER, CREATE TEMPORARY TABLES, LOCK TABLES, EXECUTE, REPLICATION SLAVE, REPLICATION CLIENT, CREATE VIEW, SHOW VIEW, CREATE ROUTINE, ALTER ROUTINE, CREATE USER, EVENT, TRIGGER, CREATE TABLESPACE, CREATE ROLE, DROP ROLE ON *.* TO `Tom`@`127.0.0.1` WITH GRANT OPTION || GRANT BACKUP_ADMIN,BINLOG_ADMIN,CONNECTION_ADMIN,ENCRYPTION_KEY_ADMIN,GROUP_REPLICATION_ADMIN,PERSIST_RO_VARIABLES_ADMIN,REPLICATION_SLAVE_ADMIN,RESOURCE_GROUP_ADMIN,RESOURCE_GROUP_USER,ROLE_ADMIN,SET_USER_ID,SYSTEM_VARIABLES_ADMIN,XA_RECOVER_ADMIN ON *.* TO `Tom`@`127.0.0.1` WITH GRANT OPTION |+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+2 rows in set (0.00 sec)mysql&gt; 查看所有的用户12345678910111213mysql&gt; select host,user from mysql.user;+-----------+------------------+| host | user |+-----------+------------------+| 127.0.0.1 | Tom || localhost | mysql.infoschema || localhost | mysql.session || localhost | mysql.sys || localhost | root |+-----------+------------------+5 rows in set (0.00 sec)mysql&gt; 查看当前用户123456789mysql&gt; select current_user();+----------------+| current_user() |+----------------+| root@localhost |+----------------+1 row in set (0.00 sec)mysql&gt; 退出root用户，用Tom@127.0.0.1用户登录-h表示指定主机IP，-u表示指定用户名，-p表示指定密码 123456789101112131415ElonJelinek:~ ElonJelinek$ mysql -h 127.0.0.1 -u Tom -pEnter password: Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 53Server version: 8.0.12 HomebrewCopyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.mysql&gt; 查看当前用户123456789mysql&gt; select current_user;+---------------+| current_user |+---------------+| Tom@127.0.0.1 |+---------------+1 row in set (0.00 sec)mysql&gt; 查看当前用户权限12345678910mysql&gt; show grants;+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| Grants for Tom@127.0.0.1 |+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| GRANT SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, RELOAD, SHUTDOWN, PROCESS, FILE, REFERENCES, INDEX, ALTER, SHOW DATABASES, SUPER, CREATE TEMPORARY TABLES, LOCK TABLES, EXECUTE, REPLICATION SLAVE, REPLICATION CLIENT, CREATE VIEW, SHOW VIEW, CREATE ROUTINE, ALTER ROUTINE, CREATE USER, EVENT, TRIGGER, CREATE TABLESPACE, CREATE ROLE, DROP ROLE ON *.* TO `Tom`@`127.0.0.1` WITH GRANT OPTION || GRANT BACKUP_ADMIN,BINLOG_ADMIN,CONNECTION_ADMIN,ENCRYPTION_KEY_ADMIN,GROUP_REPLICATION_ADMIN,PERSIST_RO_VARIABLES_ADMIN,REPLICATION_SLAVE_ADMIN,RESOURCE_GROUP_ADMIN,RESOURCE_GROUP_USER,ROLE_ADMIN,SET_USER_ID,SYSTEM_VARIABLES_ADMIN,XA_RECOVER_ADMIN ON *.* TO `Tom`@`127.0.0.1` WITH GRANT OPTION |+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+2 rows in set (0.00 sec)mysql&gt; 创建数据库创建一个数据库 mysql2018为新创建的数据库的名称，default character set = utf8表示默认编码格式为utf8格式。 1234mysql&gt; create database mysql2018 default character set = utf8;Query OK, 1 row affected, 1 warning (0.02 sec)mysql&gt; 查看当前用户下所有数据库 12345678910111213mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || mysql2018 || performance_schema || sys |+--------------------+5 rows in set (0.00 sec)mysql&gt; 选择一个数据库mysql，并查看其中的表 12345678910111213141516171819202122232425262728293031323334353637383940414243444546mysql&gt; use mysql;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; show tables;+---------------------------+| Tables_in_mysql |+---------------------------+| columns_priv || component || db || default_roles || engine_cost || func || general_log || global_grants || gtid_executed || help_category || help_keyword || help_relation || help_topic || innodb_index_stats || innodb_table_stats || password_history || plugin || procs_priv || proxies_priv || role_edges || server_cost || servers || slave_master_info || slave_relay_log_info || slave_worker_info || slow_log || tables_priv || time_zone || time_zone_leap_second || time_zone_name || time_zone_transition || time_zone_transition_type || user |+---------------------------+33 rows in set (0.00 sec)mysql&gt; 再次查询一下当前用户，看看是哪个用户，发现确实是新创建的Tom@127.0.0.1用户，这个新创建的用户下面就已经默认有一些数据库，并且数据库里默认有一些表。 123456789mysql&gt; select current_user;+---------------+| current_user |+---------------+| Tom@127.0.0.1 |+---------------+1 row in set (0.00 sec)mysql&gt; 这里选择刚刚新创建的那个数据库mysql2018，做进一步操作 1234mysql&gt; use mysql2018;Database changedmysql&gt; 查看当前数据库即当前正在使用的数据库 123456789mysql&gt; select database();+------------+| database() |+------------+| mysql2018 |+------------+1 row in set (0.00 sec)mysql&gt; 授权当前用户拥有mysql2018这个数据库的所有权限1234mysql&gt; grant all privileges on mysql2018.* to Tom@127.0.0.1;Query OK, 0 rows affected (0.17 sec)mysql&gt; 刷新系统权限表 1234mysql&gt; flush privileges;Query OK, 0 rows affected (0.00 sec)mysql&gt; 查看这个数据库中是否有表 12mysql&gt; show tables;Empty set (0.00 sec) 创建表经查询发现这个数据库中并没有表，接下来就创建一张表 1234mysql&gt; create table student(id int auto_increment primary key,name varchar(16) not null,age int,sex char(1));Query OK, 0 rows affected (0.12 sec)mysql&gt; 表名为student，表中有id,name,age,sex四个字段，其中 字段id为自增长，并且为主键，数据类型为int，字段name的数据类型为varchar，最大长度为16，并且不能为空，字段age的数据类型为int，字段sex的数据类型为char，长度为1。 数据类型char的长度不可变，varchar的长度可变。 查看字符集12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849mysql&gt; show charset;+----------+---------------------------------+---------------------+--------+| Charset | Description | Default collation | Maxlen |+----------+---------------------------------+---------------------+--------+| armscii8 | ARMSCII-8 Armenian | armscii8_general_ci | 1 || ascii | US ASCII | ascii_general_ci | 1 || big5 | Big5 Traditional Chinese | big5_chinese_ci | 2 || binary | Binary pseudo charset | binary | 1 || cp1250 | Windows Central European | cp1250_general_ci | 1 || cp1251 | Windows Cyrillic | cp1251_general_ci | 1 || cp1256 | Windows Arabic | cp1256_general_ci | 1 || cp1257 | Windows Baltic | cp1257_general_ci | 1 || cp850 | DOS West European | cp850_general_ci | 1 || cp852 | DOS Central European | cp852_general_ci | 1 || cp866 | DOS Russian | cp866_general_ci | 1 || cp932 | SJIS for Windows Japanese | cp932_japanese_ci | 2 || dec8 | DEC West European | dec8_swedish_ci | 1 || eucjpms | UJIS for Windows Japanese | eucjpms_japanese_ci | 3 || euckr | EUC-KR Korean | euckr_korean_ci | 2 || gb18030 | China National Standard GB18030 | gb18030_chinese_ci | 4 || gb2312 | GB2312 Simplified Chinese | gb2312_chinese_ci | 2 || gbk | GBK Simplified Chinese | gbk_chinese_ci | 2 || geostd8 | GEOSTD8 Georgian | geostd8_general_ci | 1 || greek | ISO 8859-7 Greek | greek_general_ci | 1 || hebrew | ISO 8859-8 Hebrew | hebrew_general_ci | 1 || hp8 | HP West European | hp8_english_ci | 1 || keybcs2 | DOS Kamenicky Czech-Slovak | keybcs2_general_ci | 1 || koi8r | KOI8-R Relcom Russian | koi8r_general_ci | 1 || koi8u | KOI8-U Ukrainian | koi8u_general_ci | 1 || latin1 | cp1252 West European | latin1_swedish_ci | 1 || latin2 | ISO 8859-2 Central European | latin2_general_ci | 1 || latin5 | ISO 8859-9 Turkish | latin5_turkish_ci | 1 || latin7 | ISO 8859-13 Baltic | latin7_general_ci | 1 || macce | Mac Central European | macce_general_ci | 1 || macroman | Mac West European | macroman_general_ci | 1 || sjis | Shift-JIS Japanese | sjis_japanese_ci | 2 || swe7 | 7bit Swedish | swe7_swedish_ci | 1 || tis620 | TIS620 Thai | tis620_thai_ci | 1 || ucs2 | UCS-2 Unicode | ucs2_general_ci | 2 || ujis | EUC-JP Japanese | ujis_japanese_ci | 3 || utf16 | UTF-16 Unicode | utf16_general_ci | 4 || utf16le | UTF-16LE Unicode | utf16le_general_ci | 4 || utf32 | UTF-32 Unicode | utf32_general_ci | 4 || utf8 | UTF-8 Unicode | utf8_general_ci | 3 || utf8mb4 | UTF-8 Unicode | utf8mb4_0900_ai_ci | 4 |+----------+---------------------------------+---------------------+--------+41 rows in set (0.05 sec)mysql&gt; MySQL当前支持41种字符集。 查看表结构查看刚刚创建的表student的结构 123456789101112mysql&gt; describe student;+-------+-------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || name | varchar(16) | NO | | NULL | || age | int(11) | YES | | NULL | || sex | char(1) | YES | | NULL | |+-------+-------------+------+-----+---------+----------------+4 rows in set (0.00 sec)mysql&gt; 查看建表语句123456789101112131415mysql&gt; show create table student;+---------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| Table | Create Table |+---------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| student | CREATE TABLE `student` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(16) NOT NULL, `age` int(11) DEFAULT NULL, `sex` char(1) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 |+---------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+1 row in set (0.00 sec)mysql&gt; 查看存储引擎1234567891011mysql&gt; show variables like \"%engine%\";+----------------------------------+-----------+| Variable_name | Value |+----------------------------------+-----------+| default_storage_engine | InnoDB || default_tmp_storage_engine | InnoDB || disabled_storage_engines | || internal_tmp_disk_storage_engine | InnoDB || internal_tmp_mem_storage_engine | TempTable |+----------------------------------+-----------+5 rows in set (0.04 sec) 查看索引123456789mysql&gt; show index from students;+----------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible |+----------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+| students | 0 | PRIMARY | 1 | StudentID | A | 7 | NULL | NULL | | BTREE | | | YES |+----------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+1 row in set (0.06 sec)mysql&gt; 下一节，就开始对这里创建的student表进行增删改查操作。 版权声明：博客中的文章版权归博主所有，未经授权，禁止转载，转载请注明出处，合作请点击“关于我”，扫码添加微信","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"MySQL数据库","slug":"MySQL数据库","permalink":"http://yoursite.com/tags/MySQL数据库/"}]},{"title":"MySQL8.0的帮助信息","slug":"MySQL8.0的帮助信息","date":"2018-07-27T14:10:08.000Z","updated":"2018-08-24T11:48:17.386Z","comments":true,"path":"2018/07/27/MySQL8.0的帮助信息/","link":"","permalink":"http://yoursite.com/2018/07/27/MySQL8.0的帮助信息/","excerpt":"整理：房玉辉","text":"整理：房玉辉 博客：https://ElonJelinek.github.ioMySQL8.0的帮助信息MySQL8.0版本相比于MySQL5.0做了很多的更改，有很多函数和字段都被删除了，因此之前网上的很多操作，现在已经不适用于8.0版本了，由于8.0版本是近期才更新的，所以对新手来说，会遇到很多的坑，而且一些坑在网上还找不到答案，所以跳坑最好的方法，就是查看MySQL自带的帮助信息，这里列出来一部分查看帮助信息的命令，以及一些帮助信息。 当然，帮助信息需要在安装MySQL8.0并登陆成功之后，才能查看得到，并且需要有一定的英语基础。 另外，跳坑最好的方法，就是不断地尝试，不断地总结，做记录。 账户管理123456789101112131415161718192021mysql&gt; help account management;You asked for help about help category: \"Account Management\"For more information, type 'help &lt;item&gt;', where &lt;item&gt; is one of the followingtopics: ALTER RESOURCE GROUP ALTER USER CREATE RESOURCE GROUP CREATE ROLE CREATE USER DROP RESOURCE GROUP DROP ROLE DROP USER GRANT RENAME USER REVOKE SET DEFAULT ROLE SET PASSWORD SET RESOURCE GROUP SET ROLEmysql&gt; 创建用户：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495mysql&gt; help create user;Name: 'CREATE USER'Description:Syntax:CREATE USER [IF NOT EXISTS] user [auth_option] [, user [auth_option]] ... DEFAULT ROLE role [, role ] ... [REQUIRE &#123;NONE | tls_option [[AND] tls_option] ...&#125;] [WITH resource_option [resource_option] ...] [password_option | lock_option] ...user: (see )auth_option: &#123; IDENTIFIED BY 'auth_string' | IDENTIFIED WITH auth_plugin | IDENTIFIED WITH auth_plugin BY 'auth_string' | IDENTIFIED WITH auth_plugin AS 'hash_string' | IDENTIFIED BY PASSWORD 'hash_string'&#125;tls_option: &#123; SSL | X509 | CIPHER 'cipher' | ISSUER 'issuer' | SUBJECT 'subject'&#125;resource_option: &#123; MAX_QUERIES_PER_HOUR count | MAX_UPDATES_PER_HOUR count | MAX_CONNECTIONS_PER_HOUR count | MAX_USER_CONNECTIONS count&#125;password_option: &#123; PASSWORD EXPIRE | PASSWORD EXPIRE DEFAULT | PASSWORD EXPIRE NEVER | PASSWORD EXPIRE INTERVAL N DAY | PASSWORD HISTORY DEFAULT | PASSWORD HISTORY N | PASSWORD REUSE INTERVAL DEFAULT | PASSWORD REUSE INTERVAL N DAY&#125;lock_option: &#123; ACCOUNT LOCK | ACCOUNT UNLOCK&#125;The CREATE USER statement creates new MySQL accounts. It enablesauthentication, SSL/TLS, resource-limit, and password-managementproperties to be established for new accounts, and controls whetheraccounts are initially locked or unlocked.To use CREATE USER, you must have the global CREATE USER privilege, orthe INSERT privilege for the mysql database. When the read_only systemvariable is enabled, CREATE USER additionally requires theCONNECTION_ADMIN or SUPER privilege.CREATE USER either succeeds for all named users or rolls back and hasno effect if any error occurs. By default, an error occurs if you tryto create a user that already exists. If the IF NOT EXISTS clause isgiven, the statement produces a warning for each named user thatalready exists, rather than an error.The statement is written to the binary log if it succeeds, but not ifit fails; in that case, rollback occurs and no changes are made. Astatement written to the binary log includes all named users. If the IFNOT EXISTS clause is given, this includes even users that already existand were not created.The statement written to the binary log specifies an authenticationplugin for each user, determined as follows:o The plugin named in the original statement, if one was specified.o Otherwise, the default authentication plugin. In particular, if a user u1 already exists and uses a nondefault authentication plugin, the statement written to the binary log for CREATE USER IF NOT EXISTS u1 names the default authentication plugin. (If the statement written to the binary log must specify a nondefault authentication plugin for a user, include it in the original statement.)If the server adds the default authentication plugin for anynonexisting users in the statement written to the binary log, it writesa warning to the error log naming those users.URL: http://dev.mysql.com/doc/refman/8.0/en/create-user.htmlmysql&gt; 修改密码新的方法为 set password for root@localhost = &#39;123456&#39;; 1234mysql&gt; set password for root@localhost = '123456';Query OK, 0 rows affected (0.04 sec)mysql&gt; 旧的方法 set password for &#39;root&#39;@&#39;localhost&#39; = password (&#39;123456&#39;); 在MySQL8.0.11已经被删除，因为新版的MySQL已经没有password字段了，但是password函数没有被删除。 修改密码的帮助信息1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980mysql&gt; help set passwordName: 'SET PASSWORD'Description:Syntax:SET PASSWORD [FOR user] = password_optionpassword_option: &#123; 'auth_string' | PASSWORD('auth_string')&#125;The SET PASSWORD statement assigns a password to a MySQL user account.'auth_string' represents a cleartext (unencrypted) password.*Note*:o SET PASSWORD ... = PASSWORD('auth_string') syntax was removed in MySQL 8.0.11.o Rather than using SET PASSWORD ... = 'auth_string' syntax, ALTER USER syntax is the preferred statement for account alterations, including assigning passwords. For example:ALTER USER user IDENTIFIED BY 'auth_string';*Important*:Under some circumstances, SET PASSWORD may be recorded in server logsor on the client side in a history file such as ~/.mysql_history, whichmeans that cleartext passwords may be read by anyone having read accessto that information. For information about the conditions under whichthis occurs for the server logs and how to control it, seehttp://dev.mysql.com/doc/refman/8.0/en/password-logging.html. Forsimilar information about client-side logging, seehttp://dev.mysql.com/doc/refman/8.0/en/mysql-logging.html.SET PASSWORD can be used with or without a FOR clause that explicitlynames a user account:o With a FOR user clause, the statement sets the password for the named account, which must exist:SET PASSWORD FOR 'jeffrey'@'localhost' = 'auth_string';o With no FOR user clause, the statement sets the password for the current user:SET PASSWORD = 'auth_string'; Any client who connects to the server using a nonanonymous account can change the password for that account. To see which account the server authenticated you as, invoke the CURRENT_USER() function:SELECT CURRENT_USER();Setting the password for a named account (with a FOR clause) requiresthe UPDATE privilege for the mysql database. Setting the password foryourself (for a nonanonymous account with no FOR clause) requires nospecial privileges. When the read_only system variable is enabled, SETPASSWORD requires the CONNECTION_ADMIN or SUPER privilege in additionto any other required privileges.If a FOR user clause is given, the account name uses the formatdescribed in http://dev.mysql.com/doc/refman/8.0/en/account-names.html.For example:SET PASSWORD FOR 'bob'@'%.example.org' = 'auth_string';The host name part of the account name, if omitted, defaults to '%'.SET PASSWORD interprets the string as a cleartext string, passes it tothe authentication plugin associated with the account, and stores theresult returned by the plugin in the mysql.user account row. (Theplugin is given the opportunity to hash the value into the encryptionformat it expects. The plugin may use the value as specified, in whichcase no hashing occurs.)URL: http://dev.mysql.com/doc/refman/8.0/en/set-password.htmlmysql&gt; 授权123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149mysql&gt; help grant;Name: 'GRANT'Description:Syntax:GRANT priv_type [(column_list)] [, priv_type [(column_list)]] ... ON [object_type] priv_level TO user_or_role [auth_option] [, user_or_role [auth_option]] ... [REQUIRE &#123;NONE | tls_option [[AND] tls_option] ...&#125;] [WITH &#123;GRANT OPTION | resource_option&#125; ...]GRANT PROXY ON user_or_role TO user_or_role [, user_or_role] ... [WITH GRANT OPTION]GRANT role [, role] ... TO user_or_role [, user_or_role] ... [WITH ADMIN OPTION]object_type: &#123; TABLE | FUNCTION | PROCEDURE&#125;priv_level: &#123; * | *.* | db_name.* | db_name.tbl_name | tbl_name | db_name.routine_name&#125;user_or_role: &#123; user | role&#125;user: (see http://dev.mysql.com/doc/refman/8.0/en/account-names.html)role: (see http://dev.mysql.com/doc/refman/8.0/en/role-names.html.auth_option: &#123; IDENTIFIED BY 'auth_string' | IDENTIFIED WITH auth_plugin | IDENTIFIED WITH auth_plugin BY 'auth_string' | IDENTIFIED WITH auth_plugin AS 'hash_string' | IDENTIFIED BY PASSWORD 'hash_string'&#125;tls_option: &#123; SSL | X509 | CIPHER 'cipher' | ISSUER 'issuer' | SUBJECT 'subject'&#125;resource_option: &#123; | MAX_QUERIES_PER_HOUR count | MAX_UPDATES_PER_HOUR count | MAX_CONNECTIONS_PER_HOUR count | MAX_USER_CONNECTIONS count&#125;The GRANT statement enables system administrators to grant privilegesand roles, which can be granted to user accounts and roles. Thesesyntax restrictions apply:The GRANT statement enables system administrators to grant privilegesand roles, which can be granted to user accounts and roles. Thesesyntax restrictions apply:o GRANT cannot mix granting both privileges and roles in the same statement. A given GRANT statement must grant either privileges or roles.o The ON clause distinguishes whether the statement grants privileges or roles: o With ON, the statement grants privileges. o Without ON, the statement grants roles. o It is permitted to assign both privileges and roles to an account, but you must use separate GRANT statements, each with syntax appropriate to what is to be granted.For more information about roles, seehttp://dev.mysql.com/doc/refman/8.0/en/roles.html.To use GRANT, you must have the GRANT OPTION privilege, and you musthave the privileges that you are granting. When the read_only systemvariable is enabled, GRANT additionally requires the CONNECTION_ADMINor SUPER privilege.GRANT either succeeds for all named users and roles or rolls back andhas no effect if any error occurs. The statement is written to thebinary log only if it succeeds for all named users and roles.The REVOKE statement is related to GRANT and enables administrators toremove account privileges. See [HELP REVOKE].Each account name uses the format described inhttp://dev.mysql.com/doc/refman/8.0/en/account-names.html. Each rolename uses the format described inhttp://dev.mysql.com/doc/refman/8.0/en/role-names.html. For example:GRANT ALL ON db1.* TO 'jeffrey'@'localhost';GRANT 'role1', 'role2' TO 'user1'@'localhost', 'user2'@'localhost';GRANT SELECT ON world.* TO 'role3';The host name part of the account or role name, if omitted, defaults to'%'.Normally, a database administrator first uses CREATE USER to create anaccount and define its nonprivilege characteristics such as itspassword, whether it uses secure connections, and limits on access toserver resources, then uses GRANT to define its privileges. ALTER USERmay be used to change the nonprivilege characteristics of existingaccounts. For example:CREATE USER 'jeffrey'@'localhost' IDENTIFIED BY 'password';GRANT ALL ON db1.* TO 'jeffrey'@'localhost';GRANT SELECT ON db2.invoice TO 'jeffrey'@'localhost';ALTER USER 'jeffrey'@'localhost' WITH MAX_QUERIES_PER_HOUR 90;*Note*:As of MySQL 8.0.11, GRANT is used only for defining account privileges.the REQUIRE clause, WITH clause as used for setting resource limits,and the IDENTIFIED clause have been removed, and it is no longerpossible to use GRANT to modify nonprivilege account characteristics.This includes using GRANT to create accounts or specify characteristicssuch as passwords, whether accounts use secure connections, and limitson access to server resources. Instead, perform these tasks usingCREATE USER or ALTER USER.From the mysql program, GRANT responds with Query OK, 0 rows affectedwhen executed successfully. To determine what privileges result fromthe operation, use SHOW GRANTS. See [HELP SHOW GRANTS].URL: http://dev.mysql.com/doc/refman/8.0/en/grant.htmlmysql&gt; 数据库和创建数据库123456789101112131415161718192021222324252627mysql&gt; help databases;Many help items for your request exist.To make a more specific request, please type 'help &lt;item&gt;',where &lt;item&gt; is one of the followingtopics: SHOW SHOW DATABASESmysql&gt; help create database;Name: 'CREATE DATABASE'Description:Syntax:CREATE &#123;DATABASE | SCHEMA&#125; [IF NOT EXISTS] db_name [create_specification] ...create_specification: [DEFAULT] CHARACTER SET [=] charset_name | [DEFAULT] COLLATE [=] collation_nameCREATE DATABASE creates a database with the given name. To use thisstatement, you need the CREATE privilege for the database. CREATESCHEMA is a synonym for CREATE DATABASE.URL: http://dev.mysql.com/doc/refman/8.0/en/create-database.htmlmysql&gt; 创建表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194mysql&gt; help create table;Name: 'CREATE TABLE'Description:Syntax:CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name (create_definition,...) [table_options] [partition_options]CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name [(create_definition,...)] [table_options] [partition_options] [IGNORE | REPLACE] [AS] query_expressionCREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name &#123; LIKE old_tbl_name | (LIKE old_tbl_name) &#125;create_definition: col_name column_definition | [CONSTRAINT [symbol]] PRIMARY KEY [index_type] (index_col_name,...) [index_option] ... | &#123;INDEX|KEY&#125; [index_name] [index_type] (index_col_name,...) [index_option] ... | [CONSTRAINT [symbol]] UNIQUE [INDEX|KEY] [index_name] [index_type] (index_col_name,...) [index_option] ... | &#123;FULLTEXT|SPATIAL&#125; [INDEX|KEY] [index_name] (index_col_name,...) [index_option] ... | [CONSTRAINT [symbol]] FOREIGN KEY [index_name] (index_col_name,...) reference_definition | CHECK (expr)column_definition: data_type [NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT] [UNIQUE [KEY]] [[PRIMARY] KEY] [COMMENT 'string'] [COLUMN_FORMAT &#123;FIXED|DYNAMIC|DEFAULT&#125;] [reference_definition] | data_type [GENERATED ALWAYS] AS (expression) [VIRTUAL | STORED] [NOT NULL | NULL] [UNIQUE [KEY]] [[PRIMARY] KEY] [COMMENT 'string']data_type: BIT[(length)] | TINYINT[(length)] [UNSIGNED] [ZEROFILL] | SMALLINT[(length)] [UNSIGNED] [ZEROFILL] | MEDIUMINT[(length)] [UNSIGNED] [ZEROFILL] | INT[(length)] [UNSIGNED] [ZEROFILL] | INTEGER[(length)] [UNSIGNED] [ZEROFILL] | BIGINT[(length)] [UNSIGNED] [ZEROFILL] | REAL[(length,decimals)] [UNSIGNED] [ZEROFILL] | DOUBLE[(length,decimals)] [UNSIGNED] [ZEROFILL] | FLOAT[(length,decimals)] [UNSIGNED] [ZEROFILL] | DECIMAL[(length[,decimals])] [UNSIGNED] [ZEROFILL] | NUMERIC[(length[,decimals])] [UNSIGNED] [ZEROFILL] | DATE | TIME[(fsp)] | TIMESTAMP[(fsp)] | DATETIME[(fsp)] | YEAR | CHAR[(length)] [CHARACTER SET charset_name] [COLLATE collation_name] | VARCHAR(length) [CHARACTER SET charset_name] [COLLATE collation_name] | BINARY[(length)] | VARBINARY(length) | TINYBLOB | BLOB[(length)] | MEDIUMBLOB | LONGBLOB | TINYTEXT [CHARACTER SET charset_name] [COLLATE collation_name] | TEXT[(length)] [CHARACTER SET charset_name] [COLLATE collation_name] | MEDIUMTEXT [CHARACTER SET charset_name] [COLLATE collation_name] | LONGTEXT [CHARACTER SET charset_name] [COLLATE collation_name] | ENUM(value1,value2,value3,...) [CHARACTER SET charset_name] [COLLATE collation_name] | SET(value1,value2,value3,...) [CHARACTER SET charset_name] [COLLATE collation_name] | JSON | spatial_typeindex_col_name: col_name [(length)] [ASC | DESC]index_type: USING &#123;BTREE | HASH&#125;index_option: KEY_BLOCK_SIZE [=] value | index_type | WITH PARSER parser_name | COMMENT 'string' | &#123;VISIBLE | INVISIBLE&#125;reference_definition: REFERENCES tbl_name (index_col_name,...) [MATCH FULL | MATCH PARTIAL | MATCH SIMPLE] [ON DELETE reference_option] [ON UPDATE reference_option]reference_option: RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULTtable_options: table_option [[,] table_option] ...table_option: AUTO_INCREMENT [=] value | AVG_ROW_LENGTH [=] value | [DEFAULT] CHARACTER SET [=] charset_name | CHECKSUM [=] &#123;0 | 1&#125; | [DEFAULT] COLLATE [=] collation_name | COMMENT [=] 'string' | COMPRESSION [=] &#123;'ZLIB'|'LZ4'|'NONE'&#125; | CONNECTION [=] 'connect_string' | &#123;DATA|INDEX&#125; DIRECTORY [=] 'absolute path to directory' | DELAY_KEY_WRITE [=] &#123;0 | 1&#125; | ENCRYPTION [=] &#123;'Y' | 'N'&#125; | ENGINE [=] engine_name | INSERT_METHOD [=] &#123; NO | FIRST | LAST &#125; | KEY_BLOCK_SIZE [=] value | MAX_ROWS [=] value | MIN_ROWS [=] value | PACK_KEYS [=] &#123;0 | 1 | DEFAULT&#125; | PASSWORD [=] 'string' | ROW_FORMAT [=] &#123;DEFAULT|DYNAMIC|FIXED|COMPRESSED|REDUNDANT|COMPACT&#125; | STATS_AUTO_RECALC [=] &#123;DEFAULT|0|1&#125; | STATS_PERSISTENT [=] &#123;DEFAULT|0|1&#125; | STATS_SAMPLE_PAGES [=] value | TABLESPACE tablespace_name | UNION [=] (tbl_name[,tbl_name]...)partition_options: PARTITION BY &#123; [LINEAR] HASH(expr) | [LINEAR] KEY [ALGORITHM=&#123;1|2&#125;] (column_list) | RANGE&#123;(expr) | COLUMNS(column_list)&#125; | LIST&#123;(expr) | COLUMNS(column_list)&#125; &#125; [PARTITIONS num] [SUBPARTITION BY &#123; [LINEAR] HASH(expr) | [LINEAR] KEY [ALGORITHM=&#123;1|2&#125;] (column_list) &#125; [SUBPARTITIONS num] ] [(partition_definition [, partition_definition] ...)]partition_definition: PARTITION partition_name [VALUES &#123;LESS THAN &#123;(expr | value_list) | MAXVALUE&#125; | IN (value_list)&#125;] [[STORAGE] ENGINE [=] engine_name] [COMMENT [=] 'string' ] [DATA DIRECTORY [=] 'data_dir'] [INDEX DIRECTORY [=] 'index_dir'] [MAX_ROWS [=] max_number_of_rows] [MIN_ROWS [=] min_number_of_rows] [TABLESPACE [=] tablespace_name] [(subpartition_definition [, subpartition_definition] ...)]subpartition_definition: SUBPARTITION logical_name [[STORAGE] ENGINE [=] engine_name] [COMMENT [=] 'string' ] [DATA DIRECTORY [=] 'data_dir'] [INDEX DIRECTORY [=] 'index_dir'] [MAX_ROWS [=] max_number_of_rows] [MIN_ROWS [=] min_number_of_rows] [TABLESPACE [=] tablespace_name]query_expression: SELECT ... (Some valid select or union statement)CREATE TABLE creates a table with the given name. You must have theCREATE privilege for the table.By default, tables are created in the default database, using theInnoDB storage engine. An error occurs if the table exists, if there isno default database, or if the database does not exist.For information about the physical representation of a table, seehttp://dev.mysql.com/doc/refman/8.0/en/create-table-files.html.URL: http://dev.mysql.com/doc/refman/8.0/en/create-table.htmlmysql&gt; 版权声明：博客中的文章版权归博主所有，未经授权，禁止转载，转载请注明出处，合作请点击“关于我”，扫码添加微信","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"MySQL数据库","slug":"MySQL数据库","permalink":"http://yoursite.com/tags/MySQL数据库/"}]},{"title":"Mac安装MySQL 8.0","slug":"Mac安装MySQL 8.0版本","date":"2018-07-27T13:29:00.000Z","updated":"2018-08-24T05:29:28.476Z","comments":true,"path":"2018/07/27/Mac安装MySQL 8.0版本/","link":"","permalink":"http://yoursite.com/2018/07/27/Mac安装MySQL 8.0版本/","excerpt":"整理：房玉辉","text":"整理：房玉辉 博客：https://ElonJelinek.github.io用Homebrew安装MySQL打开终端，输入命令：brew install mysql 1234567891011121314151617181920ElonJelinek:~ ElonJelinek$ brew install mysql==&gt; Downloading https://homebrew.bintray.com/bottles/mysql-8.0.12.high_sierra.boAlready downloaded: /Users/ElonJelinek/Library/Caches/Homebrew/mysql--8.0.12.high_sierra.bottle.tar.gz==&gt; Pouring mysql--8.0.12.high_sierra.bottle.tar.gz==&gt; /usr/local/Cellar/mysql/8.0.12/bin/mysqld --initialize-insecure --user=ElonJ==&gt; CaveatsWe've installed your MySQL database without a root password. To secure it run: mysql_secure_installationMySQL is configured to only allow connections from localhost by defaultTo connect run: mysql -urootTo have launchd start mysql now and restart at login: brew services start mysqlOr, if you don't want/need a background service you can just run: mysql.server start==&gt; Summary🍺 /usr/local/Cellar/mysql/8.0.12: 255 files, 233.0MB 启动MySQL服务：brew services start mysql 12ElonJelinek:~ ElonJelinek$ brew services start mysqlService `mysql` already started, use `brew services restart mysql` to restart. 设置开机启动：launchctl load ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist 12ElonJelinek:~ ElonJelinek$ launchctl load ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist/Users/ElonJelinek/Library/LaunchAgents/homebrew.mxcl.mysql.plist: service already loaded 用root用户登录MySQL：mysql -uroot 1234567891011121314ElonJelinek:~ ElonJelinek$ mysql -urootWelcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 8Server version: 8.0.12 HomebrewCopyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.mysql&gt; 一些简单操作，注意每一个命令都以分号;结束。查看版本：select version(); 1234567mysql&gt; select version();+-----------+| version() |+-----------+| 8.0.12 |+-----------+1 row in set (0.00 sec) 查看当前时间：select now(); 1234567mysql&gt; select now();+---------------------+| now() |+---------------------+| 2018-07-27 19:45:13 |+---------------------+1 row in set (0.00 sec) 查看所有的数据库：show databases; 12345678910mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sys |+--------------------+4 rows in set (0.00 sec) 查看当前所进入的数据库，即当前正在使用的数据库：select database(); 由于当前没有进入任何一个数据库，所以结果为null 1234567mysql&gt; select database();+------------+| database() |+------------+| NULL |+------------+1 row in set (0.00 sec) 查看数据库中的表：show tables; 由于当前并没有进入任何一个数据库，所以查不到表 123mysql&gt; show tables;ERROR 1046 (3D000): No database selectedmysql&gt; 修改root用户密码：ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;123456&#39;; 12mysql&gt; ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123456';Query OK, 0 rows affected (0.01 sec) 退出：exit 12345678910111213141516171819202122232425262728mysql&gt; exitByeElonJelinek:~ ElonJelinek$``` 重新登录，此时已经为root用户设置了密码：123456，因此，用用户名加密码方式登录：`mysql -u root -p`回车后，输入密码`123456` （这里并不显示输入的密码，直接输入123456并回车就OK。）```goElonJelinek:~ ElonJelinek$ mysql -u root -p Enter password: Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 13Server version: 8.0.12 HomebrewCopyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.mysql&gt; 选择一个数据库首次安装后，会有四个数据库，这里我们选择mysql这个库 use mysql; 1234567891011121314mysql&gt; use mysql;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; select database();+------------+| database() |+------------+| mysql |+------------+1 row in set (0.00 sec)mysql&gt; 查看mysql库里的所有表： show tables; 1234567891011121314151617181920212223242526272829303132333435363738394041mysql&gt; show tables;+---------------------------+| Tables_in_mysql |+---------------------------+| columns_priv || component || db || default_roles || engine_cost || func || general_log || global_grants || gtid_executed || help_category || help_keyword || help_relation || help_topic || innodb_index_stats || innodb_table_stats || password_history || plugin || procs_priv || proxies_priv || role_edges || server_cost || servers || slave_master_info || slave_relay_log_info || slave_worker_info || slow_log || tables_priv || time_zone || time_zone_leap_second || time_zone_name || time_zone_transition || time_zone_transition_type || user |+---------------------------+33 rows in set (0.01 sec)mysql&gt; 默认有33张表。 本节到此结束，下一次开始进行数据库、表的增删改查。 版权声明：博客中的文章版权归博主所有，未经授权，禁止转载，转载请注明出处，合作请点击“关于我”，扫码添加微信","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"MySQL数据库","slug":"MySQL数据库","permalink":"http://yoursite.com/tags/MySQL数据库/"}]},{"title":"go解析复杂json数据","slug":"go解析复杂json数据","date":"2018-05-12T13:08:00.000Z","updated":"2018-09-26T11:17:56.837Z","comments":true,"path":"2018/05/12/go解析复杂json数据/","link":"","permalink":"http://yoursite.com/2018/05/12/go解析复杂json数据/","excerpt":"整理：房玉辉","text":"整理：房玉辉 博客：https://ElonJelinek.github.io用go解析多层嵌套json数据，数据来源https://api.coinmarketcap.com/v2/ticker/数据示例 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package mainimport ( \"encoding/json\" \"fmt\" \"log\" \"net/http\")type coinmarketcap struct &#123; DATA Data `json:\"data\"` MD Metadata `json:\"metadata\"`&#125;type Metadata struct &#123; Timestamp int `json:\"timestamp\"` Num int `json:\"num_cryptocurrencies\"` Error error `json:\"error\"`&#125;type Coin struct &#123; Id int `json:\"id\"` Name string `json:\"name\"` Symbol string `json:\"symbol\"` Website string `json:\"website_slug\"` Rank int `json:\"rank\"` Circulating float32 `json:\"circulating_supply\"` Total float32 `json:\"total_supply\"` QUotes Quotes `json:\"quotes\"` Update int `json:\"last_updated\"`&#125;type Data struct &#123; COin Coin `json:\"1027\"`&#125;type Quotes struct &#123; USD Usd `json:\"USD\"`&#125;type Usd struct &#123; Price float64 `json:\"price\"` Volume float64 `json:\"volume_24h\"` MarketCap float32 `json:\"market_cap\"` Percent1h float32 `json:\"percent_change_1h\"` Percent24h float32 `json:\"percent_change_24h\"` Percent7d float32 `json:\"percent_change_7d\"`&#125;func main() &#123; url := \"https://api.coinmarketcap.com/v2/ticker/\" resp, err := http.Get(url) if err != nil &#123; log.Println(\"ERROR:\", err) return &#125; defer resp.Body.Close() var cm coinmarketcap // 将json串反序列化到结构体cm中 err = json.NewDecoder(resp.Body).Decode(&amp;cm) if err != nil &#123; log.Println(\"ERROR:\", err) return &#125;// 打印结构体对象cm fmt.Println(cm)// 将结构体对象cm转为json串 jsData, err := json.Marshal(cm) if err != nil &#123; fmt.Println(\"%s\", err) return &#125; // 打印json串 fmt.Println(string(jsData))&#125; 运行结果 12&#123;&#123;&#123;1027 Ethereum ETH ethereum 2 1.0217674e+08 1.0217674e+08 &#123;&#123;208.370687119 1.89967509491939e+09 2.1290637e+10 -1.21 -10.96 1.95&#125;&#125; 1537877260&#125;&#125; &#123;1537876696 1993 &lt;nil&gt;&#125;&#125;&#123;\"data\":&#123;\"1027\":&#123;\"id\":1027,\"name\":\"Ethereum\",\"symbol\":\"ETH\",\"website_slug\":\"ethereum\",\"rank\":2,\"circulating_supply\":102176740,\"total_supply\":102176740,\"quotes\":&#123;\"USD\":&#123;\"price\":208.370687119,\"volume_24h\":1899675094.91939,\"market_cap\":21290637000,\"percent_change_1h\":-1.21,\"percent_change_24h\":-10.96,\"percent_change_7d\":1.95&#125;&#125;,\"last_updated\":1537877260&#125;&#125;,\"metadata\":&#123;\"timestamp\":1537876696,\"num_cryptocurrencies\":1993,\"error\":null&#125;&#125; 另一种写法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package mainimport ( \"encoding/json\" \"fmt\" \"io/ioutil\" \"log\" \"net/http\")type coinmarketcap struct &#123; DATA Data `json:\"data\"` MD Metadata `json:\"metadata\"`&#125;type Metadata struct &#123; Timestamp int `json:\"timestamp\"` Num int `json:\"num_cryptocurrencies\"` Error error `json:\"error\"`&#125;type Coin struct &#123; Id int `json:\"id\"` Name string `json:\"name\"` Symbol string `json:\"symbol\"` Website string `json:\"website_slug\"` Rank int `json:\"rank\"` Circulating float32 `json:\"circulating_supply\"` Total float32 `json:\"total_supply\"` QUotes Quotes `json:\"quotes\"` Update int `json:\"last_updated\"`&#125;type Data struct &#123; COin Coin `json:\"1027\"`&#125;type Quotes struct &#123; USD Usd `json:\"USD\"`&#125;type Usd struct &#123; Price float64 `json:\"price\"` Volume float64 `json:\"volume_24h\"` MarketCap float32 `json:\"market_cap\"` Percent1h float32 `json:\"percent_change_1h\"` Percent24h float32 `json:\"percent_change_24h\"` Percent7d float32 `json:\"percent_change_7d\"`&#125;func main() &#123; url := \"https://api.coinmarketcap.com/v2/ticker/\" resp, err := http.Get(url) if err != nil &#123; log.Println(\"ERROR:\", err) return &#125; defer resp.Body.Close() var cm coinmarketcap // 解析HTTP响应 b, err := ioutil.ReadAll(resp.Body) if err != nil &#123; log.Println(\"ERROR:\", err) return &#125; // 将解析到的byte数组，反序列化到结构体对象中 err = json.Unmarshal(b, &amp;cm) // 打印结构体对象 fmt.Println(cm) // 再将结构体对象转为json串 jsData, err := json.Marshal(cm) if err != nil &#123; fmt.Println(\"%s\", err) return &#125; // 打印json串 fmt.Println(string(jsData))&#125; 运行结果 12&#123;&#123;&#123;1027 Ethereum ETH ethereum 2 1.0217727e+08 1.0217727e+08 &#123;&#123;210.279432658 1.92356647022044e+09 2.1485779e+10 1.19 -10.19 2.56&#125;&#125; 1537879535&#125;&#125; &#123;1537878974 1993 &lt;nil&gt;&#125;&#125;&#123;\"data\":&#123;\"1027\":&#123;\"id\":1027,\"name\":\"Ethereum\",\"symbol\":\"ETH\",\"website_slug\":\"ethereum\",\"rank\":2,\"circulating_supply\":102177270,\"total_supply\":102177270,\"quotes\":&#123;\"USD\":&#123;\"price\":210.279432658,\"volume_24h\":1923566470.22044,\"market_cap\":21485779000,\"percent_change_1h\":1.19,\"percent_change_24h\":-10.19,\"percent_change_7d\":2.56&#125;&#125;,\"last_updated\":1537879535&#125;&#125;,\"metadata\":&#123;\"timestamp\":1537878974,\"num_cryptocurrencies\":1993,\"error\":null&#125;&#125; 这里还有一个问题没有解决，就是data的下一层，每一个标签都不一样，暂时还没想到要怎么解析这样的数据，暂时留待日后解决。 版权声明：博客中的文章版权归博主所有，未经授权，禁止转载，转载请注明出处，合作请点击“关于我”，扫码添加微信","categories":[{"name":"go语言","slug":"go语言","permalink":"http://yoursite.com/categories/go语言/"}],"tags":[{"name":"json解析","slug":"json解析","permalink":"http://yoursite.com/tags/json解析/"}]},{"title":"在本地网络部署super—dictionary智能合约","slug":"在localhost部署super—dictionary智能合约","date":"2018-05-03T11:10:00.000Z","updated":"2018-07-28T10:45:10.196Z","comments":true,"path":"2018/05/03/在localhost部署super—dictionary智能合约/","link":"","permalink":"http://yoursite.com/2018/05/03/在localhost部署super—dictionary智能合约/","excerpt":"整理：房玉辉","text":"整理：房玉辉 博客：https://ElonJelinek.github.io星云链Dapp开发系列在本地网络（localhost）部署super-dictionary智能合约super-dictionary智能合约源码下载地址：https://github.com/15010159959/super-dictionary 1、解决本地交易网络错误问题：进入go/src/github.com/nebulasio/go-nebulas/conf/default文件夹，打开config.conf文件，找到以下代码： 1234567rpc &#123; rpc_listen: [\"0.0.0.0:8684\"] http_listen: [\"0.0.0.0:8685\"] http_module: [\"api\",\"admin\"] # HTTP CORS allowed origins # http_cors: []&#125; 去掉最后一行代码的注释，并更改如下：http_cors: [&quot;*&quot;] 2、进入super-dictionary-master/lib文件夹：打开nebPay.js文件：找到第四行代码：var payUrl = &quot;http://18.221.150.42/api/pay&quot;;更改为：var payUrl = &quot;http://localhost:8685/api/pay&quot;; 3、启动节点：打开第一个终端窗口，启动第一个星云节点： 12cd $GOPATH/src/github.com/nebulasio/go-nebulas./neb -c conf/default/config.conf 再打开一个终端窗口，启动第一个矿工节点： 12cd $GOPATH/src/github.com/nebulasio/go-nebulas./neb -c conf/example/miner.conf 4、部署合约：打开web-wallet钱包，部署super-dictionary智能合约到星云链localhost网络：进入web-wallet文件夹，用浏览器打开index.html文件，点击合约，再点击部署，找到super-dictionary-master/smartContract文件夹下的super-dictionary.js文件，将全部代码粘贴到合约代码框内：选择钱包文件，输入密码，点击解锁，再点击测试，再点击提交：保存好合约地址：n1wfeKn7GSjo8GbAE64CgUPyxwqLrpWWLnK点击交易哈希，查看交易状态，下图为部署成功： 5、执行、调用合约，与前端交互：进入super-dictionary-master文件夹，用开发工具打开index.html文件，找到第190行代码，将合约地址粘贴过来：var dappAddress = &quot;n1wfeKn7GSjo8GbAE64CgUPyxwqLrpWWLnK&quot;;保存后，用浏览器打开index.html文件，随便输入“比特币”一词，可以看到，没有释义，但是底下有一句话： Failed to find related information. Do you want to add infromation for “比特币”? 并且add可以点击，点击add后可以添加释义，输入如下释义：“比特币（BitCoin）的概念最初由中本聪在2009年提出，根据中本聪的思路设计发布的开源软件以及建构其上的P2P网络。比特币是一种P2P形式的数字货币。”点击submit，之后会弹出WebExtensionWallet钱包页面，选择localhost当地钱包文件，输入密码“passphrase”，点击生成交易，再点击交易确认，正在打包：交易打包成功：查询，如图所示：至此，super-dictionary智能合约部署成功，前端调用合约成功。 版权声明：博客中的文章版权归博主所有，未经授权，禁止转载，转载请注明出处，合作请点击“关于我”，扫码添加微信","categories":[{"name":"智能合约","slug":"智能合约","permalink":"http://yoursite.com/categories/智能合约/"}],"tags":[{"name":"星云链Dapp开发","slug":"星云链Dapp开发","permalink":"http://yoursite.com/tags/星云链Dapp开发/"}]},{"title":"在星云链测试网部署super-dictionary智能合约","slug":"在星云链测试网部署super-dictionary智能合约","date":"2018-05-02T12:02:13.000Z","updated":"2018-07-28T10:44:51.844Z","comments":true,"path":"2018/05/02/在星云链测试网部署super-dictionary智能合约/","link":"","permalink":"http://yoursite.com/2018/05/02/在星云链测试网部署super-dictionary智能合约/","excerpt":"整理：房玉辉","text":"整理：房玉辉 博客：https://ElonJelinek.github.io星云链Dapp开发系列在星云链测试网部署super-dictionary智能合约工具：Goland，Chrome，WebExtensionWallet插件钱包super-dictionary智能合约源码下载地址：https://github.com/15010159959/super-dictionary 1、下载星云链官方钱包：到GitHub的星云官方库下载web-wallet钱包https://github.com/nebulasio/web-wallet，用谷歌浏览器打开文件包里的index.html，点击右上角，选择testnet网络，再新建钱包，牢记密码，并下载保存好密码库文件，申请测试币https://testnet.nebulas.io/claim/ 2、在谷歌浏览器上安装WebExtensionWallet插件钱包，有详细安装攻略。3、部署合约下载super-dictionary智能合约：https://github.com/15010159959/super-dictionary打开super-dictionary-master/smartcontract文件夹下的super_dictionary.js文件，复制全部代码，打开web-wallet文件夹里的index.html文件，点击右上角选择Testnet测试网络，点击合约——部署，粘贴全部代码到合约部署框内，选择钱包文件，输入密码，点击解锁，再点击测试，后点击提交，保存好交易哈希和合约地址。合约地址：n1vPTmFsXNGCjZ3Dmf2ngEEyUeut7pqebaJ用goland开发工具打开super-dictionary-master文件夹下的index.html，找到第190行，把合约地址粘贴过去并保存：var dappAddress = &quot;n1vPTmFsXNGCjZ3Dmf2ngEEyUeut7pqebaJ&quot;; 4、执行合约：用谷歌浏览器打开super-dictionary-master文件夹下的index.html，点击浏览器右上角的插件钱包，选择Testnet测试网络，搜索“金庸”，可以看到没有释义，而输入框下面出现一句话，Failed to find related information. Do you want to add infromation for “金庸”?点击add添加释义，点击submit提交后，就会弹出插件钱包，选择钱包，输入密码，,点击生成交易，点击确认，大概一分钟后，交易成功，最后再次查询“金庸“，已经有了释义，如此，合约部署成功。执行合约成功。 版权声明：博客中的文章版权归博主所有，未经授权，禁止转载，转载请注明出处，合作请点击“关于我”，扫码添加微信","categories":[{"name":"智能合约","slug":"智能合约","permalink":"http://yoursite.com/categories/智能合约/"}],"tags":[{"name":"星云链Dapp开发","slug":"星云链Dapp开发","permalink":"http://yoursite.com/tags/星云链Dapp开发/"},{"name":"super-dictionary智能合约","slug":"super-dictionary智能合约","permalink":"http://yoursite.com/tags/super-dictionary智能合约/"}]},{"title":"shell脚本语言","slug":"shell脚本语言","date":"2018-04-29T08:10:00.000Z","updated":"2018-09-24T07:45:37.658Z","comments":true,"path":"2018/04/29/shell脚本语言/","link":"","permalink":"http://yoursite.com/2018/04/29/shell脚本语言/","excerpt":"整理：房玉辉","text":"整理：房玉辉 博客：https://ElonJelinek.github.iowhile循环嵌套case语句1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071# COUNTER=0# while [ $COUNTER -le 5 ] ;# do# echo $COUNTER# let COUNTER++# done## ========================我是调皮的分割线==========================## echo -e \"\\n-le 和 -lt 的却别：-le表示小于等于\\n\"# less equal less than## COUNTER=0# while [ $COUNTER -lt 5 ] ;# do# echo $COUNTER# let COUNTER++# done## ========================我是调皮的分割线==========================## echo 'type &lt;CTRL-D&gt; to terminate'# echo -n 'enter your most liked film: ' # -n表示取消行末的换行符# while read FILM# do# echo \"Yeah! great film the $FILM\"# done## ========================我是调皮的分割线==========================##!/bin/bash# 执行之后只能用组合键Ctrl+C来终止它。 # ========================下面是死循环，慎用！慎用！慎用！==========================# while :# do# echo I love you forever# done## ========================上面是死循环，慎用！慎用！慎用！==========================#!/bin/bash# ========================这也是死循环，慎用！慎用！慎用！==========================# while true# do # echo I love you forever# done# ========================这也是死循环，慎用！慎用！慎用！==========================echo \"I love you forever\"# ========================我是调皮的分割线==========================while :do echo echo \"====================\" echo \" 1：学习九阴真经\" echo \" 2：学习九阳真经\" echo \" 3：学习独孤九剑\" echo \" q或Q：退出江湖\" echo \"====================\" read -p \"请选择：\" input case $input in 1) echo -e \"\\n\\n 学习九阴真经\\n\" ;; 2) echo -e \"\\n\\n 学习九阳真经\\n\" ;; 3) echo -e \"\\n\\n 学习独孤九剑\\n\" ;; q | Q) exit ;; esac #statementsdone# ========================我是调皮的分割线========================== 运行结果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647ElonJelinek:Desktop ElonJelinek$ ./test.sh I love you forever==================== 1：学习九阴真经 2：学习九阳真经 3：学习独孤九剑 q或Q：退出江湖====================请选择：3 学习独孤九剑==================== 1：学习九阴真经 2：学习九阳真经 3：学习独孤九剑 q或Q：退出江湖====================请选择：1 学习九阴真经==================== 1：学习九阴真经 2：学习九阳真经 3：学习独孤九剑 q或Q：退出江湖====================请选择：2 学习九阳真经==================== 1：学习九阴真经 2：学习九阳真经 3：学习独孤九剑 q或Q：退出江湖====================请选择：qElonJelinek:Desktop ElonJelinek$ while循环嵌套if语句123456789101112131415161718192021222324# #!/bin/bash# #从/etc/passwd文件中读取用户名并输出# oldIFS=$IFS #IFS是文件内部分隔符# IFS=\":\" #设置分隔符为:# while read username var #var变量不可少# do# echo \"用户名:$username\"# done &lt; /etc/passwd# IFS=$oldIFS#!/bin/bash#每隔一段时间，ping一下局域网内本机IP，#并把结果记录到ping.txt文件中while datedo ping -c5 127.0.0.1 &gt;/dev/null 2&gt;&amp;1 if [ $? = 0 ];then echo OK else echo FAIL fi sleep 6 #6秒done &gt; ping.txt 打开ping.txt，可以看到，其中记录了ping的时间和结果。 for循环，求1到100的和123456789#!/bin/bashsum=0for i in `seq 1 100`do sum=$[$sum+$i]doneecho $sum 运行，结果为：5050 while嵌套if语句12345678910111213141516171819202122#/bin/bashwhile :doread -p \"please input a number: \" n if [ -z \"$n\" ] then echo \"输入不能为空。\" continue fi n1=`echo $n|sed 's/[0-9]//g'` if [ ! -z \"$n1\" ] then echo \"只能输入数字。\" continue fibreakdoneecho \"您输入的是：$n\" 运行结果 12345678ElonJelinek:Desktop ElonJelinek$ ./test.sh please input a number: 输入不能为空。please input a number: h只能输入数字。please input a number: 8您输入的是：8ElonJelinek:Desktop ElonJelinek$ until循环12345678#!/bin/basha=0until [[ ! $a -lt 10 ]];do echo -e \"$a\\t\" a=`expr $a + 1`done 运行结果 123456789101112ElonJelinek:Desktop ElonJelinek$ ./test.sh 0 1 2 3 4 5 6 7 8 9 ElonJelinek:Desktop ElonJelinek$ while循环嵌套case，break跳出循环12345678910111213#!/bin/bashwhile : ;do read -p \"please input a number between 1 to 5: \" aNum # read aNum case $aNum in 1|2|3|4|5) echo \"Your number is $aNum\" ;; *) echo \"You do not select a number between 1 to 5,game over.\" break ;; esacdone 运行结果 12345678ElonJelinek:Desktop ElonJelinek$ ./test.sh please input a number between 1 to 5: 3Your number is 3please input a number between 1 to 5: 5Your number is 5please input a number between 1 to 5: 0You do not select a number between 1 to 5,game over.ElonJelinek:Desktop ElonJelinek$ break跳出for循环break后面可以跟整数，表示跳出第几层循环 1234567891011121314#!/bin/bashfor var1 in 1 2 3do for var2 in 0 5 do if [ $var1 -eq 3 -a $var2 -eq 0 ] then break 2 else echo \"$var1 $var2\" fi donedone 运行结果 123456ElonJelinek:Desktop ElonJelinek$ ./test.sh 1 01 52 02 5ElonJelinek:Desktop ElonJelinek$ continue跳过当前循环continue后面也可以跟整数，表示跳过第几层循环 1234567891011121314#!/bin/shNUMS=\"1 2 3 4 5 6 7\"for NUM in $NUMSdo Q=`expr $NUM % 2` if [[ $Q -eq 0 ]]; then echo \"$NUM Number is an even number!!\" continue fi echo \"Found odd number\"done 运行结果 123456789ElonJelinek:Desktop ElonJelinek$ ./test.sh Found odd number2 Number is an even number!!Found odd number4 Number is an even number!!Found odd number6 Number is an even number!!Found odd numberElonJelinek:Desktop ElonJelinek$ shell函数函数调用不需要括号，函数的返回值只能是数字。 123456789101112131415161718192021Hello () &#123; echo \"流水今日，明月前身。\"&#125;HelloHellofunWithReturn()&#123; echo \"The function is to get the sum of two number...\" echo \"Input first number: \" read numA echo \"Input second number: \" read numB echo \"The two numbers are $numA and $numB !\" return $(($numA+$numB))&#125;funWithReturnret=$?echo \"The sum of two numbers is $ret !\" 运行结果 1234567891011ElonJelinek:Desktop ElonJelinek$ ./test.sh 流水今日，明月前身。流水今日，明月前身。The function is to get the sum of two number...Input first number: 3Input second number: 5The two numbers are 3 and 5 !The sum of two numbers is 8 !ElonJelinek:Desktop ElonJelinek$ 函数嵌套调用12345678910fun1() &#123; echo -n \"人生几回伤往事，\"&#125;fun2() &#123; fun1 echo \"山形依旧枕寒流。\"&#125;fun2 运行结果，-n表示取消行末的换行符 123ElonJelinek:Desktop ElonJelinek$ ./test.sh 人生几回伤往事，山形依旧枕寒流。ElonJelinek:Desktop ElonJelinek$ 取消函数设置：unset 函数名 12345678910111213fun1() &#123; echo -n \"人生几回伤往事，\"&#125;fun2() &#123; fun1 echo \"山形依旧枕寒流。\"&#125;fun2unset fun1fun2 运行结果 12345ElonJelinek:Desktop ElonJelinek$ ./test.sh 人生几回伤往事，山形依旧枕寒流。./test.sh: line 6: fun1: command not found山形依旧枕寒流。ElonJelinek:Desktop ElonJelinek$ 函数参数12345678910funWithParam() &#123; echo \"The value of the first parameter is $1 !\" echo \"The value of the second parameter is $2 !\" echo \"The value of the tenth parameter is $10 !\" echo \"The value of the tenth parameter is $&#123;10&#125; !\" echo \"The value of the eleventh parameter is $&#123;11&#125; !\" echo \"The amount of the parameters is $# !\" echo \"The string of the parameters is $* !\"&#125;funWithParam 19 2 3 4 5 6 7 8 9 10 16 运行结果 123456789ElonJelinek:Desktop ElonJelinek$ ./test.sh The value of the first parameter is 19 !The value of the second parameter is 2 !The value of the tenth parameter is 190 !The value of the tenth parameter is 10 !The value of the eleventh parameter is 16 !The amount of the parameters is 11 !The string of the parameters is 19 2 3 4 5 6 7 8 9 10 16 !ElonJelinek:Desktop ElonJelinek$ 注意，10不能获取第十个参数，获取第十个参数需要{10}。当 n&gt;=10 时，需要使用 ${n} 来获取参数。 特殊变量 说明 $# 传递给函数的参数个数。 $* 传给函数的所有参数，被双引号包含时，&quot;$∗&quot;会将所有的参数作为一个整体输出。 $@ 与 $* 相同，被双引号包含时，&quot;$@&quot;会将参数一个个分开输出。 $? 函数的返回值。 输出重定向两个箭头&gt;&gt;表示输出到文件末尾，一个箭头的话，会覆盖原有内容。 123456who &gt; users.txtecho \"I love you forever\" &gt;&gt; users.txtfun1() &#123; echo \"玉勒雕鞍游冶处\"&#125;fun1 &gt;&gt; users.txt 运行结果，终端看不到任何输出，但是当前目录下自动生成了一个users.txt文本文件，打开该文件，输出结果在文件里。内容如下 1234ElonJelinek console Sep 7 09:10 ElonJelinek ttys000 Sep 23 10:57 I love you forever玉勒雕鞍游冶处 shell外部脚本创建第一个脚本subscript.sh，内容如下 1url=\"http://see.xidian.edu.cn/cpp/view/2738.html\" 创建第二个脚本main.sh，内容如下 123#!/bin/bash. ./subscript.shecho $url 执行脚本，过程如下 1234567891011121314151617181920ElonJelinek:Desktop ElonJelinek$ touch subscript.shElonJelinek:Desktop ElonJelinek$ echo url=\"http://see.xidian.edu.cn/cpp/view/2738.html\" &gt; subscript.sh ElonJelinek:Desktop ElonJelinek$ touch main.shElonJelinek:Desktop ElonJelinek$ open main.sh ElonJelinek:Desktop ElonJelinek$ bash -x main.sh + . ./subscript.sh++ url=http://see.xidian.edu.cn/cpp/view/2738.html+ echo http://see.xidian.edu.cn/cpp/view/2738.htmlhttp://see.xidian.edu.cn/cpp/view/2738.htmlElonJelinek:Desktop ElonJelinek$ sh -x main.sh + . ./subscript.sh++ url=http://see.xidian.edu.cn/cpp/view/2738.html+ echo http://see.xidian.edu.cn/cpp/view/2738.htmlhttp://see.xidian.edu.cn/cpp/view/2738.htmlElonJelinek:Desktop ElonJelinek$ ./main.sh-bash: ./main.sh: Permission deniedElonJelinek:Desktop ElonJelinek$ chmod +x main.sh ElonJelinek:Desktop ElonJelinek$ ./main.sh http://see.xidian.edu.cn/cpp/view/2738.htmlElonJelinek:Desktop ElonJelinek$ shell脚本语言看似简单，其实还有很多可学的内容。 版权声明：博客中的文章版权归博主所有，未经授权，禁止转载，转载请注明出处，合作请点击“关于我”，扫码添加微信","categories":[{"name":"脚本语言","slug":"脚本语言","permalink":"http://yoursite.com/categories/脚本语言/"}],"tags":[{"name":"shell脚本语言","slug":"shell脚本语言","permalink":"http://yoursite.com/tags/shell脚本语言/"}]},{"title":"go语言结构体对象与json串的互相转换","slug":"go解析json数据","date":"2018-04-12T12:55:00.000Z","updated":"2018-09-26T12:22:26.482Z","comments":true,"path":"2018/04/12/go解析json数据/","link":"","permalink":"http://yoursite.com/2018/04/12/go解析json数据/","excerpt":"整理：房玉辉","text":"整理：房玉辉 博客：https://ElonJelinek.github.io将结构体对象转为json串1234567891011121314151617181920package mainimport ( \"encoding/json\" \"os\")// 结构体中的字段首字母必须要大写，否则解析不出来，这里相当于是json包在调用person类中的字段，所以首字母必须大写，否则为私有，外部包不可调用type person struct &#123; First string Last string Age int notExported int&#125;func main() &#123; p1 := person&#123;\"James\", \"Bond\", 20, 007&#125; // os.Stdout表示标准输出，Encode是编码，将结构体对象编码为json串 json.NewEncoder(os.Stdout).Encode(p1)&#125; 运行结果 1&#123;\"First\":\"James\",\"Last\":\"Bond\",\"Age\":20&#125; 这里的结果就是json串了，类似于map的key-value，中间有个冒号。 结构体转json串的另一种写法123456789101112131415161718192021222324package mainimport ( \"encoding/json\" \"fmt\")type person struct &#123; First string Last string Age int notExported int&#125;func main() &#123; p1 := person&#123;\"James\", \"Bond\", 20, 007&#125; //json.NewEncoder(os.Stdout).Encode(p1) // 另一种写法，这里Marshal函数的参数是空接口，所以可以将任何类型的数据转为json，比如struct，map，返回值为byte，也就是说可以把任何类型转为byte b, err := json.Marshal(p1) if err != nil &#123; fmt.Printf(\"%s\", err) &#125; fmt.Println(string(b))&#125; 运行结果 1&#123;\"First\":\"James\",\"Last\":\"Bond\",\"Age\":20&#125; 将json串转为结构体1234567891011121314151617181920212223package mainimport ( \"encoding/json\" \"fmt\" \"strings\")type person struct &#123; First string Last string Age int notExported int&#125;func main() &#123; var p1 person rdr := strings.NewReader(`&#123;\"First\":\"James\", \"Last\":\"Bond\", \"Age\":20&#125;`) // 将json串rdr解码到结构体对象p1中 json.NewDecoder(rdr).Decode(&amp;p1) fmt.Println(p1)&#125; 运行结果 1&#123;James Bond 20 0&#125; 直接打印结构体的话，不显示字段名，而且也没有冒号，与json串明显不同。 json转结构体的另一种写法1234567891011121314151617181920212223242526package mainimport ( \"encoding/json\" \"fmt\")type person struct &#123; First string Last string Age int `json:\"wisdom score\"`&#125;func main() &#123; var p1 person fmt.Println(p1) bs := []byte(`&#123;\"First\":\"James\", \"Last\":\"Bond\", \"wisdom score\":20&#125;`) // 将byte反序列化到结构体对象p1中，这里Unmarshal的第一个参数是byte，第二个参数是空接口，但是必须传指针，包括结构体指针，map指针都可以 json.Unmarshal(bs, &amp;p1) fmt.Println(string(bs)) fmt.Println(\"--------------\") fmt.Println(p1)&#125; 运行结果 1234&#123; 0&#125;&#123;\"First\":\"James\", \"Last\":\"Bond\", \"wisdom score\":20&#125;--------------&#123;James Bond 20&#125; json标签1234567891011121314151617181920212223242526package mainimport ( \"encoding/json\" \"fmt\")type person struct &#123; First string Last string //Age int Age int `json:\"ageNumber\"`&#125;func main() &#123; var p1 person fmt.Println(p1) //bs := []byte(`&#123;\"First\":\"James\", \"Last\":\"Bond\", \"Age\":20&#125;`) //json.Unmarshal(bs, &amp;p1) bs := []byte(`&#123;\"First\":\"James\", \"Last\":\"Bond\", \"ageNumber\":20&#125;`) json.Unmarshal(bs, &amp;p1) fmt.Println(p1)&#125; 运行结果 12&#123; 0&#125;&#123;James Bond 20&#125; 注意这段字母的最外面是一个特殊字符，是esc下面那个键~，要在英文状态下输入，不是单引号。 这里Age字段后面的json:&quot;ageNumber&quot;，表示json标签，也就是说json数据的冒号前面的key值，既可以是Age，也可以是ageNumber，比如下面这两个json数据类型，都可以反序列化到结构体对象中：{&quot;First&quot;:&quot;James&quot;, &quot;Last&quot;:&quot;Bond&quot;, &quot;Age&quot;:20}{&quot;First&quot;:&quot;James&quot;, &quot;Last&quot;:&quot;Bond&quot;, &quot;ageNumber&quot;:20}效果是完全一样的。 这里只是最简单的json数据类型，实际中的json数据要复杂得多。比如这样如何解析这样的json数据，请继续关注下一篇文章。 其次，json也可以转为map，同样的map也可以转为json。 版权声明：博客中的文章版权归博主所有，未经授权，禁止转载，转载请注明出处，合作请点击“关于我”，扫码添加微信","categories":[{"name":"go语言","slug":"go语言","permalink":"http://yoursite.com/categories/go语言/"}],"tags":[{"name":"json解析","slug":"json解析","permalink":"http://yoursite.com/tags/json解析/"}]},{"title":"go语言Context包","slug":"go语言Context包","date":"2018-03-30T06:32:18.000Z","updated":"2018-09-19T11:26:05.371Z","comments":true,"path":"2018/03/30/go语言Context包/","link":"","permalink":"http://yoursite.com/2018/03/30/go语言Context包/","excerpt":"整理：房玉辉","text":"整理：房玉辉 博客：https://ElonJelinek.github.ioContext包定义了上下文类型，用来简化在多个goroutine传递上下文数据，终止goroutine树等操作，比如官方http包使用Context传递请求的上下文数据，gRpc使用Context来终止某个请求产生的goroutine树。 Context中的方法是协程安全的，也就是说在父goroutine中创建的Context，可以传递给任意数量的goroutine并让他们同时访问。 Context是个接口，里面有四个方法： Deadline() (deadline time.Time, ok bool)返回一个超时时间time.Time，是当前Context应该结束的时间，ok表示是否有deadline。goroutine获得了超时时间后，可以对某些io操作设定超时时间。 Done() &lt;-chan struct{}返回一个struct类型的只读channel，当该Context被取消的时候，该channel会被关闭，同时对应的使用该Context的goroutine也应该结束并返回，即它是一个表示Context是否已关闭的信号。 Err() error返回Context被取消时的错误，当Done通道关闭后，Err方法表名Context被撤销的原因。 Value(key interface{}) interface{}是Context自带的key-value存储功能，可以让goroutine共享一些数据，并且获得数据也是协程安全的。但使用这些数据的时候要注意同步，比如返回了一个map，而这个map的读写则要加锁。 withcancel和withtimeout函数会返回继承的Context对象，这些对象可以比它们的父Context更早地取消。 一个网络请求超时控制的例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package mainimport ( \"context\" \"fmt\" \"io/ioutil\" \"net/http\" \"time\")type Result struct &#123; r *http.Response err error&#125;func process() &#123; ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second) defer cancel() tr := &amp;http.Transport&#123;&#125; client := &amp;http.Client&#123;Transport: tr&#125; resultChan := make(chan Result, 1) req, err := http.NewRequest(\"GET\", \"https://www.baidu.com\", nil) //req, err := http.NewRequest(\"GET\", 、\"http://www.google.com\", nil) if err != nil &#123; fmt.Println(\"http request failed,err:\", err) return &#125; go func() &#123; resp, err := client.Do(req) pack := Result&#123;r: resp, err: err&#125; resultChan &lt;- pack &#125;() select &#123; case &lt;-ctx.Done(): tr.CancelRequest(req) er := &lt;-resultChan fmt.Println(\"Timeout!\", er.err) case res := &lt;-resultChan: defer res.r.Body.Close() out, _ := ioutil.ReadAll(res.r.Body) fmt.Printf(\"Server Response: %s\", out) &#125; return&#125;func main() &#123; process()&#125; 运行结果 12345678910Server Response: &lt;html&gt;&lt;head&gt; &lt;script&gt; location.replace(location.href.replace(\"https://\",\"http://\")); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;noscript&gt;&lt;meta http-equiv=\"refresh\" content=\"0;url=http://www.baidu.com/\"&gt;&lt;/noscript&gt;&lt;/body&gt;&lt;/html&gt; 如果把请求的网址换成Google，由于不能翻墙，2秒后网络请求会被取消，并返回错误的原因： 1Timeout! Get http://www.google.com: net/http: request canceled while waiting for connection WithValue传递元数据12345678910111213141516171819202122package mainimport ( \"context\" \"fmt\")func process(ctx context.Context) &#123; ret, ok := ctx.Value(\"empno\").(int) if !ok &#123; ret = 83156789 &#125; fmt.Printf(\"empno:%d\\n\", ret) s, _ := ctx.Value(\"ename\").(string) fmt.Printf(\"ename:%s\\n\", s)&#125;func main() &#123; ctx := context.WithValue(context.Background(), \"empno\", 12315) ctx = context.WithValue(ctx, \"ename\", \"duguqiubai\") process(ctx)&#125; 运行结果 12empno:12315ename:duguqiubai 通过Context传递元数据123456789101112131415161718192021222324252627282930313233package mainimport ( \"context\" \"fmt\" \"time\")var key = \"name\"func purchase(ctx context.Context) &#123; for &#123; select &#123; case &lt;-ctx.Done(): fmt.Println(ctx.Value(key), \"抢购结束，卖完了…\") return default: fmt.Println(ctx.Value(key), \"goroutine抢购中…\") time.Sleep(2 * time.Second) &#125; &#125;&#125;func main() &#123; ctx, cancel := context.WithCancel(context.Background()) valueCtx := context.WithValue(ctx, key, \"【黄牛1】\") go purchase(valueCtx) time.Sleep(10 * time.Second) fmt.Println(\"卖完了，通知抢购结束\") cancel() // 检测抢购是否停止，如果没有输出，就表示停止了 time.Sleep(3 * time.Second)&#125; 运行结果 1234567【黄牛1】 goroutine抢购中…【黄牛1】 goroutine抢购中…【黄牛1】 goroutine抢购中…【黄牛1】 goroutine抢购中…【黄牛1】 goroutine抢购中…卖完了，通知抢购结束【黄牛1】 抢购结束，卖完了… 超时控制WithDeadline1234567891011121314151617181920package mainimport ( \"context\" \"fmt\" \"time\")func main() &#123; d := time.Now().Add(4 * time.Second) // d := time.Now().Add(2 * time.Second) ctx, cancel := context.WithDeadline(context.Background(), d) defer cancel() select &#123; case &lt;-time.After(3 * time.Second): fmt.Println(\"差点睡过头了\") case &lt;-ctx.Done(): fmt.Println(ctx.Err()) &#125;&#125; 运行结果 1差点睡过头了 如果把第一行的时间改成2秒，就会出现超时，上下文被取消 1context deadline exceeded 利用Context结束goroutine1234567891011121314151617181920212223242526272829303132333435363738394041424344package mainimport ( \"context\" \"fmt\" \"time\")// 创建一个通道，启动goroutine，for循环存数据，func gen(ctx context.Context) &lt;-chan int &#123; dst := make(chan int) n := 1 go func() &#123; for &#123; select &#123; case &lt;-ctx.Done(): // 执行defer cancel 操作后，就会执行该select fmt.Println(\"i exited\") return case dst &lt;- n: n++ &#125; &#125; &#125;() return dst&#125;func test() &#123; ctx, cancel := context.WithCancel(context.Background()) // 当n==5的时候，执行defer cancel操作 defer cancel() intChan := gen(ctx) for n := range intChan &#123; fmt.Println(n) if n == 6 &#123; break &#125; &#125;&#125;func main() &#123; test() time.Sleep(5 * time.Second)&#125; 运行结果 1234567123456i exited 版权声明：博客中的文章版权归博主所有，未经授权，禁止转载，转载请注明出处，合作请点击“关于我”，扫码添加微信","categories":[{"name":"go语言","slug":"go语言","permalink":"http://yoursite.com/categories/go语言/"}],"tags":[{"name":"Context包","slug":"Context包","permalink":"http://yoursite.com/tags/Context包/"}]},{"title":"求字符串最长公共子序列","slug":"求字符串最长公共子序列","date":"2018-03-23T12:36:00.000Z","updated":"2018-09-14T12:40:02.523Z","comments":true,"path":"2018/03/23/求字符串最长公共子序列/","link":"","permalink":"http://yoursite.com/2018/03/23/求字符串最长公共子序列/","excerpt":"整理：房玉辉","text":"整理：房玉辉 博客：https://ElonJelinek.github.iogo语言：递归与动态规划算法求：字符串最长公共子序列动态规划算法在动态规划算法中，子问题可能是重叠的，通过使用备忘录来保存已解决的子问题的答案。对于大部分问题，动态规划能够将待求解的问题的时间复杂度由指数级降低为多项式级，如O(n^2 )、O(n^3 )等。 动态规划主要包含两个部分： 递归：递归求解子问题 备忘录：将已经计算的值存储在表中 动态规划=递归+备忘录 动态规划的适用范围动态规划不能求解所有问题，从以下两点可以判断是否适用于给定问题 最优子结构：问题的最优解包含其子问题的最优解 子问题重叠：递归求解过程中包含少量不同子问题的多次重复计算 动态规划与直接递归的区别在于对递归调用的备忘。如果子问题是相互独立的，不存在重叠，那么备忘录功能就没有任何作用，因此动态规划并不适用于所有问题。 动态规划求最长公共子序列已知两个字符串，长度为m的字符串和长度为n的字符串，找出最长公共子序列：在两个字符串中从左至右均出现的最长字符序列（不一定是连续的），例如：X=”ABCBDAB”，Y=”BDCABA”，最长公共子序列LCS[X,Y]={“BCBA”，“BDAB”，“BCAB”}，所以，可能存在多个最优解。 蛮力法：一个简单的思路是检查X[1-m]中的每个子序列是否也是Y[1-n]的一个子序列。一次检查花费O(n)的时间，而X也有2^n 个子序列，那么花费的总时间为指数级O(n*2^m )。对于非常长的序列，这种方法是极为低效的。 递归求解该问题求解过程中涉及X和Y中的两个子序列，假设X的子序列开始下标为i，Y子序列的开始下标为j，X[1…m]是一个X的从i开始到末尾的子串，Y[1…n]是一个Y从j开始到末尾的子串。由此，可能存在以下情况： 如果X[i]==Y[j]，则1+LCS(i+1,j+1)。 如果X[i]!=Y[j]，则LCS(i,j+1)。跳过Y的第j个字符。 如果X[i]!=Y[j]，则LCS(i+1,j)。跳过x的第i个字符。 对于第一种情况，如果X[i]等于Y[j]，则找到一个匹配对，并将其计入LCS的总长度中，否则需要跳过X的第i个字符或者Y的第j个字符，继续搜寻最长公共子序列。 递归求解法，完整代码 1234567891011121314151617181920212223242526272829package mainimport \"fmt\"var LCS [1024][1024]intfunc LCSlength(x string, i, m int, y string, j, n int) int &#123; if i == m || j == n &#123; return 0 &#125; else if x[i] == y[j] &#123; return 1 + LCSlength(x, i+1, m, y, j+1, n) &#125; else &#123; return max(LCSlength(x, i+1, m, y, j, n), LCSlength(x, i, m, y, j+1, n)) &#125;&#125;func max(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125;func main() &#123; str1 := \"ABCBDAB\" str2 := \"BDCABA\" length := LCSlength(str1, 0, len(str1), str2, 0, len(str2)) fmt.Println(length)&#125; 递归算法存在重复计算，非常耗时。如果两个字符串没有匹配的字符，那么算法总是执行最后一行代码，当m等于n时，时间复杂度接近于O(2^n )。 动态规划求解法：增加备忘录递归求解的子问题被调用了多次，其中子问题对应于LCSLength函数的一次调用，共有(i+1)(j+1)个可能的子问题（一个相对较小的数）。但如果有2^n 个递归调用，那么这些子问题中的某一些必然被反复求解。 在需要求解某个子问题时，动态规划算法首先检测该子问题是否已经被解决，因此有些计算是查询而不是再次求解。 动态规划算法具体步骤 1234567891011121314151617181920212223242526272829303132333435363738394041424344package mainimport \"fmt\"var LCS [1024][1024]int// 这里将每一步的执行结果都打出来，以便理解func LCSlength(x string, m int, y string, n int) int &#123; for i := m - 1; i &gt;= 0; i-- &#123; for j := n - 1; j &gt;= 0; j-- &#123; fmt.Println(\"LCS[\", i, \"][\", j, \"]:\", LCS[i][j]) LCS[i][j] = LCS[i+1][j+1] fmt.Print(\"LCS[\", i, \"][\", j, \"] = LCS[\", i+1, \"][\", j+1, \"]\\t=\",LCS[i][j]) fmt.Println() if x[i] == y[j] &#123; fmt.Println(\"x[\", i, \"] == y[\", j, \"]\") fmt.Print(i, j, \"\\t\", LCS[i][j], \"\\t\") LCS[i][j]++ fmt.Print(i, j, \"\\t\", LCS[i][j], \"\\t\") fmt.Println() &#125; if LCS[i][j+1] &gt; LCS[i][j] &#123; fmt.Println(\"LCS[\", i, \"][\", j+1, \"] &gt; LCS[\", i, \"][\", j, \"]\") LCS[i][j] = LCS[i][j+1] fmt.Print(\"LCS[\", i, \"][\", j, \"] = LCS[\", i, \"][\", j+1, \"]\\t=\",LCS[i][j]) fmt.Println() &#125; if LCS[i+1][j] &gt; LCS[i][j] &#123; fmt.Println(\"LCS[\", i+1, \"][\", j, \"] &gt; LCS[\", i, \"][\", j, \"]\") LCS[i][j] = LCS[i+1][j] fmt.Print(\"LCS[\", i, \"][\", j, \"] = LCS[\", i+1, \"][\", j, \"]\\t=\",LCS[i][j]) fmt.Println() &#125; &#125; &#125; return LCS[0][0]&#125;func main() &#123; str1 := \"ABCBDAB\" str2 := \"BDCABA\" n := LCSlength(str1, len(str1), str2, len(str2)) fmt.Println(n)&#125; 运行结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153LCS[ 6 ][ 5 ]: 0LCS[6][5] = LCS[7][6] =0LCS[ 6 ][ 4 ]: 0LCS[6][4] = LCS[7][5] =0x[ 6 ] == y[ 4 ]6 4 0 6 4 1 LCS[ 6 ][ 3 ]: 0LCS[6][3] = LCS[7][4] =0LCS[ 6 ][ 4 ] &gt; LCS[ 6 ][ 3 ]LCS[6][3] = LCS[6][4] =1LCS[ 6 ][ 2 ]: 0LCS[6][2] = LCS[7][3] =0LCS[ 6 ][ 3 ] &gt; LCS[ 6 ][ 2 ]LCS[6][2] = LCS[6][3] =1LCS[ 6 ][ 1 ]: 0LCS[6][1] = LCS[7][2] =0LCS[ 6 ][ 2 ] &gt; LCS[ 6 ][ 1 ]LCS[6][1] = LCS[6][2] =1LCS[ 6 ][ 0 ]: 0LCS[6][0] = LCS[7][1] =0x[ 6 ] == y[ 0 ]6 0 0 6 0 1 LCS[ 5 ][ 5 ]: 0LCS[5][5] = LCS[6][6] =0x[ 5 ] == y[ 5 ]5 5 0 5 5 1 LCS[ 5 ][ 4 ]: 0LCS[5][4] = LCS[6][5] =0LCS[ 5 ][ 5 ] &gt; LCS[ 5 ][ 4 ]LCS[5][4] = LCS[5][5] =1LCS[ 5 ][ 3 ]: 0LCS[5][3] = LCS[6][4] =1x[ 5 ] == y[ 3 ]5 3 1 5 3 2 LCS[ 5 ][ 2 ]: 0LCS[5][2] = LCS[6][3] =1LCS[ 5 ][ 3 ] &gt; LCS[ 5 ][ 2 ]LCS[5][2] = LCS[5][3] =2LCS[ 5 ][ 1 ]: 0LCS[5][1] = LCS[6][2] =1LCS[ 5 ][ 2 ] &gt; LCS[ 5 ][ 1 ]LCS[5][1] = LCS[5][2] =2LCS[ 5 ][ 0 ]: 0LCS[5][0] = LCS[6][1] =1LCS[ 5 ][ 1 ] &gt; LCS[ 5 ][ 0 ]LCS[5][0] = LCS[5][1] =2LCS[ 4 ][ 5 ]: 0LCS[4][5] = LCS[5][6] =0LCS[ 5 ][ 5 ] &gt; LCS[ 4 ][ 5 ]LCS[4][5] = LCS[5][5] =1LCS[ 4 ][ 4 ]: 0LCS[4][4] = LCS[5][5] =1LCS[ 4 ][ 3 ]: 0LCS[4][3] = LCS[5][4] =1LCS[ 5 ][ 3 ] &gt; LCS[ 4 ][ 3 ]LCS[4][3] = LCS[5][3] =2LCS[ 4 ][ 2 ]: 0LCS[4][2] = LCS[5][3] =2LCS[ 4 ][ 1 ]: 0LCS[4][1] = LCS[5][2] =2x[ 4 ] == y[ 1 ]4 1 2 4 1 3 LCS[ 4 ][ 0 ]: 0LCS[4][0] = LCS[5][1] =2LCS[ 4 ][ 1 ] &gt; LCS[ 4 ][ 0 ]LCS[4][0] = LCS[4][1] =3LCS[ 3 ][ 5 ]: 0LCS[3][5] = LCS[4][6] =0LCS[ 4 ][ 5 ] &gt; LCS[ 3 ][ 5 ]LCS[3][5] = LCS[4][5] =1LCS[ 3 ][ 4 ]: 0LCS[3][4] = LCS[4][5] =1x[ 3 ] == y[ 4 ]3 4 1 3 4 2 LCS[ 3 ][ 3 ]: 0LCS[3][3] = LCS[4][4] =1LCS[ 3 ][ 4 ] &gt; LCS[ 3 ][ 3 ]LCS[3][3] = LCS[3][4] =2LCS[ 3 ][ 2 ]: 0LCS[3][2] = LCS[4][3] =2LCS[ 3 ][ 1 ]: 0LCS[3][1] = LCS[4][2] =2LCS[ 4 ][ 1 ] &gt; LCS[ 3 ][ 1 ]LCS[3][1] = LCS[4][1] =3LCS[ 3 ][ 0 ]: 0LCS[3][0] = LCS[4][1] =3x[ 3 ] == y[ 0 ]3 0 3 3 0 4 LCS[ 2 ][ 5 ]: 0LCS[2][5] = LCS[3][6] =0LCS[ 3 ][ 5 ] &gt; LCS[ 2 ][ 5 ]LCS[2][5] = LCS[3][5] =1LCS[ 2 ][ 4 ]: 0LCS[2][4] = LCS[3][5] =1LCS[ 3 ][ 4 ] &gt; LCS[ 2 ][ 4 ]LCS[2][4] = LCS[3][4] =2LCS[ 2 ][ 3 ]: 0LCS[2][3] = LCS[3][4] =2LCS[ 2 ][ 2 ]: 0LCS[2][2] = LCS[3][3] =2x[ 2 ] == y[ 2 ]2 2 2 2 2 3 LCS[ 2 ][ 1 ]: 0LCS[2][1] = LCS[3][2] =2LCS[ 2 ][ 2 ] &gt; LCS[ 2 ][ 1 ]LCS[2][1] = LCS[2][2] =3LCS[ 2 ][ 0 ]: 0LCS[2][0] = LCS[3][1] =3LCS[ 3 ][ 0 ] &gt; LCS[ 2 ][ 0 ]LCS[2][0] = LCS[3][0] =4LCS[ 1 ][ 5 ]: 0LCS[1][5] = LCS[2][6] =0LCS[ 2 ][ 5 ] &gt; LCS[ 1 ][ 5 ]LCS[1][5] = LCS[2][5] =1LCS[ 1 ][ 4 ]: 0LCS[1][4] = LCS[2][5] =1x[ 1 ] == y[ 4 ]1 4 1 1 4 2 LCS[ 1 ][ 3 ]: 0LCS[1][3] = LCS[2][4] =2LCS[ 1 ][ 2 ]: 0LCS[1][2] = LCS[2][3] =2LCS[ 2 ][ 2 ] &gt; LCS[ 1 ][ 2 ]LCS[1][2] = LCS[2][2] =3LCS[ 1 ][ 1 ]: 0LCS[1][1] = LCS[2][2] =3LCS[ 1 ][ 0 ]: 0LCS[1][0] = LCS[2][1] =3x[ 1 ] == y[ 0 ]1 0 3 1 0 4 LCS[ 0 ][ 5 ]: 0LCS[0][5] = LCS[1][6] =0x[ 0 ] == y[ 5 ]0 5 0 0 5 1 LCS[ 0 ][ 4 ]: 0LCS[0][4] = LCS[1][5] =1LCS[ 1 ][ 4 ] &gt; LCS[ 0 ][ 4 ]LCS[0][4] = LCS[1][4] =2LCS[ 0 ][ 3 ]: 0LCS[0][3] = LCS[1][4] =2x[ 0 ] == y[ 3 ]0 3 2 0 3 3 LCS[ 0 ][ 2 ]: 0LCS[0][2] = LCS[1][3] =2LCS[ 0 ][ 3 ] &gt; LCS[ 0 ][ 2 ]LCS[0][2] = LCS[0][3] =3LCS[ 0 ][ 1 ]: 0LCS[0][1] = LCS[1][2] =3LCS[ 0 ][ 0 ]: 0LCS[0][0] = LCS[1][1] =3LCS[ 1 ][ 0 ] &gt; LCS[ 0 ][ 0 ]LCS[0][0] = LCS[1][0] =44 动态规划完整代码 12345678910111213141516171819202122232425262728293031package mainimport \"fmt\"var LCS [1024][1024]intfunc LCSlength(x string, m int, y string, n int) int &#123; for i := m - 1; i &gt;= 0; i-- &#123; for j := n - 1; j &gt;= 0; j-- &#123; LCS[i][j] = LCS[i+1][j+1] if x[i] == y[j] &#123; LCS[i][j]++ &#125; if LCS[i][j+1] &gt; LCS[i][j] &#123; LCS[i][j] = LCS[i][j+1] &#125; if LCS[i+1][j] &gt; LCS[i][j] &#123; LCS[i][j] = LCS[i+1][j] &#125; &#125; &#125; return LCS[0][0]&#125;func main() &#123; str1 := \"ABCBDAB\" str2 := \"BDCABA\" n := LCSlength(str1, len(str1), str2, len(str2)) fmt.Println(n)&#125; 动态规划算法，其时间复杂度为O(mn)，因为i从1~m依次取值，j从1~n依次取值。 下面把字符串加长，对比一下两种算法所消耗的时间 动态规划算法 123456789func main() &#123; str1 := \"ABCBDABGNAIGIAENIGEGWM\" str2 := \"BDCABAFANIGINIEINGINWM\" start := time.Now() n := LCS1length1(str1, len(str1), str2, len(str2)) end := time.Since(start) fmt.Println(\"耗时：\", end) fmt.Println(\"最长公共子序列的长度为：\", n)&#125; 运行结果 12耗时： 43.729µs最长公共子序列的长度为： 14 递归算法 123456789func main() &#123; str1 := \"ABCBDABGNAIGIAENIGEGWM\" str2 := \"BDCABAFANIGINIEINGINWM\" start := time.Now() length := LCSlength(str1, 0, len(str1), str2, 0, len(str2)) end := time.Since(start) fmt.Println(\"耗时：\", end) fmt.Println(\"最长公共子序列的长度为：\", length)&#125; 运行结果 12耗时： 8.484912422s最长公共子序列的长度为： 14 对比可见，同样的问题，动态规划算法只需要不到100微秒，而递归算法需要8秒，是动态规划算法的8万多倍。 前面这种动态规划解法是将字符串从尾到头开始比较，该问题也可以从头到尾进行比较，下面看一下这种方法 完整代码 1234567891011121314151617181920212223242526272829303132333435363738package mainimport ( \"fmt\" \"time\")func comSubstring(str1, str2 string, m, n int) int &#123; var arr12 [1024][1024]int for i := 1; i &lt;= m; i++ &#123; for j := 1; j &lt;= n; j++ &#123; if str1[i-1] == str2[j-1] &#123; arr12[i][j] = arr12[i-1][j-1] + 1 &#125; if str1[i-1] != str2[j-1] &#123; arr12[i][j] = max1(arr12[i][j-1], arr12[i-1][j]) &#125; &#125; &#125; return arr12[m][n]&#125;func max1(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125;func main() &#123; str1 := \"ABCBDABGNAIGIAENIGEGWM\" str2 := \"BDCABAFANIGINIEINGINWM\" start := time.Now() n := comSubstring(str1, str2, len(str1), len(str2)) end := time.Since(start) fmt.Println(\"耗时：\", end) fmt.Println(\"最长公共子序列的长度为：\", n)&#125; 运行结果 12耗时： 4.674424ms最长公共子序列的长度为： 14 这种方法也比较耗时，不过仍然比递归耗时要小得多。 接下来用这种方法，将最长公共子序列输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package mainimport ( \"fmt\" \"time\")func comSubStrLen(s1, s2 string) int &#123; var arr [1024][1024]int for i := 1; i &lt; len(s1)+1; i++ &#123; for j := 1; j &lt; len(s2)+1; j++ &#123; if s1[i-1] == s2[j-1] &#123; arr[i][j] = 1 + arr[i-1][j-1] &#125; else &#123; arr[i][j] = maxNum(arr[i-1][j], arr[i][j-1]) &#125; &#125; &#125; return arr[len(s1)][len(s2)]&#125;func comSubStr(s1, s2 string) string &#123; var arr [1024][1024]int for i := 1; i &lt; len(s1)+1; i++ &#123; for j := 1; j &lt; len(s2)+1; j++ &#123; if s1[i-1] == s2[j-1] &#123; arr[i][j] = 1 + arr[i-1][j-1] &#125; else &#123; arr[i][j] = maxNum(arr[i-1][j], arr[i][j-1]) &#125; &#125; &#125; m := len(s1) n := len(s2) var result []byte for m &gt; 0 &amp;&amp; n &gt; 0 &#123; if s1[m-1] == s2[n-1] &#123; result = append(result, s1[m-1]) m-- n-- &#125; else if arr[m][n-1] &gt;= arr[m-1][n] &#123; n-- &#125; else &#123; m-- &#125; &#125; return reverseString(string(result))&#125;func reverseString(s string) string &#123; runes := []rune(s) for from, to := 0, len(runes)-1; from &lt; to; from, to = from+1, to-1 &#123; runes[from], runes[to] = runes[to], runes[from] &#125; return string(runes)&#125;func maxNum(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125;func main() &#123; str1 := \"ABCBDABGNAIGIAENIGEGWM\" str2 := \"BDCABAFANIGINIEINGINWM\" start := time.Now() n := comSubStrLen(str1, str2) end := time.Since(start) fmt.Println(\"耗时：\", end) fmt.Println(\"最长公共子序列的长度为：\", n) csr := comSubStr(str1, str2) fmt.Println(\"最长公共子序列为：\", csr)&#125; 运行结果 123耗时： 5.396031ms最长公共子序列的长度为： 14最长公共子序列为： BDABAIGINIEGWM 公共子序列还有其他好几个相关问题，同样动态规划算法的应用场景也很多，这里只是最简单的用法，网上还能搜索到很多，这里就不再展开。 最后，推荐一本书《数据结构与算法经典问题解析》，印度：纳拉辛哈·卡鲁曼希著，封面如下豆瓣链接：https://book.douban.com/subject/26834485/ 本文中大部分内容参考自这本书，内容详实，非常经典，非常实用。 版权声明：博客中的文章版权归博主所有，未经授权，禁止转载，转载请注明出处，合作请点击“关于我”，扫码添加微信","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/categories/数据结构与算法/"}],"tags":[{"name":"递归","slug":"递归","permalink":"http://yoursite.com/tags/递归/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"最长公共子序列","slug":"最长公共子序列","permalink":"http://yoursite.com/tags/最长公共子序列/"}]},{"title":"搭建etcd多台服务器集群","slug":"搭建etcd多台服务器集群","date":"2018-02-11T13:08:05.000Z","updated":"2018-07-28T10:47:08.717Z","comments":true,"path":"2018/02/11/搭建etcd多台服务器集群/","link":"","permalink":"http://yoursite.com/2018/02/11/搭建etcd多台服务器集群/","excerpt":"整理：房玉辉","text":"整理：房玉辉 博客：https://ElonJelinek.github.io 1、清空缓存：在etcd目录下执行make clean 2、导入API：在etcd/bin目录下执行export ETCDCTL_API=3 3、设置服务器IP：在etcd/bin目录下执行三台机器按主机IP顺序执行以下同一段代码 123456789TOKEN=token-01CLUSTER_STATE=newNAME_1=machine-1NAME_2=machine-2NAME_3=machine-3HOST_1=10.0.154.189HOST_2=10.0.154.210HOST_3=10.0.154.244CLUSTER=$&#123;NAME_1&#125;=http://$&#123;HOST_1&#125;:2380,$&#123;NAME_2&#125;=http://$&#123;HOST_2&#125;:2380,$&#123;NAME_3&#125;=http://$&#123;HOST_3&#125;:2380 4、启动服务：在etcd/bin目录下执行 三台机器按顺序执行各自命令：machine1执行如下命令： 123THIS_NAME=$&#123;NAME_1&#125;THIS_IP=$&#123;HOST_1&#125;./etcd --data-dir=data.etcd --name $&#123;THIS_NAME&#125; --initial-advertise-peer-urls http://$&#123;THIS_IP&#125;:2380 --listen-peer-urls http://$&#123;THIS_IP&#125;:2380 --advertise-client-urls http://$&#123;THIS_IP&#125;:2379 --listen-client-urls http://$&#123;THIS_IP&#125;:2379 --initial-cluster $&#123;CLUSTER&#125; --initial-cluster-state $&#123;CLUSTER_STATE&#125; --initial-cluster-token $&#123;TOKEN&#125; machine2执行以下命令： 123THIS_NAME=$&#123;NAME_2&#125;THIS_IP=$&#123;HOST_2&#125;./etcd --data-dir=data.etcd --name $&#123;THIS_NAME&#125; --initial-advertise-peer-urls http://$&#123;THIS_IP&#125;:2380 --listen-peer-urls http://$&#123;THIS_IP&#125;:2380 --advertise-client-urls http://$&#123;THIS_IP&#125;:2379 --listen-client-urls http://$&#123;THIS_IP&#125;:2379 --initial-cluster $&#123;CLUSTER&#125; --initial-cluster-state $&#123;CLUSTER_STATE&#125; --initial-cluster-token $&#123;TOKEN&#125; machine3执行以下命令： 123THIS_NAME=$&#123;NAME_3&#125;THIS_IP=$&#123;HOST_3&#125;./etcd --data-dir=data.etcd --name $&#123;THIS_NAME&#125; --initial-advertise-peer-urls http://$&#123;THIS_IP&#125;:2380 --listen-peer-urls http://$&#123;THIS_IP&#125;:2380 --advertise-client-urls http://$&#123;THIS_IP&#125;:2379 --listen-client-urls http://$&#123;THIS_IP&#125;:2379 --initial-cluster $&#123;CLUSTER&#125; --initial-cluster-state $&#123;CLUSTER_STATE&#125; --initial-cluster-token $&#123;TOKEN&#125; machine3接入成功 5、检测几台机器接入集群： 新开一个终端：进入etcd/bin目录导入IP：export ETCDCTL_API=3执行以下命令： 123456HOST_1=10.0.154.189HOST_2=10.0.154.210HOST_3=10.0.154.244ENDPOINTS=$HOST_1:2379,$HOST_2:2379,$HOST_3:2379./etcdctl --endpoints=$ENDPOINTS member list 连接成功如图： 版权声明：博客中的文章版权归博主所有，未经授权，禁止转载，转载请注明出处，合作请点击“关于我”，扫码添加微信","categories":[{"name":"分布式系统","slug":"分布式系统","permalink":"http://yoursite.com/categories/分布式系统/"}],"tags":[{"name":"etcd多台服务器集群","slug":"etcd多台服务器集群","permalink":"http://yoursite.com/tags/etcd多台服务器集群/"}]},{"title":"gin框架：用POST进行文件上传","slug":"gin框架：文件上传","date":"2018-02-04T11:52:10.000Z","updated":"2018-08-26T07:49:32.885Z","comments":true,"path":"2018/02/04/gin框架：文件上传/","link":"","permalink":"http://yoursite.com/2018/02/04/gin框架：文件上传/","excerpt":"整理：房玉辉","text":"整理：房玉辉 博客：https://ElonJelinek.github.io上传单个文件：上传文件用POST方法，之前提到过的multipart/form-data编码格式，就是用于上传文件的，gin把go原生的request封装到了c.Request中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package mainimport ( \"github.com/gin-gonic/gin\" \"fmt\" \"net/http\" \"os\" \"log\" \"io\")func uploadFile(c *gin.Context) &#123;// FormFile方法会读取参数“upload”后面的文件名，返回值是一个File指针，和一个FileHeader指针，和一个err错误。 file, header, err := c.Request.FormFile(\"upload\") if err != nil &#123; c.String(http.StatusBadRequest, \"Bad request\") return &#125; // header调用Filename方法，就可以得到文件名 filename := header.Filename fmt.Println(file, err, filename)// 创建一个文件，文件名为filename，这里的返回值out也是一个File指针 out, err := os.Create(filename) if err != nil &#123; log.Fatal(err) &#125; defer out.Close()// 将file的内容拷贝到out _, err = io.Copy(out, file) if err != nil &#123; log.Fatal(err) &#125; c.String(http.StatusCreated, \"upload successful \\n\")&#125;func main() &#123; router := gin.Default()// 调用POST方法，传入路由参数和路由函数 router.POST(\"/upload\", uploadFile)// 监听端口8000，注意冒号。 router.Run(\":8000\")&#125; 运行结果： 12345678910[GIN-debug] [WARNING] Now Gin requires Go 1.6 or later and Go 1.7 will be required soon.[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.[GIN-debug] [WARNING] Running in \"debug\" mode. Switch to \"release\" mode in production. - using env: export GIN_MODE=release - using code: gin.SetMode(gin.ReleaseMode)[GIN-debug] POST /upload --&gt; main.uploadFile (3 handlers)[GIN-debug] Listening and serving HTTP on :8000 在终端输入： curl -X POST http://127.0.0.1:8000/upload -F &quot;upload=@/Users/ElonJelinek/Pictures/avatar.jpg&quot; -H &quot;Content-Type: multipart/form-data&quot; 运行结果： 123ElonJelinek:~ ElonJelinek$ curl -X POST http://127.0.0.1:8000/upload -F \"upload=@/Users/ElonJelinek/Pictures/avatar.jpg\" -H \"Content-Type: multipart/form-data\"upload successful ElonJelinek:~ ElonJelinek$ 控制台输出： 12&#123;0xc4201d0e70&#125; &lt;nil&gt; avatar.jpg[GIN] 2018/02/04 - 13:52:16 | 201 | 1.186844ms | 127.0.0.1 | POST /upload 输出upload successful则表示上传成功，这里上传的是一张名为avatar.jpg的图片，这里上传完成后的文件在工程的根目录下，也就是工程名目录下。 上传多个文件：模拟上传多个文件，与上传单个文件区别不大，只是用MultipartForm方法替代了FormFile方法，而MultipartForm方法的返回值是一个数组，数组元素为file，所以只需要遍历一下这个数组，并取出文件名，再进行拷贝即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package mainimport ( \"github.com/gin-gonic/gin\" \"log\" \"os\" \"io\" \"net/http\" \"fmt\")func upldFiles(c *gin.Context) &#123; err := c.Request.ParseMultipartForm(200000) if err != nil &#123; log.Fatal(err) &#125;// 获取表单 form := c.Request.MultipartForm// 获取参数upload后面的多个文件名，存放到数组files里面， files := form.File[\"upload\"]// 遍历数组，每取出一个file就拷贝一次 for i, _ := range files &#123; file, err := files[i].Open() defer file.Close() if err != nil &#123; log.Fatal(err) &#125; fileName := files[i].Filename fmt.Println(fileName) out, err := os.Create(fileName) defer out.Close() if err != nil &#123; log.Fatal(err) &#125; _, err = io.Copy(out, file) if err != nil &#123; log.Fatal(err) &#125; c.String(http.StatusCreated, \"uploadFiles success! \\n\") &#125;&#125;func main() &#123; router := gin.Default() router.POST(\"/upload\", upldFiles) router.Run(\":8088\")&#125; 在goland运行： 12345678910[GIN-debug] [WARNING] Now Gin requires Go 1.6 or later and Go 1.7 will be required soon.[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.[GIN-debug] [WARNING] Running in \"debug\" mode. Switch to \"release\" mode in production. - using env: export GIN_MODE=release - using code: gin.SetMode(gin.ReleaseMode)[GIN-debug] POST /upload --&gt; main.upldFiles (3 handlers)[GIN-debug] Listening and serving HTTP on :8088 在终端输入：curl -X POST http://127.0.0.1:8088/upload -F &quot;upload=@/Users/ElonJelinek/Pictures/avatar.jpg&quot; -F &quot;upload=@/Users/ElonJelinek/Pictures/爬虫.jpg&quot; -H &quot;Content-Type: multipart/form-data&quot; 结果： 1234ElonJelinek:~ ElonJelinek$ curl -X POST http://127.0.0.1:8088/upload -F \"upload=@/Users/ElonJelinek/Pictures/avatar.jpg\" -F \"upload=@/Users/ElonJelinek/Pictures/爬虫.jpg\" -H \"Content-Type: multipart/form-data\"uploadFiles success! uploadFiles success! ElonJelinek:~ ElonJelinek$ 控制台输出： 123avatar.jpg爬虫.jpg[GIN] 2018/02/04 - 15:22:14 | 201 | 3.835634ms | 127.0.0.1 | POST /upload gin框架的封装做的很好，用起来很方便，以上例子是一些简单的运用，实际开发中要复杂的多，例如文件上传，在实际工作中，用户上传图片都是通过表单，在浏览器页面上传。实际上gin框架很强大，性能优秀，方便灵活。","categories":[{"name":"go语言","slug":"go语言","permalink":"http://yoursite.com/categories/go语言/"}],"tags":[{"name":"web框架","slug":"web框架","permalink":"http://yoursite.com/tags/web框架/"}]},{"title":"gin框架","slug":"gin框架","date":"2018-02-03T14:52:10.000Z","updated":"2018-08-26T04:15:18.869Z","comments":true,"path":"2018/02/03/gin框架/","link":"","permalink":"http://yoursite.com/2018/02/03/gin框架/","excerpt":"整理：房玉辉","text":"整理：房玉辉 博客：https://ElonJelinek.github.iogin是一个用go写的web框架 1、安装gin在命令行输入：go get github.com/gin-gonic/gin 12ElonJelinek:~ ElonJelinek$ go get github.com/gin-gonic/ginElonJelinek:~ ElonJelinek$ 2、基本用法1、Hello World使用gin实现hello world 很简单，首先调用其default方法创建一个router，然后调用其Run方法 1234567891011121314151617181920package mainimport ( \"github.com/gin-gonic/gin\" \"net/http\")func main() &#123;// 调用default方法创建路由 router := gin.Default()// 通过GET方法绑定路由规则和路由函数 router.GET(\"/\", func(c *gin.Context) &#123; c.String(http.StatusOK, \"Hello world gin! \\n\") &#125;)// 调用Run方法监听端口：8088 router.Run(\":8088\")&#125; 运行，控制台输出： 12345678910[GIN-debug] [WARNING] Now Gin requires Go 1.6 or later and Go 1.7 will be required soon.[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.[GIN-debug] [WARNING] Running in \"debug\" mode. Switch to \"release\" mode in production. - using env: export GIN_MODE=release - using code: gin.SetMode(gin.ReleaseMode)[GIN-debug] GET / --&gt; main.main.func1 (3 handlers)[GIN-debug] Listening and serving HTTP on :8088 打开终端，输入：curl http://localhost:8088 123ElonJelinek:~ ElonJelinek$ curl http://localhost:8088Hello world gin! ElonJelinek:~ ElonJelinek$ gin的路由来自httprouter库，具有httprouter的功能，但是不支持路由正则表达式： 123456789101112131415161718package mainimport ( \"github.com/gin-gonic/gin\" \"net/http\")func main() &#123; router := gin.Default()// 冒号 ：加上一个参数名，组成路由参数，使用Param方法读取其值， router.GET(\"/user/:name\", func(c *gin.Context) &#123; name := c.Param(\"name\") c.String(http.StatusOK, \"Hello %s! \\n\", name) &#125;) router.Run(\":8088\")&#125; 运行： 12345678910[GIN-debug] [WARNING] Now Gin requires Go 1.6 or later and Go 1.7 will be required soon.[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.[GIN-debug] [WARNING] Running in \"debug\" mode. Switch to \"release\" mode in production. - using env: export GIN_MODE=release - using code: gin.SetMode(gin.ReleaseMode)[GIN-debug] GET /user/:name --&gt; main.main.func1 (3 handlers)[GIN-debug] Listening and serving HTTP on :8088 显示监听http：8088端口打开终端，输入：curl http://localhost:8088/user/Tom匹配正确 12ElonJelinek:~ ElonJelinek$ curl http://localhost:8088/user/TomHello Tom! 输入：http://localhost:8088/user/Tom/（最后多了个斜杠“ / ”）显示不匹配 12ElonJelinek:~ ElonJelinek$ curl http://localhost:8088/user/Tom/&lt;a href=\"/user/Tom\"&gt;Moved Permanently&lt;/a&gt;. 输入：curl http://localhost:8088/user/（user/后面为空）也不匹配 12ElonJelinek:~ ElonJelinek$ curl http://localhost:8088/user/404 page not foundElonJelinek:~ ElonJelinek$ 可见，/user/Tom是匹配的，但/user/和/user/Tom/是不匹配的，前者name字段为空，后者name字段后有个斜杠/ 控制台的输出： 123[GIN] 2018/02/03 - 16:54:55 | 200 | 24.52µs | ::1 | GET /user/Tom[GIN-debug] redirecting request 301: /user/Tom/ --&gt; /user/Tom[GIN] 2018/02/03 - 16:55:21 | 404 | 1.143µs | ::1 | GET /user/ 除了冒号之外，还有*参数，*能匹配的规则就很多： 12345678910111213141516171819package mainimport ( \"github.com/gin-gonic/gin\" \"net/http\")func main() &#123; router := gin.Default()// 冒号 : 加name字段，星号 * 加action字段 router.GET(\"/user/:name/*action\", func(c *gin.Context) &#123; name := c.Param(\"name\") action := c.Param(\"action\") msg := name + \" is \" + action + \"\\n\" c.String(http.StatusOK, msg) &#125;) router.Run(\":8088\")&#125; 在终端依次输入：curl http://localhost:8088/user/Tom/美国人curl http://localhost:8088/user/Tom/美国人/curl http://localhost:8088/user/Tom/curl http://localhost:8088/user/Tom/American 结果均匹配正确： 123456789ElonJelinek:~ ElonJelinek$ curl http://localhost:8088/user/Tom/美国人Tom is /美国人ElonJelinek:~ ElonJelinek$ curl http://localhost:8088/user/Tom/美国人/Tom is /美国人/ElonJelinek:~ ElonJelinek$ curl http://localhost:8088/user/Tom/Tom is /ElonJelinek:~ ElonJelinek$ curl http://localhost:8088/user/Tom/AmericanTom is /AmericanElonJelinek:~ ElonJelinek$ 控制台结果： 1234[GIN] 2018/02/03 - 17:23:07 | 200 | 12.679µs | ::1 | GET /user/Tom/美国人[GIN] 2018/02/03 - 17:23:11 | 200 | 16.977µs | ::1 | GET /user/Tom/美国人/[GIN] 2018/02/03 - 17:23:18 | 200 | 19.03µs | ::1 | GET /user/Tom/[GIN] 2018/02/03 - 17:23:50 | 200 | 13.1µs | ::1 | GET /user/Tom/American 2、GETgin.Context中的Query方法：1234567891011121314151617181920212223242526package mainimport ( \"github.com/gin-gonic/gin\" \"net/http\")func getQuery(context *gin.Context) &#123;// 调用query方法获取userid和username userid := context.Query(\"userid\") username := context.Query(\"username\")// 转换为string，并在浏览器输出 context.String(http.StatusOK, userid+\" \"+username)&#125;func main() &#123;// 使用gin的default方法创建一个路由handler router := gin.Default()// 路由参数/user 调用getquery方法获取/user之后的值 router.GET(\"/user\", getQuery) // 启动路由的run方法监听端口：8088 router.Run(\":8088\")&#125; 运行这段代码，goland控制台（即服务端）会有如下输出： 12345678910[GIN-debug] [WARNING] Now Gin requires Go 1.6 or later and Go 1.7 will be required soon.[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.[GIN-debug] [WARNING] Running in \"debug\" mode. Switch to \"release\" mode in production. - using env: export GIN_MODE=release - using code: gin.SetMode(gin.ReleaseMode)[GIN-debug] GET /user --&gt; main.getQuery (3 handlers)[GIN-debug] Listening and serving HTTP on :8088 然后，打开浏览器，输入网址：http://localhost:8088/user?userid=1&amp;username=tyming 控制台会输出： 12[GIN] 2018/02/03 - 18:00:31 | 200 | 105.848µs | ::1 | GET /user?userid=1&amp;username=tyming[GIN] 2018/02/03 - 18:05:32 | 404 | 613ns | ::1 | GET /favicon.ico 浏览器（即客户端）输出：1 tyming 2、gin.Context中的Param方法：1234567891011121314151617181920212223242526package mainimport ( \"github.com/gin-gonic/gin\" \"net/http\")func getParam(context *gin.Context) &#123;// 调用param方法读取userid和username的值 userid := context.Param(\"userid\") username := context.Param(\"username\")// 转换为string并在浏览器输出，输出格式为：userid 空格 username context.String(http.StatusOK, userid+\" \"+username)&#125;func main() &#123;// 用default注册路由 router := gin.Default()// 路由参数 /user/:加上由参数名组成的路由参数 router.GET(\"/user/:userid/:username\", getParam)// 调用路由的run方法 router.Run(\":8088\")&#125; 运行，goland控制台输出： 12345678910[GIN-debug] [WARNING] Now Gin requires Go 1.6 or later and Go 1.7 will be required soon.[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.[GIN-debug] [WARNING] Running in \"debug\" mode. Switch to \"release\" mode in production. - using env: export GIN_MODE=release - using code: gin.SetMode(gin.ReleaseMode)[GIN-debug] GET /user/:userid/:username --&gt; main.getParam (3 handlers)[GIN-debug] Listening and serving HTTP on :8088 打开网址：http://localhost:8088/user/1/tyming 浏览器输出：1 tyming goland控制台输出： 1[GIN] 2018/02/03 - 18:26:35 | 200 | 32.083µs | ::1 | GET /user/1/tyming 3、POSTgin.Context中的PostForm方法：1234567891011121314151617181920212223242526package mainimport ( \"github.com/gin-gonic/gin\")func post(c *gin.Context) &#123; username := c.PostForm(\"username\") // DefaultPostForm方法的第二个参数为默认值 // 如果提交post请求的时候，没有password字段，则默认值123456会被自动提交 password := c.DefaultPostForm(\"password\", \"123456\") c.JSON(200, gin.H&#123; \"status\": \"ok\", \"username\": username, \"password\": password, &#125;)&#125;func main() &#123; router := gin.Default() router.POST(\"/user\", post) router.Run(\":8088\")&#125; 运行此代码（在goland运行），控制台（即服务端）输出： 12345678910[GIN-debug] [WARNING] Now Gin requires Go 1.6 or later and Go 1.7 will be required soon.[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.[GIN-debug] [WARNING] Running in \"debug\" mode. Switch to \"release\" mode in production. - using env: export GIN_MODE=release - using code: gin.SetMode(gin.ReleaseMode)[GIN-debug] POST /user --&gt; main.post (3 handlers)[GIN-debug] Listening and serving HTTP on :8088 在终端用curl模拟提交post请求：输入：curl -X POST http://localhost:8088/user -H &quot;Content-Type:application/multipart/form-data&quot; -d &quot;username=hello&amp;password=123456&quot; 或输入：curl -X POST http://localhost:8088/user -H &quot;Content-Type:application/x-www-form-urlencoded&quot; -d &quot;username=hello&amp;password=123456&quot; 这一段命令的localhost也可用127.0.0.1代替，x-www-form-urlencoded和multipart/form-data是post请求的编码格式，urlencoded表示对url进行encode加密，username=hello&amp;password=123456是要提交的数据， 123ElonJelinek:~ ElonJelinek$ curl -X POST http://localhost:8088/user -H \"Content-Type:application/multipart/form-data\" -d \"username=hello&amp;password=123456\"&#123;\"password\":\"123456\",\"status\":\"ok\",\"username\":\"\"&#125;ElonJelinek:~ ElonJelinek$ 控制台输出： 1[GIN] 2018/02/03 - 19:05:24 | 200 | 188.599µs | ::1 | POST /user 也可用postman工具进行模拟post提交，使用很方便，不需要在终端打一长串命令，postman工具官网：https://www.getpostman.com/ 控制台输出： 1[GIN] 2018/02/03 - 19:36:57 | 200 | 1.1565ms | 127.0.0.1 | POST /user 参数绑定： 1234567891011121314151617181920212223242526272829303132package mainimport ( \"github.com/gin-gonic/gin\" \"net/http\")type User struct &#123; Username string `form:\"username\"` Password string `form:\"password\"`&#125;func bind(c *gin.Context) &#123; var user User if c.Bind(&amp;user) == nil &#123; c.JSON(http.StatusOK, gin.H&#123; \"username\": user.Username, \"password\": user.Password, &#125;) &#125;&#125;func main() &#123; router := gin.Default() // 注意bind前面有个斜杠 / router.POST(\"/bind\", bind) // 注意8088前面有个冒号 : router.Run(\":8088\")&#125; 在goland运行，然后用postman工具模拟提交post请求：控制台输出： 1[GIN] 2018/02/03 - 20:20:15 | 200 | 1.266963ms | 127.0.0.1 | POST /bind 除了GET和POST方法外，gin还提供了PUT，DELETE，OPTION等常用的restful方法。 版权声明：博客中的文章版权归博主所有，未经授权，禁止转载，转载请注明出处，合作请点击“关于我”，扫码添加微信","categories":[{"name":"go语言","slug":"go语言","permalink":"http://yoursite.com/categories/go语言/"}],"tags":[{"name":"web框架","slug":"web框架","permalink":"http://yoursite.com/tags/web框架/"}]},{"title":"go语言常见面试题（数学篇）","slug":"go语言面试题（数学篇）","date":"2018-01-03T12:55:20.000Z","updated":"2018-07-31T10:35:44.626Z","comments":true,"path":"2018/01/03/go语言面试题（数学篇）/","link":"","permalink":"http://yoursite.com/2018/01/03/go语言面试题（数学篇）/","excerpt":"整理：房玉辉","text":"整理：房玉辉 博客：https://ElonJelinek.github.io一、分解质因数：比如90，分解出：90=2*3*3*5分析：质数为大于1的自然数，除了1和它本身没有其他因数。相反，除了1和它本身还有其他因数的数，称为合数，所以，分解法为：先用这个合数最小的那个因数（是质数的因数）去除，商如果是合数，就继续除：商如果是质数，就停止，最后的这个商是它的最大的质因数。因此，最后可以写成所有的除数乘以最后的商。 1234567891011121314151617181920package mainimport \"fmt\"func main() &#123; var n = 90 fun(n)&#125;func fun(n int) &#123; fmt.Print(n, \"=\", ) for i := 2; i &lt; n; i++ &#123; if n%i == 0 &#123; n = n / i fmt.Print(i, \"*\") i-- &#125; &#125; fmt.Println(n)&#125; 运行结果： 190=2*3*3*5 二、计算 sum(n) = 1/3 + 2/5 + 3/7 + … + n/2n+1 的前n项和123456789101112131415161718package mainimport \"fmt\"func main() &#123; var n float32 = 8 fmt.Print(\"sum(\", n, \")=\\t\") sum := float32(0) for i := float32(1); i &lt;= n; i++ &#123; if i != n &#123; fmt.Print(i, \"/\", 2*i+1, \"\\t+\\t\") &#125; else &#123; fmt.Print(i, \"/\", 2*i+1, \"\\t\") &#125; sum += i / (2*i + 1) &#125; fmt.Println(\"=\", sum)&#125; 运行结果： 1sum(8)= 1/3 + 2/5 + 3/7 + 4/9 + 5/11 + 6/13 + 7/15 + 8/17 = 3.4596882 三、一球从100米高度自由落下，每次落地后又返跳回原高度的一半，再下落，求它第10次落地时，共经过多少米？分析：从第2次开始，每次经过的距离为下落点的2倍，所以第10次落地共经过的距离为后9次的下落点的高度和乘以2加上第一次的100米。 123456789101112131415package mainimport \"fmt\"func main() &#123; var hight float32 = 100 var jump = hight for i := 2; i &lt;= 10; i++ &#123; jump = jump / 2 hight += jump * 2 &#125; fmt.Println(\"第十次落地共经过：\", hight, \"米。\")&#125; 运行结果： 1第十次落地共经过： 299.60938 米。 四、要求输入一个整数n，请你输出斐波那契数列的第n项[斐波那契数列0 1 1 2 3 5 8 13 21……]123456789101112131415package mainimport \"fmt\"func main() &#123; fmt.Println(fibonacci(8))&#125;func fibonacci(n int) int &#123; if n &lt;= 1 &#123; return n &#125; else &#123; return fibonacci(n-2) + fibonacci(n-1) &#125;&#125; 运行结果：21 五、求1+2!+3!+…+20!的和12345678910111213141516171819202122package mainimport ( \"fmt\")func main() &#123; sum := 0 // 把1到20的阶乘的和累加 for i := 1; i &lt;= 20; i++ &#123; sum += fact(i) &#125; fmt.Println(sum)&#125;// 用递归求阶乘func fact(n int) int &#123; if n &lt;= 1 &#123; return n &#125; else &#123; return n * fact(n-1) &#125;&#125; 运行结果： 12561327494111820313 六、求101-200之内的素数12345678910111213141516171819202122package mainimport ( \"fmt\")func main() &#123; n := 0 for i := 100; i &lt;= 200; i++ &#123; count := 0 for j := 2; j &lt; i; j++ &#123; if i%j == 0 &#123; count++ &#125; &#125; if count == 0 &#123; n++ fmt.Print(i, \"\\t\") &#125; &#125; fmt.Println(n)&#125; 运行结果：101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 21共有21个。 七、打印出所有的 “水仙花数 “，所谓 “水仙花数 “是指一个三位数，其各位数字立方和等于该数本身。例如：153是一个 “水仙花数 “，因为153=1的三次方＋5的三次方＋3的三次方1234567891011121314package mainimport \"fmt\"func main() &#123; for i := 100; i &lt;= 999; i++ &#123; l := i / 100 m := i / 10 % 10 n := i % 10 if l*l*l+m*m*m+n*n*n == i &#123; fmt.Println(i) &#125; &#125;&#125; 运行结果： 1234153370371407 八、利用递归方法求5!12345678910111213141516package mainimport \"fmt\"func main() &#123; a := fact(5) fmt.Println(a)&#125;func fact(n int) int &#123; if n &lt;= 1 &#123; return 1 &#125; else &#123; return n * fact(n-1) &#125;&#125; 运行结果120 九、有1、2、3、4四个数字，能组成多少个互不相同且无重复的三位数1234567891011121314package mainimport \"fmt\"func main() &#123; for i := 123; i &lt;= 432; i++ &#123; g := i % 10 s := i % 100 / 10 b := i / 100 if g != s &amp;&amp; g != b &amp;&amp; s != b &amp;&amp; g &lt;= 4 &amp;&amp; s &lt;= 4 &amp;&amp; b &lt;= 4 &amp;&amp; g != 0 &amp;&amp; s != 0 &amp;&amp; b != 0 &#123; fmt.Print(i, \"\\t\") &#125; &#125;&#125; 运行结果：123 124 132 134 142 143 213 214 231 234 241 243 312 314 321 324 341 342 412 413 421 423 431 432 十、输入三个整数x,y,z，请把这三个数由小到大输出12345678910111213141516171819202122232425package mainimport \"fmt\"func main() &#123; var x int var y int var z int fmt.Scanln(&amp;x, &amp;y, &amp;z) if x &gt; y &#123; x, y = y, x &#125; if x &gt; z &#123; x, z = z, x &#125; if y &gt; z &#123; y, z = z, y &#125; fmt.Println(x, y, z)&#125; 输入：15 20 2运行结果：2 15 20 十一、求S=a+aa+aaa+aaaa+aa…a的值，其中a是一个数字。例如2+22+222+2222+22222（此时共有5个数相加），几个数相加由键盘控制。1234567891011121314151617package mainimport \"fmt\"func main() &#123; test(5, 2)&#125;func test(n int, m int) &#123; a := 0 sum := 0 for i := 0; i &lt; n; i++ &#123; a = (a * 10) + m sum += a &#125; fmt.Println(\"sum=\", sum)&#125; 运行结果：sum= 24690 十二、古典问题：有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？共12个月分析：从第三个月开始每个月的兔子总数为前两个月的兔子数量的和，因为上一个月的兔子到这个月都不生兔子，而上上一个月的兔子到这个月都会再生一对儿兔子，所以这个月新出生的兔子数量与上上个月的兔子总数相同。例如： 6月的兔子总数 = 5月的兔子总数 + 6月新出生的兔子的数量6月的兔子总数 = 5月的兔子总数 + 4月的兔子总数 123456789101112131415package mainimport \"fmt\"func main() &#123; a := 1 b := 1 var c int for i := 1; i &lt;= 12; i++ &#123; a = b b = c c = a + b fmt.Print(c,\"\\t\") &#125;&#125; 运行结果：1 1 2 3 5 8 13 21 34 55 89 144这里还可以用递归方法做，12个月的兔子数量正好是一个斐波那契数列。 十三、猴子分桃：海滩上有一堆桃子，五只猴子来分。第一只猴子把这堆桃子平均分为五份，多了一个，这只猴子把多的一个扔入海中，拿走了一份。第二只猴子把剩下的桃子又平均分成五份，又多了一个，它同样把多的一个扔入海中，拿走了一份，第三、第四、第五只猴子都是这样做的，问海滩上原来最少有多少个桃子？分析：假如第五只猴子拿走的一份正好是一颗桃子，则最后一堆桃子数是：5+1=6（颗）。 1234567891011121314151617181920212223242526package mainimport \"fmt\"func main() &#123; num := 6 for &#123; num = num + 5 count := num monkey := 0 for i := 0; i &lt;= 5; i++ &#123; if (count-1)%5 == 0 &#123; count = (count - 1) / 5 * 4 monkey++ &#125; else &#123; break //如果不满足扔一个还能均分5份，就跳出内层循环，再给num加5 &#125; &#125; if monkey == 5 &#123; break //如果不满足monkey等于5，就一直循环 &#125; &#125; fmt.Println(num)&#125; 运行结果：3121 这里的很多题都有不止一种解法，就好像同样一种算法，可能每个人写的代码都不完全相同，有的可能逻辑更清晰，有的可能代码量更少，有的可能时间复杂度更低，实际开发中很多问题都需要针对不同的具体情况去优化。 版权声明：博客中的文章版权归博主所有，未经授权，禁止转载，转载请注明出处，合作请点击“关于我”，扫码添加微信","categories":[{"name":"go语言","slug":"go语言","permalink":"http://yoursite.com/categories/go语言/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"}]},{"title":"Redis开源库redigo的使用","slug":"Redis开源库redigo的使用","date":"2018-01-03T10:10:00.000Z","updated":"2018-08-23T09:17:59.491Z","comments":true,"path":"2018/01/03/Redis开源库redigo的使用/","link":"","permalink":"http://yoursite.com/2018/01/03/Redis开源库redigo的使用/","excerpt":"整理：房玉辉","text":"整理：房玉辉 博客：https://ElonJelinek.github.io打开终端，获取开源库redigo，完成后启动Redis服务123456789101112131415161718192021222324252627ElonJelinek:~ ElonJelinek$ go get github.com/garyburd/redigo/redisElonJelinek:~ ElonJelinek$ redis-server /usr/local/etc/redis.conf2273:C 23 Aug 15:22:52.471 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo2273:C 23 Aug 15:22:52.471 # Redis version=4.0.11, bits=64, commit=00000000, modified=0, pid=2273, just started2273:C 23 Aug 15:22:52.471 # Configuration loaded2273:M 23 Aug 15:22:52.473 * Increased maximum number of open files to 10032 (it was originally set to 256). _._ _.-``__ ''-._ _.-`` `. `_. ''-._ Redis 4.0.11 (00000000/0) 64 bit .-`` .-```. ```\\/ _.,_ ''-._ ( ' , .-` | `, ) Running in standalone mode |`-._`-...-` __...-.``-._|'` _.-'| Port: 6379 | `-._ `._ / _.-' | PID: 2273 `-._ `-._ `-./ _.-' _.-' |`-._`-._ `-.__.-' _.-'_.-'| | `-._`-._ _.-'_.-' | http://redis.io `-._ `-._`-.__.-'_.-' _.-' |`-._`-._ `-.__.-' _.-'_.-'| | `-._`-._ _.-'_.-' | `-._ `-._`-.__.-'_.-' _.-' `-._ `-.__.-' _.-' `-._ _.-' `-.__.-' 2273:M 23 Aug 15:22:52.474 # Server initialized2273:M 23 Aug 15:22:52.474 * DB loaded from disk: 0.000 seconds2273:M 23 Aug 15:22:52.474 * Ready to accept connections Goland编译器：123456789101112131415161718192021222324252627282930package mainimport ( \"github.com/garyburd/redigo/redis\" \"fmt\")func main() &#123;//连接Redis c, err := redis.Dial(\"tcp\", \"127.0.0.1:6379\") if err != nil &#123; fmt.Println(\"Connect to redis error\", err) return &#125; defer c.Close()//存入数据 _, err = c.Do(\"SET\", \"myname\", \"lixunhuan\") if err != nil &#123; fmt.Println(\"redis set failed:\", err) &#125;//读取数据 username, err := redis.String(c.Do(\"GET\", \"myname\")) if err != nil &#123; fmt.Println(\"redis get failed:\", err) &#125; else &#123; fmt.Printf(\"Get myname: %v \\n\", username) &#125;&#125; 运行： 1Get myname: lixunhuan 查询值是否存在：1234567891011121314151617181920212223package mainimport ( \"github.com/garyburd/redigo/redis\" \"fmt\")func main() &#123; c, err := redis.Dial(\"tcp\", \"127.0.0.1:6379\") if err != nil &#123; fmt.Println(\"Connect to redis error\", err) return &#125; defer c.Close() is_key_exit, err := redis.Bool(c.Do(\"EXISTS\", \"myname\")) if err != nil &#123; fmt.Println(\"error:\", err) &#125; else &#123; fmt.Printf(\"exists or not: %v \\n\", is_key_exit) &#125;&#125; 运行： 1exists or not: true 删除值：123456789101112131415161718192021222324252627package mainimport ( \"github.com/garyburd/redigo/redis\" \"fmt\")func main() &#123; c, err := redis.Dial(\"tcp\", \"127.0.0.1:6379\") if err != nil &#123; fmt.Println(\"Connect to redis error\", err) return &#125; defer c.Close() _, err = c.Do(\"DEL\", \"myname\") if err != nil &#123; fmt.Println(\"redis delete failed:\", err) &#125; username, err := redis.String(c.Do(\"GET\", \"myname\")) if err != nil &#123; fmt.Println(\"reids get failed:\", err) &#125; else &#123; fmt.Printf(\"Get myname: %v \\n\", username) &#125;&#125; 运行： 1reids get failed: redigo: nil returned json串的存取123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport ( \"github.com/garyburd/redigo/redis\" \"fmt\" \"encoding/json\")func main() &#123; c, err := redis.Dial(\"tcp\", \"127.0.0.1:6379\") if err != nil &#123; fmt.Println(\"Connect to redis error\", err) return &#125; defer c.Close() key := \"varurr\" map1 := map[string]string&#123;\"name\": \"berry\", \"age\": \"22\"&#125; value, _ := json.Marshal(map1) n, err := c.Do(\"SETNX\", key, value) if err != nil &#123; fmt.Println(err) &#125; if n == int64(1) &#123; fmt.Println(\"success\") &#125; var map2 map[string]string getVlue, err := redis.Bytes(c.Do(\"GET\", key)) if err != nil &#123; fmt.Println(err) &#125; err = json.Unmarshal(getVlue, &amp;map2) if err != nil &#123; fmt.Println(err) &#125; fmt.Println(map2[\"name\"]) fmt.Println(map2[\"age\"])&#125; 运行： 123successberry22 版权声明：博客中的文章版权归博主所有，未经授权，禁止转载，转载请注明出处，合作请点击“关于我”，扫码添加微信","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"Redis数据库","slug":"Redis数据库","permalink":"http://yoursite.com/tags/Redis数据库/"}]},{"title":"Redis数据库的安装（Mac环境）","slug":"Redis数据库的安装","date":"2018-01-03T08:16:00.000Z","updated":"2018-08-23T10:32:52.096Z","comments":true,"path":"2018/01/03/Redis数据库的安装/","link":"","permalink":"http://yoursite.com/2018/01/03/Redis数据库的安装/","excerpt":"整理：房玉辉","text":"整理：房玉辉 博客：https://ElonJelinek.github.io1、利用Homebrew安装Redis打开终端，输入以下命令： brew install redis 会输出如下内容： 123456789101112（之前的输出省略）………………==&gt; Pouring redis--4.0.11.high_sierra.bottle.tar.gz==&gt; CaveatsTo have launchd start redis now and restart at login: brew services start redisOr, if you don't want/need a background service you can just run: redis-server /usr/local/etc/redis.conf==&gt; Summary🍺 /usr/local/Cellar/redis/4.0.11: 13 files, 2.8MB 到这里即安装完成。 启动Redis服务： redis-server 出现以下内容，说明安装成功，并启动成功 123456789101112131415161718192021222324（之前的输出省略）……………… _._ _.-``__ ''-._ _.-`` `. `_. ''-._ Redis 4.0.11 (00000000/0) 64 bit .-`` .-```. ```\\/ _.,_ ''-._ ( ' , .-` | `, ) Running in standalone mode |`-._`-...-` __...-.``-._|'` _.-'| Port: 6379 | `-._ `._ / _.-' | PID: 78083 `-._ `-._ `-./ _.-' _.-' |`-._`-._ `-.__.-' _.-'_.-'| | `-._`-._ _.-'_.-' | http://redis.io `-._ `-._`-.__.-'_.-' _.-' |`-._`-._ `-.__.-' _.-'_.-'| | `-._`-._ _.-'_.-' | `-._ `-._`-.__.-'_.-' _.-' `-._ `-.__.-' _.-' `-._ _.-' `-.__.-' 78083:M 23 Aug 14:39:07.868 # Server initialized78083:M 23 Aug 14:39:07.868 * Ready to accept connections 此时，该终端窗口会一直保持启动状态，不能再输入命令，要写入数据，需要另外开启一个终端窗口打开另一个终端窗口，启动Redis客户端 redis-cli 会输出如下内容，表示已经进入Redis客户端，之后可进行数据的读写操作 1127.0.0.1:6379&gt; 2、数据的增删改查Redis是key-value型数据库，输入key *可查看所有的key-value键值对 set为写入命令get为读取命令append为追加命令del为删除shutdown为关闭Redis服务 接下来依次输入一些数据，查看效果 1234567891011121314151617181920212223127.0.0.1:6379&gt; keys *(empty list or set)127.0.0.1:6379&gt; set name \"lucy\"OK127.0.0.1:6379&gt; get name \"lucy\"127.0.0.1:6379&gt; keys *1) \"name\"127.0.0.1:6379&gt; append name Tom(integer) 7127.0.0.1:6379&gt; get name\"lucyTom\"127.0.0.1:6379&gt; set age 22OK127.0.0.1:6379&gt; keys *1) \"name\"2) \"age\"127.0.0.1:6379&gt; del name(integer) 1127.0.0.1:6379&gt; get name(nil)127.0.0.1:6379&gt; shutdownnot connected&gt; 输入shutdown之后，Redis服务会被关闭，前一个终端窗口会输出如下内容 1234576944:M 23 Aug 17:57:40.220 # User requested shutdown...76944:M 23 Aug 17:57:40.220 * Saving the final RDB snapshot before exiting.76944:M 23 Aug 17:57:40.221 * DB saved on disk76944:M 23 Aug 17:57:40.221 # Redis is now ready to exit, bye bye...ElonJelinek:~ ElonJelinek$ 之后，第二个终端窗口用exit退出Redis客户端。 版权声明：博客中的文章版权归博主所有，未经授权，禁止转载，转载请注明出处，合作请点击“关于我”，扫码添加微信","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"Redis数据库","slug":"Redis数据库","permalink":"http://yoursite.com/tags/Redis数据库/"}]},{"title":"用go语言爬虫珍爱网所有城市网址","slug":"用go语言爬虫珍爱网所有城市网址","date":"2018-01-02T13:04:21.000Z","updated":"2018-07-28T10:45:36.912Z","comments":true,"path":"2018/01/02/用go语言爬虫珍爱网所有城市网址/","link":"","permalink":"http://yoursite.com/2018/01/02/用go语言爬虫珍爱网所有城市网址/","excerpt":"整理：房玉辉","text":"整理：房玉辉 博客：https://ElonJelinek.github.io爬虫珍爱网系列文章go语言爬虫入门第一课1、查看网站编码格式工具：GoLand，Chrome浏览器，珍爱网 所有城市页面 http://www.zhenai.com/zhenghun首先右键鼠标，查看网页源代码，查看网站编码格式，这里以gbk格式为例，， 123456789101112131415161718192021222324252627282930313233343536package mainimport ( \"net/http\" \"fmt\" \"golang.org/x/text/transform\" \"golang.org/x/text/encoding/simplifiedchinese\" \"io/ioutil\")const cityListURL = \"http://www.zhenai.com/zhenghun\"func main() &#123; resp, err := http.Get(cityListURL) if err != nil &#123; panic(err) //如果err不为空,说明出现错误数据，Panic结束程序。 &#125; defer resp.Body.Close() //关闭数据解析请求 if resp.StatusCode != http.StatusOK &#123; fmt.Println(\"Error:Status Code:\", resp.StatusCode) &#125; // 以gbk格式读取网站源代码， utf8Reader := transform.NewReader(resp.Body, simplifiedchinese.GBK.NewDecoder()) // 读取网页所有数据，ReadAll方法返回值为[]byte字节数组，和err allData, err1 := ioutil.ReadAll(utf8Reader) if err1 != nil &#123; panic(err1) &#125; // 将字节数组转换为字符串，并打印输出 fmt.Println(string(allData))&#125; 网站编码格式有很多种，比如还有utf-8等格式，为了更好的封装，我们来写个方法，自动判断网站的编码格式， 12345678func determinEncoding(r io.Reader) encoding.Encoding &#123; bytes, err := bufio.NewReader(r).Peek(1024) if err != nil &#123; return unicode.UTF8 &#125; e, _, _ := charset.DetermineEncoding(bytes, \"\") return e&#125; 该方法的参数是resp.body,返回值即是编码格式。 2、观察目标字段看一下需要获取的字段长什么样，Chrome浏览器查看，在goland控制台打印， 1234567891011121314&lt;dd&gt; &lt;a href=&quot;http://www.zhenai.com/zhenghun/eerduosi&quot; class=&quot;&quot;&gt;鄂尔多斯&lt;/a&gt; &lt;a href=&quot;http://www.zhenai.com/zhenghun/enshi&quot; class=&quot;&quot;&gt;恩施&lt;/a&gt; &lt;a href=&quot;http://www.zhenai.com/zhenghun/ezhou&quot; class=&quot;&quot;&gt;鄂州&lt;/a&gt; &lt;/dd&gt; 可以看到，目标字段是很简单的格式，很容易获取，每一个a标签就是一个目标字段，正则表达式为：&lt;a href=&quot;(http://www.zhenai.com/zhenghun/[a-z0-9]+)&quot;[^&gt;]+&gt;([^&lt;]+)&lt;/a&gt;该正则表达式中有两个()，第一个括号中为目标网址，第二个括号中为城市名。 3、获取目标字段123match := regexp.MustCompile(`&lt;a href=\"(http://www.zhenai.com/zhenghun/[a-z0-9]+)\"[^&gt;]+&gt;([^&lt;]+)&lt;/a&gt;`) bytes := match.FindAllSubmatch(allData, -1) regexp.MustCompile用来在文本中查找匹配正则表达式的内容。FindAllSubmatch方法的第2个参数表示查找次数，-1表示不限次数，查找多少次，就返回多少个字节数组；返回值是一个字节数组，里面有三个元素，是匹配到的结果，及其分组内容，返回值中的第 0 个元素是整个正则表达式的匹配结果，分组顺序按照“(”的出现次序而定，所以第 1 个元素是网址，第 2 个元素是城市名，接下来只需要遍历返回的字节数组，转化为字符串输出及得到最终结果。最后，全部代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package mainimport ( \"net/http\" \"fmt\" \"io/ioutil\" \"regexp\" \"io\" \"golang.org/x/text/encoding\" \"bufio\" \"golang.org/x/net/html/charset\" \"golang.org/x/text/transform\" \"golang.org/x/text/encoding/simplifiedchinese\")const cityListURL = \"http://www.zhenai.com/zhenghun\"func main() &#123; resp, err := http.Get(cityListURL) if err != nil &#123; panic(err) //如果err不为空,说明出现错误数据，Panic结束程序。 &#125; defer resp.Body.Close() //关闭数据解析请求 if resp.StatusCode != http.StatusOK &#123; fmt.Println(\"Error:Status Code:\", resp.StatusCode) &#125; utf8Reader := transform.NewReader(resp.Body, simplifiedchinese.GBK.NewDecoder()) //e := determinEncoding(resp.Body) //utf8Reader := transform.NewReader(resp.Body, e.NewDecoder()) allData, err1 := ioutil.ReadAll(utf8Reader) if err1 != nil &#123; panic(err1) &#125; //fmt.Println(string(allData)) match := regexp.MustCompile(`&lt;a href=\"(http://www.zhenai.com/zhenghun/[a-z0-9]+)\"[^&gt;]+&gt;([^&lt;]+)&lt;/a&gt;`) bytes := match.FindAllSubmatch(allData, 50) for key, value := range bytes &#123; fmt.Println(key+1, \"城市：\", string(value[2]), \"网址：\", string(value[1])) &#125;&#125;func determinEncoding(r io.Reader) encoding.Encoding &#123; bytes, err := bufio.NewReader(r).Peek(1024) if err != nil &#123; panic(err) &#125; e, _, _ := charset.DetermineEncoding(bytes, \"\") return e&#125; 结果如下： 1234561 城市： 阿坝 网址： http://www.zhenai.com/zhenghun/aba2 城市： 阿克苏 网址： http://www.zhenai.com/zhenghun/akesu......468 城市： 自贡 网址： http://www.zhenai.com/zhenghun/zigong469 城市： 资阳 网址： http://www.zhenai.com/zhenghun/ziyang1470 城市： 遵义 网址： http://www.zhenai.com/zhenghun/zunyi 版权声明：博客中的文章版权归博主所有，未经授权，禁止转载，转载请注明出处，合作请点击“关于我”，扫码添加微信","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/categories/爬虫/"}],"tags":[{"name":"go语言爬虫","slug":"go语言爬虫","permalink":"http://yoursite.com/tags/go语言爬虫/"}]},{"title":"在一台电脑上搭建etcd服务器集群","slug":"在一台电脑上搭建etcd服务器集群","date":"2017-12-31T11:26:08.000Z","updated":"2018-07-28T10:44:19.173Z","comments":true,"path":"2017/12/31/在一台电脑上搭建etcd服务器集群/","link":"","permalink":"http://yoursite.com/2017/12/31/在一台电脑上搭建etcd服务器集群/","excerpt":"整理：房玉辉","text":"整理：房玉辉 博客：https://ElonJelinek.github.io在同一台电脑上开启三个节点 进入etcd/bin目录：cd go/src/github.com/coreos/etcd/bin 节点1打开第一个终端，进入etcd/bin目录执行: 1./etcd --name cd0 --initial-advertise-peer-urls http://127.0.0.1:2380 --listen-peer-urls http://127.0.0.1:2380 --listen-client-urls http://127.0.0.1:2379 --advertise-client-urls http://127.0.0.1:2379 --initial-cluster-token etcd-cluster-1 --initial-cluster cd0=http://127.0.0.1:2380,cd1=http://127.0.0.1:2480,cd2=http://127.0.0.1:2080 --initial-cluster-state new 节点2打开第二个终端，进入etcd/bin目录执行: 1./etcd --name cd1 --initial-advertise-peer-urls http://127.0.0.1:2480 --listen-peer-urls http://127.0.0.1:2480 --listen-client-urls http://127.0.0.1:2479 --advertise-client-urls http://127.0.0.1:2479 --initial-cluster-token etcd-cluster-1 --initial-cluster cd0=http://127.0.0.1:2380,cd1=http://127.0.0.1:2480,cd2=http://127.0.0.1:2080 --initial-cluster-state new 节点3打开第三个终端，进入etcd/bin目录执行: 1./etcd --name cd2 --initial-advertise-peer-urls http://127.0.0.1:2080 --listen-peer-urls http://127.0.0.1:2080 --listen-client-urls http://127.0.0.1:2079 --advertise-client-urls http://127.0.0.1:2079 --initial-cluster-token etcd-cluster-1 --initial-cluster cd0=http://127.0.0.1:2380,cd1=http://127.0.0.1:2480,cd2=http://127.0.0.1:2080 --initial-cluster-state new 查询 member 列表新开一个终端，进入etcd/bin目录，执行: 1234export ETCDCTL_API=3ENDPOINTS=127.0.0.1:2379,127.0.0.1:2479,127.0.0.1:2079./etcdctl --endpoints=$ENDPOINTS member list 运行结果： 1237a46237d7e589f81, started, cd2, http://127.0.0.1:2080, http://127.0.0.1:2079bf9071f4639c75cc, started, cd0, http://127.0.0.1:2380, http://127.0.0.1:2379e3ba87c3b4858ef1, started, cd1, http://127.0.0.1:2480, http://127.0.0.1:2479 在终端手动添加 member 节点member add 添加节点 1./etcdctl --endpoints=$ENDPOINTS member add cd3 --peer-urls=http://127.0.0.1:2180 运行结果 1234ETCD_NAME=&quot;cd3&quot;ETCD_INITIAL_CLUSTER=&quot;cd2=http://127.0.0.1:2080,cd0=http://127.0.0.1:2380,cd3=http://127.0.0.1:2180,cd1=http://127.0.0.1:2480&quot;ETCD_INITIAL_ADVERTISE_PEER_URLS=&quot;http://127.0.0.1:2180&quot;ETCD_INITIAL_CLUSTER_STATE=&quot;existing&quot; 查询 member 节点列表信息 1./etcdctl --endpoints=$ENDPOINTS member list 运行结果： 12347a46237d7e589f81, started, cd2, http://127.0.0.1:2080, http://127.0.0.1:2079bf9071f4639c75cc, started, cd0, http://127.0.0.1:2380, http://127.0.0.1:2379c886a1da995d65c1, unstarted, , http://127.0.0.1:2180, e3ba87c3b4858ef1, started, cd1, http://127.0.0.1:2480, http://127.0.0.1:2479 通过查询结果可以发现：http://127.0.0.1:2180 显示状态为：unstarted 启动新节点 1./etcd --name cd3 --listen-client-urls http://127.0.0.1:2179 --advertise-client-urls http://127.0.0.1:2179 --listen-peer-urls http://127.0.0.1:2180 --initial-advertise-peer-urls http://127.0.0.1:2180 --initial-cluster-state existing --initial-cluster cd2=http://127.0.0.1:2080,cd0=http://127.0.0.1:2380,cd3=http://127.0.0.1:2180,cd1=http://127.0.0.1:2480 --initial-cluster-token etcd-cluster-1 查询 member 节点列表信息 1./etcdctl --endpoints=$ENDPOINTS member list 运行结果： 12347a46237d7e589f81, started, cd2, http://127.0.0.1:2080, http://127.0.0.1:2079bf9071f4639c75cc, started, cd0, http://127.0.0.1:2380, http://127.0.0.1:2379c886a1da995d65c1, started, cd3, http://127.0.0.1:2180, http://127.0.0.1:2179e3ba87c3b4858ef1, started, cd1, http://127.0.0.1:2480, http://127.0.0.1:2479 代码实现 member 的管理添加节点12345678910111213func addMember(cli *clientv3.Client, peerURLs []string) &#123; // //向系统中插入节点 _, err := cli.MemberAdd(context.Background(), peerURLs) if err != nil &#123; fmt.Println(\"MemberAdd\", err) &#125; //显示刚才插入节点信息 resp, err := cli.MemberList(context.Background()) if err != nil &#123; fmt.Println(\"MemberList\", err) &#125; fmt.Println(\"添加后的members为\", resp.Members)&#125; 1234567891011121314151617181920var ( dialTimeout = 5 * time.Second requestTimeout = 2 * time.Second endpoints = []string&#123;\"127.0.0.1:2379\"&#125;)//在main函数中调用addMember，添加端口为2280的节点func main() &#123; cli, err := clientv3.New(clientv3.Config&#123; Endpoints: endpoints, DialTimeout: dialTimeout, &#125;) if err != nil &#123; fmt.Println(\"clientv3.New\", err) &#125; defer cli.Close() peerURLs := []string&#123;\"http://127.0.0.1:2280\"&#125; addMember(cli, peerURLs)&#125; Goland控制台运行结果 1添加后的members为 [ID:2468423305315244021 peerURLs:\"http://127.0.0.1:2280\" ID:8810768742894575489 name:\"cd2\" peerURLs:\"http://127.0.0.1:2080\" clientURLs:\"http://127.0.0.1:2079\" ID:13803658152347727308 name:\"cd0\" peerURLs:\"http://127.0.0.1:2380\" clientURLs:\"http://127.0.0.1:2379\" ID:14449414414712792513 name:\"cd3\" peerURLs:\"http://127.0.0.1:2180\" clientURLs:\"http://127.0.0.1:2179\" ID:16409577466894847729 name:\"cd1\" peerURLs:\"http://127.0.0.1:2480\" clientURLs:\"http://127.0.0.1:2479\" ] etcd没有提供用代码启动节点的方法，因此，执行完添加节点，需要打开终端手动启动节点，启动节点之后，才能再次添加节点（即一次只能添加一个节点，不能连续添加）。 1./etcd --name cd4 --listen-client-urls http://127.0.0.1:2279 --advertise-client-urls http://127.0.0.1:2279 --listen-peer-urls http://127.0.0.1:2280 --initial-advertise-peer-urls http://127.0.0.1:2180 --initial-cluster-state existing --initial-cluster cd2=http://127.0.0.1:2080,cd4=http://127.0.0.1:2280,cd0=http://127.0.0.1:2380,cd3=http://127.0.0.1:2180,cd1=http://127.0.0.1:2480 --initial-cluster-token etcd-cluster-1 查询 member 节点列表信息新开一个终端，进入etcd/bin目录，不要导入API，直接查询member列表 1./etcdctl --endpoints=$ENDPOINTS member list 运行结果 12345224199eafc9c57f5: name=cd4 peerURLs=http://127.0.0.1:2280 clientURLs=http://127.0.0.1:2279 isLeader=false7a46237d7e589f81: name=cd2 peerURLs=http://127.0.0.1:2080 clientURLs=http://127.0.0.1:2079 isLeader=falsebf9071f4639c75cc: name=cd0 peerURLs=http://127.0.0.1:2380 clientURLs=http://127.0.0.1:2379 isLeader=truec886a1da995d65c1: name=cd3 peerURLs=http://127.0.0.1:2180 clientURLs=http://127.0.0.1:2179 isLeader=falsee3ba87c3b4858ef1: name=cd1 peerURLs=http://127.0.0.1:2480 clientURLs=http://127.0.0.1:2479 isLeader=false 启动后etcd/bin目录如图 删除 member删除节点cd4 1./etcdctl --endpoints=$ENDPOINTS member remove 224199eafc9c57f5 运行结果： 1Removed member 224199eafc9c57f5 from cluster 查询 member 节点列表信息 1./etcdctl --endpoints=$ENDPOINTS member list 运行结果： 12347a46237d7e589f81: name=cd2 peerURLs=http://127.0.0.1:2080 clientURLs=http://127.0.0.1:2079 isLeader=falsebf9071f4639c75cc: name=cd0 peerURLs=http://127.0.0.1:2380 clientURLs=http://127.0.0.1:2379 isLeader=truec886a1da995d65c1: name=cd3 peerURLs=http://127.0.0.1:2180 clientURLs=http://127.0.0.1:2179 isLeader=falsee3ba87c3b4858ef1: name=cd1 peerURLs=http://127.0.0.1:2480 clientURLs=http://127.0.0.1:2479 isLeader=false 在Goland用程序删除节点 12345678func delMember(cli *clientv3.Client, memberId uint64) &#123; _, err := cli.MemberRemove(context.Background(), memberId) if err != nil &#123; fmt.Println(\"delMember\", err) &#125; else &#123; fmt.Printf(\"删除节点%d成功\\n\", memberId) &#125;&#125; 1234567891011121314151617//在main函数中调用delMember，删除端口为2180的节点，即节点cd3func main() &#123; cli, err := clientv3.New(clientv3.Config&#123; Endpoints: endpoints, DialTimeout: dialTimeout, &#125;) if err != nil &#123; fmt.Println(\"clientv3.New\", err) &#125; defer cli.Close() //第一种写法，14449414414712792513为Goland控制台输出的十进制ID //delMember(cli, 14449414414712792513) //第二种写法，c886a1da995d65c1为终端输出的十六进制ID delMember(cli, uint64(0xc886a1da995d65c1)) //2180，cd3&#125; Goland控制台运行结果 1删除节点14449414414712792513成功 版权声明：博客中的文章版权归博主所有，未经授权，禁止转载，转载请注明出处，合作请点击“关于我”，扫码添加微信","categories":[{"name":"分布式系统","slug":"分布式系统","permalink":"http://yoursite.com/categories/分布式系统/"}],"tags":[{"name":"单机模拟etcd服务器集群","slug":"单机模拟etcd服务器集群","permalink":"http://yoursite.com/tags/单机模拟etcd服务器集群/"}]},{"title":"go语言链表","slug":"go语言链表","date":"2017-12-27T14:13:00.000Z","updated":"2018-07-28T12:03:13.200Z","comments":true,"path":"2017/12/27/go语言链表/","link":"","permalink":"http://yoursite.com/2017/12/27/go语言链表/","excerpt":"整理：房玉辉","text":"整理：房玉辉 博客：https://ElonJelinek.github.io1、什么是链表：链表是一种数据存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列节点组成，节点可以在运行时动态生成。每个节点包括两个部分 存储数据元素的数据域存储下一个节点地址的地址域 2、链表与数组的区别： 数组长度固定，链表长度不固定数组的内存地址是连续的，链表的内存地址是不连续的数组可以随机读取，链表不可以随机读取数组内存空间开销比链表小，因为链表增加了地址域 3、链表结构： 数据域地址域第一个节点称为头节点，最后一个节点称为尾节点 123456type Node struct &#123; //数据域 Data string //地址域 NextNode *Node&#125; //声明全局变量，保存头节点和当前节点 var head *Node //头节点var curr *Node //当前节点、最新节点 创建头节点 12345678910func CreateHeadNode(data string) *Node &#123; var node = new(Node) node.Data = data node.NextNode = nil //保存头节点 head = node //保存当前节点 curr = node return node&#125; 添加节点 1234567891011func AddNode(data string) *Node &#123; var newNode = new(Node) newNode.Data = data newNode.NextNode = nil //挂接节点，当前节点的后节点为新节点 curr.NextNode = newNode //更新当前节点 curr = newNode return newNode&#125; 遍历链表 123456789101112131415func ShowNodes() &#123; fmt.Println(\"------------------\") fmt.Println(\"遍历节点：\") var node = head for &#123; //若遍历到某个节点，它的后节点为nil，则该节点为最后一个节点，则跳出循环 if node.NextNode == nil &#123; fmt.Print(node.Data, \"\\n\") break &#125; else &#123; fmt.Println(node.Data) node = node.NextNode &#125; &#125;&#125; 统计节点个数 1234567891011121314func NodeCount() int &#123; var node = head var count = 0 for &#123; count++ if node.NextNode == nil &#123; //到最后一个节点的时候，跳出循环 break &#125; node = node.NextNode &#125; //fmt.Println(\"总共有\", count, \"个节点。\") return count&#125; 在指定位置插入节点： 如果index为0，则插入的节点为头节点；如果index大于当前节点总数，则插入的节点为尾节点，直接调用AddNode()方法即可；如果index既不为0，又大于当前节点的index，则属于在两个节点中间插入节点，需要先找到index-1这个目标节点，再将找到的该目标节点的后一个节点指向新添加的节点的后节点，再将目标节点的后节点指向新添加的节点。 1234567891011121314151617181920212223func InsertNodeByIndex(index int, data string) &#123; if index == 0 &#123; var node = new(Node) node.Data = data node.NextNode = head head = node &#125; else if index &gt; NodeCount()-1 &#123; AddNode(data) &#125; else &#123; var n = head //找到目标节点，即index-1节点 for i := 0; i &lt; index-1; i++ &#123; n = n.NextNode &#125; var newNode = new(Node) newNode.Data = data //将新节点的后节点指向目标节点的后节点 newNode.NextNode = n.NextNode //目标节点的后节点指向新节点 n.NextNode = newNode &#125;&#125; 修改指定节点的内容 1234567891011func UpdateNodeByIndex(index int, data string) &#123; var node = head if index == 0 &#123; head.Data = data &#125; else &#123; for i := 0; i &lt; index; i++ &#123; node = node.NextNode &#125; node.Data = data &#125;&#125; 删除指定节点 1234567891011func DeleteNodeByIndex(index int) &#123; var node = head if index == 0 &#123; head = node.NextNode &#125; else &#123; for i := 0; i &lt; index-1; i++ &#123; node = node.NextNode &#125; node.NextNode = node.NextNode.NextNode &#125;&#125; 这是最简单的链表形式，实际中链表还分为单向链表，双向链表，循环链表，并且链表存储的数据可以是多种类型。而更新节点，删除、插入节点也要考虑更多方面。这里只是简单介绍一下。 版权声明：博客中的文章版权归博主所有，未经授权，禁止转载，转载请注明出处，合作请点击“关于我”，扫码添加微信","categories":[{"name":"go语言","slug":"go语言","permalink":"http://yoursite.com/categories/go语言/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://yoursite.com/tags/链表/"}]},{"title":"二叉树的GO语言实现","slug":"二叉树的GO语言实现","date":"2017-12-13T12:40:00.000Z","updated":"2018-08-10T07:48:54.585Z","comments":true,"path":"2017/12/13/二叉树的GO语言实现/","link":"","permalink":"http://yoursite.com/2017/12/13/二叉树的GO语言实现/","excerpt":"整理：房玉辉","text":"整理：房玉辉 博客：https://ElonJelinek.github.io二叉树的GO语言实现相关函数与方法 12345678910111213Insert()插入节点Max()找出最大值Min()找出最小值String()格式化输出Search()搜索某个值是否存在Remove()删除节点PreOrderTraverse()前序遍历InOrderTraverse()中序遍历PostOrderTraverse()后序遍历breadthFirstTraverse()广度优先遍历getCount()统计节点个数GetLeafCount()统计叶子节点个数GetDepth()二叉树的深度 代码实现： 12345678910111213141516171819202122package mainimport ( \"sync\" \"fmt\")type Item interface&#123;&#125;//节点的结构type Node struct &#123; key int value Item Left *Node Right *Node&#125;//树的结构type BinarySearchTree struct &#123; root *Node lock sync.RWMutex&#125; 插入节点 1234567891011121314151617181920212223242526272829//插入节点func (tree *BinarySearchTree) Insert(key int, value Item) &#123; tree.lock.Lock() defer tree.lock.Unlock() node := &amp;Node&#123;key, value, nil, nil&#125; if tree.root == nil &#123; tree.root = node &#125; else &#123; insertNode(tree.root, node) &#125;&#125;func insertNode(node, newNode *Node) &#123; if newNode.key &lt; node.key &#123; if node.Left == nil &#123; node.Left = newNode &#125; else &#123; insertNode(node.Left, newNode) &#125; &#125; else &#123; if node.Right == nil &#123; node.Right = newNode &#125; else &#123; insertNode(node.Right, newNode) &#125; &#125;&#125; 找出最大节点 123456789101112131415func (tree *BinarySearchTree) Max() *Item &#123; tree.lock.Lock() defer tree.lock.Unlock() node := tree.root if node == nil &#123; return nil &#125; for &#123; if node.Right == nil &#123; return &amp;node.value &#125; node = node.Right &#125;&#125; 最小节点 123456789101112131415func (tree *BinarySearchTree) Min() *Item &#123; tree.lock.Lock() defer tree.lock.Unlock() node := tree.root if node == nil &#123; return nil &#125; for &#123; if node.Left == nil &#123; return &amp;node.value &#125; node = node.Left &#125;&#125; 格式化输出二叉树 12345678910111213141516171819202122func (tree *BinarySearchTree) String() &#123; tree.lock.Lock() defer tree.lock.Unlock() fmt.Println(\"-----------------------------\") stringify(tree.root, 0) fmt.Println(\"-----------------------------\")&#125;func stringify(node *Node, level int) &#123; if node != nil &#123; format := \"\" for i := 0; i &lt; level; i++ &#123; format += \" \" &#125; format += \"---[ \" level++ stringify(node.Right, level) fmt.Printf(format+\"%d\\n\", node.key) stringify(node.Left, level) &#125;&#125; 查找是否存在某个节点 12345678910111213141516171819202122func (tree *BinarySearchTree) Search(key int) bool &#123; tree.lock.Lock() defer tree.lock.Unlock() fmt.Print(\"是否存在节点\", key, \"：\") return search(tree.root, key)&#125;func search(node *Node, key int) bool &#123; if node == nil &#123; return false &#125; if key &lt; node.key &#123; return search(node.Left, key) &#125; if key &gt; node.key &#123; return search(node.Right, key) &#125; return true&#125; 删除节点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950func (tree *BinarySearchTree) Remove(key int) &#123; tree.lock.Lock() defer tree.lock.Unlock() fmt.Println(\"删除节点：\", key) remove(tree.root, key)&#125;func remove(node *Node, key int) *Node &#123; if node == nil &#123; return nil &#125; if key &lt; node.key &#123; node.Left = remove(node.Left, key) return node &#125; if key &gt; node.key &#123; node.Right = remove(node.Right, key) return node &#125; if node.Left == nil &amp;&amp; node.Right == nil &#123; node = nil return node &#125; if node.Left == nil &#123; node = node.Right return node &#125; if node.Right == nil &#123; node = node.Left return node &#125; mostRightNode := node.Left for &#123; if mostRightNode != nil &amp;&amp; mostRightNode.Right != nil &#123; mostRightNode = mostRightNode.Right &#125; else &#123; break &#125; &#125; node.key, node.value = mostRightNode.key, mostRightNode.value node.Left = remove(node.Left, node.key) return node&#125; 深度优先遍历：前序遍历，中序遍历，后序遍历是深度优先遍历的三种形式。前序遍历 1234567891011121314151617func (tree *BinarySearchTree) PreOrderTraverse() &#123; tree.lock.Lock() defer tree.lock.Unlock() fmt.Println(\"前序遍历：\") node := tree.root preOrder(node) fmt.Println()&#125;func preOrder(node *Node) &#123; if node == nil &#123; return &#125; fmt.Print(node.value, \"\\t\") preOrder(node.Left) preOrder(node.Right)&#125; 中序遍历 12345678910111213141516func (tree *BinarySearchTree) InOrderTraverse() &#123; tree.lock.Lock() defer tree.lock.Unlock() fmt.Println(\"中序遍历：\") node := tree.root inOrder(node) fmt.Println()&#125;func inOrder(node *Node) &#123; if node != nil &#123; inOrder(node.Left) fmt.Print(node.value, \"\\t\") inOrder(node.Right) &#125;&#125; 后序遍历 12345678910111213141516func (tree *BinarySearchTree) PostOrderTraverse() &#123; tree.lock.Lock() defer tree.lock.Unlock() fmt.Println(\"后序遍历：\") node := tree.root postOrder(node) fmt.Println()&#125;func postOrder(node *Node) &#123; if node != nil &#123; postOrder(node.Left) postOrder(node.Right) fmt.Print(node.value, \"\\t\") &#125;&#125; 广度优先遍历： 12345678910111213141516171819func (tree *BinarySearchTree) breadthFirstTraverse(node *Node) &#123; fmt.Println(\"广度优先遍历：\") var result []Item var nodes = []Node&#123;*node&#125; for len(nodes) &gt; 0 &#123; node := nodes[0] nodes = nodes[1:] result = append(result, node.value) if node.Left != nil &#123; nodes = append(nodes, *node.Left) &#125; if node.Right != nil &#123; nodes = append(nodes, *node.Right) &#125; &#125; fmt.Println(result)&#125; 统计节点的个数 123456func getCount(node *Node) int &#123; if node == nil &#123; return 0 &#125; return getCount(node.Left) + getCount(node.Right) + 1&#125; 统计叶子节点的个数 123456789101112func GetLeafCount(node *Node) int &#123; if node == nil &#123; return 0 &#125; var sum = 0 if node.Left == nil &amp;&amp; node.Right == nil &#123; return 1 &#125; sum += GetLeafCount(node.Left) sum += GetLeafCount(node.Right) return sum&#125; 二叉树的深度 1234567891011121314func GetDepth(node *Node) int &#123; if node == nil &#123; return 0 &#125; return max(GetDepth(node.Left), GetDepth(node.Right)) + 1&#125;func max(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125; 运行结果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849----------------------------- ---[ 16 ---[ 14 ---[ 13 ---[ 12 ---[ 10 ---[ 9---[ 8 ---[ 7 ---[ 6 ---[ 5 ---[ 4 ---[ 3 ---[ 2 ---[ 1 ---[ 0-----------------------------最大值是： 16最小值是： 0是否存在节点11：false删除节点： 8----------------------------- ---[ 16 ---[ 14 ---[ 13 ---[ 12 ---[ 10 ---[ 9---[ 7 ---[ 6 ---[ 5 ---[ 4 ---[ 3 ---[ 2 ---[ 1 ---[ 0-----------------------------前序遍历：7 4 2 1 0 3 6 5 13 10 9 12 16 14 中序遍历：0 1 2 3 4 5 6 7 9 10 12 13 14 16 后序遍历：0 1 3 2 5 6 4 9 12 10 14 16 13 7 共有 14 个节点。叶子节点的个数为： 6二叉树的深度为： 5广度优先遍历：[7 4 13 2 6 10 16 1 3 5 9 12 14 0] 版权声明：博客中的文章版权归博主所有，未经授权，禁止转载，转载请注明出处，合作请点击“关于我”，扫码添加微信","categories":[{"name":"go语言","slug":"go语言","permalink":"http://yoursite.com/categories/go语言/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"http://yoursite.com/tags/二叉树/"}]},{"title":"用go语言简单实现SHA256哈希算法","slug":"用go语言简单实现SHA256哈希算法","date":"2017-12-01T15:36:20.000Z","updated":"2018-07-28T10:49:15.518Z","comments":true,"path":"2017/12/01/用go语言简单实现SHA256哈希算法/","link":"","permalink":"http://yoursite.com/2017/12/01/用go语言简单实现SHA256哈希算法/","excerpt":"整理：房玉辉","text":"整理：房玉辉 博客：https://ElonJelinek.github.io用go语言简单实现SHA256哈希算法：12345678910111213141516package mainimport ( \"crypto/sha256\" \"fmt\")func main() &#123; string := \"Hello\" //需要哈希的字符串内容 hash := sha256.New() //声明sha256哈希函数 hash.Write([]byte(string)) bs := hash.Sum(nil) fmt.Printf(\"%x\", bs)&#125; 运行结果：185f8db32271fe25f561a6fc938b2e264306ec304eda518007d1764826381969其中，hash.Write()写入需要生成哈希的内容，h.Sum()添加额外的[]byte到当前的哈希中。 生成符合某一条件的哈希：12345678910111213141516171819202122232425262728293031323334353637383940package mainimport ( \"fmt\" \"crypto/sha256\")func isvhd(hash string, diff int) bool &#123; var i int for i = 0; i &lt; len(hash); i++ &#123; if hash[i] != '8' &#123; //哈希字符串的前diff个字符是否为8，如果不为8，结束循环。 break &#125; &#125; return i &gt;= diff&#125;func main() &#123; nonce := 0 hash := \"\" shaobj := sha256.New() prehash := \"0000fedaa499741317a18f1ad626f933776ad24822cb422634978bfe8005c94b\" //prehash := \"185f8db32271fe25f561a6fc938b2e264306ec304eda518007d1764826381969\" count := 0 //循环的次数 for !isvhd(hash, 4) &#123; nonce++ input := \"100\" + prehash + \"Thu, 26 Apr 2018 03:30:54 GMT\" + \"A -&gt; B 1000\" + string(nonce) shaobj.Write([]byte(input)) hash = fmt.Sprintf(\"%x\", shaobj.Sum(nil)) fmt.Println(hash) count++ &#125; fmt.Println(\"count:\", count) fmt.Println(\"nonce:\", nonce) fmt.Println(hash) fmt.Println(len(hash)) //哈希字符串的长度&#125; 运行结果：············0c7d465c78faf8dcc359343df18d535497b6dee228577f84b236e908193c65228888448863c33dff9acdc99dc6b85ca3329716c4d6fa3f51a540e2b977347ac6count: 11743nonce: 117438888448863c33dff9acdc99dc6b85ca3329716c4d6fa3f51a540e2b977347ac664 分析：isvhd（）函数用来判断生成的哈希内容是否满足某一条件，此处为判断生成的哈希数，前4位数是否为8。若不满足这一条件，则给nonce加1，再次生成哈希，直到生成一个前4位数均为8的哈希，结束循环。生成了一个前四位数为8的哈希，哈希字符串长度为64，循环了11743次。","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"sha256哈希算法","slug":"sha256哈希算法","permalink":"http://yoursite.com/tags/sha256哈希算法/"}]},{"title":"mac下生成RSA私钥和公钥","slug":"mac下生成rsa私钥和公钥","date":"2017-11-30T13:26:05.000Z","updated":"2018-07-28T10:41:32.270Z","comments":true,"path":"2017/11/30/mac下生成rsa私钥和公钥/","link":"","permalink":"http://yoursite.com/2017/11/30/mac下生成rsa私钥和公钥/","excerpt":"整理：房玉辉","text":"整理：房玉辉 博客：https://ElonJelinek.github.io第一种方式（执行第2步之后，需要输入两次开机密码）：打开终端：输入：openssl依次输入命令：1、制作私钥genrsa -out rsa_private_key.pem 20482、设置私钥为PKCS8格式pkcs8 -topk8 -inform PEM -in rsa_private_key.pem -outform PEM 注意：执行完第2步，终端会输出以—–BEGIN ENCRYPTED PRIVATE KEY—–开头，以—–END ENCRYPTED PRIVATE KEY—–结尾的私钥，不是RSA私钥：记住不要用此私钥，可以把这里的私钥保存一下，查看其长度，为1784。此时，/Users/（用户名）目录下也有了名为rsa_private_key.pem的私钥文件，可用记事本查看一下，是以—–BEGIN RSA PRIVATE KEY—–开头，以—–END RSA PRIVATE KEY—–结尾。这才是RSA私钥。3、通过私钥产生公钥rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem执行完第三步/Users/（用户名）目录下就已经有了两个文件：rsa_private_key.pemrsa_public_key.pem前者为私钥，后者为公钥。此时可以用记事本打开文件，公钥长度为450，私钥长度为1678，私钥与刚才控制台输出的私钥不一样也可以用命令行在终端查看秘钥：cat /Users/charlienike/rsa_private_key.pem### 第二种方式（不需要输密码）：打开终端：输入 openssl依次输入命令：1、genrsa -out rsa_private_key.pem 20482、pkcs8 -topk8 -inform PEM -in rsa_private_key.pem -outform PEM –nocrypt3、rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem命令执行过程中控制台不会输出私钥最后/Users/(用户名)目录下会生成两个文件，一个公钥，一个私钥，用记事本打开（或者用终端：cat 文件路径），公钥长度为450，私钥长度为1674。私钥的长度与第一种方式生成的私钥不一样长（1678、1674）。 注意：RSA私钥是以—–BEGIN RSA PRIVATE KEY—–开头，以—–END RSA PRIVATE KEY—–结尾，公钥是以—–BEGIN PUBLIC KEY—–开头，以—–END PUBLIC KEY—–结尾，第一种方式执行过程中终端输出的并不是RSA私钥。两种方式的不同是第二种方式的第2条命令后面多了个–nocrypt，第二种方式执行过程中不会输出私钥，也不需要输入密码，因此推荐使用第二种方式，以避免混淆。 同理：如果要生成1024字节的秘钥，只需要将第1行命令最后的2048改成1024即可：rsa_private_key.pem 1024同样推荐使用第二种方式，因为不需要输密码，且不易混淆。若使用第一种方式，过程中终端输出的私钥同样不是以—–BEGIN RSA PRIVATE KEY—–开头，不是RSA私钥，长度为992。正确的秘钥，即在用户名目录下生成的两个秘钥文件，私钥长度为886，公钥长度为271。 版权声明：博客中的文章版权归博主所有，未经授权，禁止转载，转载请注明出处，合作请点击“关于我”，扫码添加微信","categories":[{"name":"密码学","slug":"密码学","permalink":"http://yoursite.com/categories/密码学/"}],"tags":[{"name":"RSA秘钥","slug":"RSA秘钥","permalink":"http://yoursite.com/tags/RSA秘钥/"}]},{"title":"快速排序算法","slug":"快速排序算法","date":"2017-11-28T14:19:00.000Z","updated":"2018-08-04T01:46:00.894Z","comments":true,"path":"2017/11/28/快速排序算法/","link":"","permalink":"http://yoursite.com/2017/11/28/快速排序算法/","excerpt":"整理：房玉辉","text":"整理：房玉辉 博客：https://ElonJelinek.github.io快速排序算法目前世界上一般情况下最好的算法是“快速排序算法”，该算法由英国计算机科学家托尼·霍尔于1961年发表，是迄今为止世界计算机产业中使用最多的排序算法。 什么是快速排序：快速排序强调少做事情，其原理大致如下： 首先，对一个无序数组，从中随机挑选一个，比如是68，这个被随机选中的数字被称为枢值，之后，把数组中的所有数字分成两部分，第一部分是大于等于68的，第二部分是小于68的。在第一部完成之后，无序数组就变得稍微有序一点了。 第二步，将上面得到的两个数组，分别采用第一步的方法各自再找一个枢值。对于第一部分数字，由于所有的数字都大于或等于68，因此，第二次随机挑选的枢值肯定是一个大于68的数字，比如79；类似的，对于第二部分由于所有数字都小于68，因此第二次随机挑选的枢值肯定小于它，比如15。接下来，再把两堆数字各自分成大于等于相应枢值的数组，以及小于枢值的数组。这样做下来，原来的一个数组就变成了四个小的数组，他们分别是小于15的数字，介于15到68之间的数字，介于68到79之间的数字，以及大于79的数字。 再接下来，用同样的方法，四组变八组，八组变十六组，很快所有的数字就排好序列了。快速排序与其他排序：快速排序通常情况下复杂度是N乘以log(N)，和归并排序相同。根据计算机科学的标准，它们同样好，不过在工程上，快速排序一般比归并排序块两倍，因此在工程上还是有意义的，这也是很多人用快速排序的原因。快速排序比归并排序快一些，可以在计算机科学上证明，这里打个比方，比较一下：假如有一个学区，里面有20000名高中生，如果让大家到一个超级大的学校上大课，从里面跳出学生中的尖子，效率一定不高。这就是冒泡排序，每个人都要和所有人比较。如果把这20000人放到10所学校中，每所学校都只有两千人，从各个学校各自跳出尖子生，再进行比较，效率就高的多了。这就是归并排序。如果先划出几个分数线，根据个人成绩的高低把20000名学生分到10所学校，第一所学校的学生成绩最好，第十所最差，再找出尖子生，那就容易多了，工作量最小。这就是快速排序，所以快速排序比归并排序要快。 代码实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344package mainimport ( \"fmt\")func main() &#123; arr := []int&#123;12, 12, 8, 9, 0, 18, 6, 2, 24, 4, 22, 13, 11, 3, 5, 12, 6&#125; quickSort(arr, 0, len(arr)-1) fmt.Println(arr)&#125;func quickSort(arr []int, left, right int) &#123; i := left j := right temp := arr[left] //枢值 for i != j &#123; for arr[j] &gt;= temp &amp;&amp; i &lt; j &#123; //从最后一个数开始，直到找到小于枢值的数，停止循环 j-- &#125; for arr[i] &lt;= temp &amp;&amp; i &lt; j &#123; //从第一个数开始，直到找到大于枢值的数，停止循环 i++ &#125; if i &lt; j &#123; arr[i], arr[j] = arr[j], arr[i] &#125; &#125; //最后，当i等于j的时候，i之前（包括i）是小于枢值的数字，i之后是大于枢值的数字，所以，将枢值与下标为i的数字互换，之后，分别处理枢值两边的数。 arr[i], arr[left] = temp, arr[i] //递归处理枢值左边未处理的 if left &lt; i-1 &#123; quickSort(arr, left, i-1) &#125; //递归处理枢值右边未处理的 if i != len(arr)-1 &amp;&amp; i+1 &lt; right &#123; quickSort(arr, i+1, right) &#125;&#125; 运行结果： 1[0 2 3 4 5 6 6 8 9 11 12 12 12 13 18 22 24] 快速排序通常是最好的算法，但是，在极端情况下，其复杂度是N的平方，和冒泡排序一样糟糕。而归并排序即使是在最坏的情况下，也能保证N乘以log(N)的复杂度。所以，并没有绝对最好的算法。 版权声明：博客中的文章版权归博主所有，未经授权，禁止转载，转载请注明出处，合作请点击“关于我”，扫码添加微信","categories":[{"name":"go语言","slug":"go语言","permalink":"http://yoursite.com/categories/go语言/"}],"tags":[{"name":"快速排序","slug":"快速排序","permalink":"http://yoursite.com/tags/快速排序/"}]},{"title":"Mac配置环境变量","slug":"Mac配置环境变量","date":"2017-03-26T10:58:09.000Z","updated":"2018-07-28T10:43:34.918Z","comments":true,"path":"2017/03/26/Mac配置环境变量/","link":"","permalink":"http://yoursite.com/2017/03/26/Mac配置环境变量/","excerpt":"整理：房玉辉","text":"整理：房玉辉 博客：https://ElonJelinek.github.io1、找到.bash_profile文件Mac上的环境变量都在隐藏文件.bash_profile里配置，该文件一般都在Mac的用户名目录下，打开访达，进入到用户名目录，按shift+command+•，就可以看见用户名目录下的所有文件（包括隐藏文件），如图，我的用户名为CharlieNike第三个文件.bash_profile就是Mac的配置环境变量的文件；或者打开终端，输入：ls -a，就可以看见用户名目录下的所有文件和文件夹（包括隐藏的）；如果用户名目录下没有该文件，说明之前未配置过环境变量，该文件不存在，就打开终端，输入： 1touch .bash_profile 创建.bash_profile文件。 2、编辑.bash_profile文件有了该文件之后，可用记事本打开，进行编辑；或者在终端输入： 1open -e .bash_profile 就可以调用记事本打开该文件，编辑完成后，保存退出。例如，我的golang的环境变量如下 12export GOPATH=/Users/charlienike/goexport PATH=/Users/charlienike/bin:$GOPATH/bin:$PATH 3、使配置生效编辑完成后，在终端输入： 1source .bash_profile 才能使刚刚配置的环境变量生效。 版权声明：博客中的文章版权归博主所有，未经授权，禁止转载，转载请注明出处，合作请点击“关于我”，扫码添加微信","categories":[{"name":"Mac操作","slug":"Mac操作","permalink":"http://yoursite.com/categories/Mac操作/"}],"tags":[{"name":"环境变量","slug":"环境变量","permalink":"http://yoursite.com/tags/环境变量/"}]}]}